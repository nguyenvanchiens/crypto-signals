<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Trading Signal Bot - Futures Long/Short</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #fff;
      min-height: 100vh;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    header {
      text-align: center;
      padding: 30px 0;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      margin-bottom: 30px;
    }

    header h1 {
      font-size: 2.5em;
      background: linear-gradient(45deg, #00d9ff, #00ff88);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 10px;
    }

    header p {
      color: #888;
      font-size: 1.1em;
    }

    .controls {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      margin-bottom: 30px;
      padding: 20px;
      background: rgba(255,255,255,0.05);
      border-radius: 15px;
    }

    .control-group {
      flex: 1;
      min-width: 200px;
    }

    .control-group label {
      display: block;
      margin-bottom: 8px;
      color: #00d9ff;
      font-weight: 500;
    }

    select, input {
      width: 100%;
      padding: 12px 15px;
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 8px;
      background: #1a1a2e;
      color: #fff;
      font-size: 1em;
      cursor: pointer;
    }

    select option {
      background: #1a1a2e;
      color: #fff;
      padding: 10px;
    }

    select:focus, input:focus {
      outline: none;
      border-color: #00d9ff;
    }

    button {
      padding: 12px 30px;
      background: linear-gradient(45deg, #00d9ff, #00ff88);
      border: none;
      border-radius: 8px;
      color: #1a1a2e;
      font-size: 1em;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(0, 217, 255, 0.4);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .signal-card {
      background: rgba(255,255,255,0.05);
      border-radius: 15px;
      padding: 25px;
      margin-bottom: 20px;
      border: 1px solid rgba(255,255,255,0.1);
    }

    .signal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      flex-wrap: wrap;
      gap: 10px;
    }

    .symbol-info {
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .symbol-name {
      font-size: 1.8em;
      font-weight: bold;
    }

    .price {
      font-size: 1.5em;
      color: #00ff88;
    }

    .signal-badge {
      padding: 10px 25px;
      border-radius: 25px;
      font-weight: bold;
      font-size: 1.2em;
      text-transform: uppercase;
    }

    .signal-long {
      background: linear-gradient(135deg, #1a1a2e 0%, #1a2e1f 100%);
      border: 1px solid #00ff8840;
      color: #fff;
    }

    .signal-short {
      background: linear-gradient(135deg, #1a1a2e 0%, #2d1f3d 100%);
      border: 1px solid #e040fb40;
      color: #fff;
    }

    .signal-wait {
      background: rgba(255,255,255,0.2);
      color: #fff;
    }

    .indicators-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }

    .indicator-box {
      background: rgba(0,0,0,0.3);
      padding: 15px;
      border-radius: 10px;
    }

    .indicator-box h4 {
      color: #888;
      font-size: 0.85em;
      text-transform: uppercase;
      margin-bottom: 8px;
    }

    .indicator-box .value {
      font-size: 1.3em;
      font-weight: bold;
    }

    .indicator-box .status {
      font-size: 0.9em;
      margin-top: 5px;
    }

    .bullish { color: #00ff88; }
    .bearish { color: #e040fb; }
    .neutral { color: #ffd700; }

    .trade-setup {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
      padding: 20px;
      background: rgba(0,0,0,0.3);
      border-radius: 10px;
      margin-bottom: 20px;
    }

    .trade-item {
      text-align: center;
    }

    .trade-item label {
      display: block;
      color: #888;
      font-size: 0.85em;
      margin-bottom: 5px;
    }

    .trade-item .value {
      font-size: 1.2em;
      font-weight: bold;
    }

    .entry { color: #00d9ff; }
    .stop-loss { color: #ff5252; }
    .take-profit { color: #00ff88; }

    .reasons {
      background: rgba(0,0,0,0.3);
      padding: 15px;
      border-radius: 10px;
    }

    .reasons h4 {
      color: #00d9ff;
      margin-bottom: 10px;
    }

    .reasons ul {
      list-style: none;
      padding-left: 0;
    }

    .reasons li {
      padding: 8px 0;
      border-bottom: 1px solid rgba(255,255,255,0.05);
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .reasons li:before {
      content: "‚Üí";
      color: #00d9ff;
    }

    .reasons li:last-child {
      border-bottom: none;
    }

    .position-calculator {
      background: rgba(255,255,255,0.05);
      border-radius: 15px;
      padding: 25px;
      margin-top: 30px;
    }

    .position-calculator h3 {
      color: #00d9ff;
      margin-bottom: 20px;
    }

    .calc-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }

    .calc-result {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
      padding: 20px;
      background: rgba(0,0,0,0.3);
      border-radius: 10px;
    }

    .loading {
      text-align: center;
      padding: 50px;
      color: #888;
    }

    .loading::after {
      content: "";
      display: inline-block;
      width: 30px;
      height: 30px;
      border: 3px solid rgba(0, 217, 255, 0.3);
      border-top-color: #00d9ff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-left: 10px;
      vertical-align: middle;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .multi-signals {
      display: grid;
      gap: 15px;
    }

    .mini-signal {
      display: grid;
      grid-template-columns: 1fr 1fr auto;
      gap: 20px;
      align-items: center;
      background: rgba(255,255,255,0.05);
      padding: 15px 20px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.1);
    }

    .mini-signal:hover {
      border-color: #00d9ff;
      cursor: pointer;
    }

    .mini-signal .symbol {
      font-weight: bold;
      font-size: 1.1em;
    }

    .mini-signal .price-info {
      color: #888;
    }

    .mini-signal .mini-badge {
      padding: 5px 15px;
      border-radius: 15px;
      font-size: 0.9em;
      font-weight: bold;
    }

    .confidence-bar {
      height: 6px;
      background: rgba(255,255,255,0.1);
      border-radius: 3px;
      overflow: hidden;
    }

    /* Order Entry Form */
    .order-entry {
      background: rgba(0,217,255,0.1);
      border: 1px solid #00d9ff;
      border-radius: 10px;
      padding: 20px;
      margin-top: 15px;
    }

    .order-entry h4 {
      color: #00d9ff;
      margin-bottom: 15px;
    }

    .order-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 10px;
      margin-bottom: 15px;
    }

    .order-grid input {
      padding: 10px;
      font-size: 0.95em;
    }

    .order-buttons {
      display: flex;
      gap: 10px;
    }

    .order-buttons button {
      flex: 1;
      padding: 12px;
    }

    .btn-long {
      background: linear-gradient(45deg, #0d7a3e, #10a050) !important;
      color: #fff !important;
    }

    .btn-short {
      background: linear-gradient(45deg, #7b1fa2, #ab47bc) !important;
      color: #fff !important;
    }

    /* Position History */
    .position-card {
      background: rgba(255,255,255,0.05);
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 10px;
      border-left: 4px solid #888;
    }

    .position-card.long {
      border-left-color: #00ff88;
    }

    .position-card.short {
      border-left-color: #e040fb;
    }

    .position-card.profit {
      background: rgba(0,255,136,0.1);
    }

    .position-card.loss {
      background: rgba(255,82,82,0.1);
    }

    .position-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .position-symbol {
      font-weight: bold;
      font-size: 1.1em;
    }

    .position-pnl {
      font-weight: bold;
      font-size: 1.2em;
    }

    .position-pnl.profit {
      color: #00ff88;
    }

    .position-pnl.loss {
      color: #ff5252;
    }

    .position-details {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      gap: 10px;
      font-size: 0.9em;
      color: #888;
    }

    .position-details span {
      display: block;
    }

    .position-details .label {
      color: #666;
      font-size: 0.85em;
    }

    .position-details .value {
      color: #fff;
    }

    .position-actions {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }

    .position-actions button {
      padding: 8px 15px;
      font-size: 0.85em;
    }

    .btn-close-profit {
      background: linear-gradient(45deg, #00c853, #00e676) !important;
    }

    .btn-close-loss {
      background: linear-gradient(45deg, #ff1744, #ff5252) !important;
      color: #fff !important;
    }

    .btn-delete {
      background: rgba(255,255,255,0.1) !important;
      color: #888 !important;
    }

    .btn-copy {
      background: linear-gradient(45deg, #00d9ff, #0099cc) !important;
      color: #fff !important;
    }

    .btn-copy:hover {
      box-shadow: 0 3px 15px rgba(0, 217, 255, 0.4);
    }

    .no-positions {
      text-align: center;
      padding: 40px;
      color: #666;
    }

    .history-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
      padding: 20px;
      background: rgba(0,0,0,0.3);
      border-radius: 10px;
    }

    .stat-item {
      text-align: center;
    }

    .stat-item .label {
      color: #888;
      font-size: 0.85em;
      margin-bottom: 5px;
    }

    .stat-item .value {
      font-size: 1.3em;
      font-weight: bold;
      margin-top: 5px;
    }

    .confidence-fill {
      height: 100%;
      border-radius: 3px;
      transition: width 0.3s;
    }

    .tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    }

    .tab {
      padding: 10px 20px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .tab:hover, .tab.active {
      background: rgba(0, 217, 255, 0.2);
      border-color: #00d9ff;
    }

    .symbol-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: #1a1a2e;
      border: 1px solid #00d9ff;
      border-radius: 8px;
      max-height: 300px;
      overflow-y: auto;
      z-index: 1000;
      margin-top: 5px;
    }

    .symbol-dropdown-item {
      padding: 12px 15px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }

    .symbol-dropdown-item:hover {
      background: rgba(0, 217, 255, 0.2);
    }

    .symbol-dropdown-item .coin-name {
      font-weight: bold;
      color: #fff;
    }

    .symbol-dropdown-item .coin-pair {
      color: #888;
      font-size: 0.9em;
    }

    /* Toast Notification */
    .toast-container {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 9999;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .toast {
      min-width: 320px;
      max-width: 420px;
      padding: 16px 20px;
      border-radius: 12px;
      background: rgba(26, 26, 46, 0.98);
      border: 1px solid rgba(255,255,255,0.1);
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
      animation: slideIn 0.3s ease-out;
      backdrop-filter: blur(10px);
    }

    .toast.success {
      border-left: 4px solid #00ff88;
    }

    .toast.error {
      border-left: 4px solid #ff5252;
    }

    .toast.info {
      border-left: 4px solid #00d9ff;
    }

    .toast-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
    }

    .toast-icon {
      font-size: 1.5em;
    }

    .toast-title {
      font-weight: bold;
      font-size: 1.1em;
      color: #fff;
    }

    .toast-body {
      color: #ccc;
      font-size: 0.95em;
      line-height: 1.5;
    }

    .toast-body .detail {
      display: flex;
      justify-content: space-between;
      padding: 4px 0;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }

    .toast-body .detail:last-child {
      border-bottom: none;
    }

    .toast-body .detail .label {
      color: #888;
    }

    .toast-body .detail .value {
      font-weight: 500;
    }

    .toast-body .value.long {
      color: #00ff88;
    }

    .toast-body .value.short {
      color: #ff5252;
    }

    .toast-close {
      position: absolute;
      top: 10px;
      right: 10px;
      background: none;
      border: none;
      color: #888;
      font-size: 1.2em;
      cursor: pointer;
      padding: 5px;
    }

    .toast-close:hover {
      color: #fff;
    }

    .toast-progress {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 3px;
      background: linear-gradient(90deg, #00d9ff, #00ff88);
      border-radius: 0 0 0 12px;
      animation: progress 4s linear forwards;
    }

    /* Modal Dialog */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      animation: fadeIn 0.2s ease-out;
    }

    .modal {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      border-radius: 16px;
      padding: 25px;
      min-width: 350px;
      max-width: 450px;
      border: 1px solid rgba(255,255,255,0.1);
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
      animation: scaleIn 0.2s ease-out;
    }

    .modal-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 20px;
    }

    .modal-icon {
      font-size: 2em;
    }

    .modal-icon.warning { color: #ffc107; }
    .modal-icon.danger { color: #ff5252; }
    .modal-icon.success { color: #00ff88; }
    .modal-icon.info { color: #00d9ff; }

    .modal-title {
      font-size: 1.3em;
      font-weight: bold;
      color: #fff;
    }

    .modal-body {
      color: #ccc;
      margin-bottom: 20px;
      line-height: 1.6;
    }

    .modal-input {
      width: 100%;
      padding: 12px 15px;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      background: rgba(0,0,0,0.3);
      color: #fff;
      font-size: 1.1em;
      margin-top: 10px;
    }

    .modal-input:focus {
      outline: none;
      border-color: #00d9ff;
    }

    .modal-footer {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }

    .modal-btn {
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 1em;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .modal-btn.cancel {
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      color: #ccc;
    }

    .modal-btn.cancel:hover {
      background: rgba(255,255,255,0.2);
    }

    .modal-btn.confirm {
      background: linear-gradient(45deg, #00d9ff, #00ff88);
      border: none;
      color: #1a1a2e;
    }

    .modal-btn.confirm:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(0, 217, 255, 0.4);
    }

    .modal-btn.danger {
      background: linear-gradient(45deg, #ff5252, #ff1744);
      border: none;
      color: #fff;
    }

    .modal-btn.danger:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(255, 82, 82, 0.4);
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes scaleIn {
      from { transform: scale(0.9); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes slideOut {
      from {
        transform: translateX(0);
        opacity: 1;
      }
      to {
        transform: translateX(100%);
        opacity: 0;
      }
    }

    @keyframes progress {
      from { width: 100%; }
      to { width: 0%; }
    }

    @keyframes pulse {
      0%, 100% { box-shadow: 0 0 0 0 rgba(0, 217, 255, 0.4); }
      50% { box-shadow: 0 0 20px 10px rgba(0, 217, 255, 0.6); }
    }

    /* ===================== CHART MODAL ===================== */
    .chart-modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.9);
      z-index: 10000;
      display: none;
      justify-content: center;
      align-items: center;
      animation: fadeIn 0.2s ease;
    }

    .chart-modal-overlay.active {
      display: flex;
    }

    .chart-modal {
      width: 95%;
      max-width: 1400px;
      height: 85vh;
      background: #1a1a2e;
      border-radius: 15px;
      overflow: hidden;
      animation: scaleIn 0.3s ease;
      display: flex;
      flex-direction: column;
    }

    .chart-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 20px;
      background: rgba(0, 217, 255, 0.1);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .chart-modal-title {
      font-size: 1.3em;
      color: #00d9ff;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .chart-modal-close {
      background: none;
      border: none;
      color: #fff;
      font-size: 2em;
      cursor: pointer;
      padding: 0 10px;
      transition: color 0.2s;
    }

    .chart-modal-close:hover {
      color: #ff5252;
    }

    .chart-modal-body {
      flex: 1;
      overflow: hidden;
    }

    .chart-modal-body iframe {
      width: 100%;
      height: 100%;
      border: none;
    }

    .btn-chart {
      background: rgba(0, 217, 255, 0.2);
      border: 1px solid #00d9ff;
      color: #00d9ff;
      padding: 8px 15px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 0.9em;
      transition: all 0.2s;
      margin-top: 10px;
    }

    .btn-chart:hover {
      background: #00d9ff;
      color: #1a1a2e;
    }

    /* ===================== BINANCE API CONFIG ===================== */
    .api-config-btn {
      position: fixed;
      bottom: 90px;
      right: 20px;
      z-index: 1000;
      background: linear-gradient(135deg, #f0b90b, #d4a00a);
      border: none;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.3em;
      box-shadow: 0 4px 15px rgba(240, 185, 11, 0.4);
      transition: all 0.3s ease;
    }

    .api-config-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 25px rgba(240, 185, 11, 0.6);
    }

    .api-config-btn.connected {
      background: linear-gradient(135deg, #00c853, #00e676);
      box-shadow: 0 4px 15px rgba(0, 200, 83, 0.4);
    }

    .api-config-btn.connected:hover {
      box-shadow: 0 6px 25px rgba(0, 200, 83, 0.6);
    }

    .api-modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10002;
      animation: fadeIn 0.2s ease;
    }

    .api-modal-overlay.active {
      display: flex;
    }

    .api-modal {
      background: linear-gradient(145deg, #1e1e2e, #252540);
      border-radius: 20px;
      padding: 30px;
      max-width: 450px;
      width: 90%;
      position: relative;
      border: 1px solid rgba(240, 185, 11, 0.3);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    .api-modal h3 {
      color: #f0b90b;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .api-modal .subtitle {
      color: #888;
      font-size: 0.85em;
      margin-bottom: 20px;
    }

    .api-input-group {
      margin-bottom: 15px;
    }

    .api-input-group label {
      display: block;
      color: #aaa;
      font-size: 0.9em;
      margin-bottom: 5px;
    }

    .api-input-group input {
      width: 100%;
      padding: 12px 15px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 8px;
      color: #fff;
      font-size: 0.95em;
    }

    .api-input-group input:focus {
      border-color: #f0b90b;
      outline: none;
    }

    .api-warning {
      background: rgba(255, 193, 7, 0.1);
      border: 1px solid rgba(255, 193, 7, 0.3);
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 15px;
      font-size: 0.85em;
      color: #ffc107;
    }

    .api-warning strong {
      display: block;
      margin-bottom: 5px;
    }

    .api-status {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px;
      border-radius: 8px;
      margin-bottom: 15px;
      font-size: 0.9em;
    }

    .api-status.connected {
      background: rgba(0, 200, 83, 0.1);
      border: 1px solid rgba(0, 200, 83, 0.3);
      color: #00c853;
    }

    .api-status.disconnected {
      background: rgba(255, 82, 82, 0.1);
      border: 1px solid rgba(255, 82, 82, 0.3);
      color: #ff5252;
    }

    .api-balance {
      background: rgba(0, 217, 255, 0.1);
      border: 1px solid rgba(0, 217, 255, 0.3);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
    }

    .api-balance-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
    }

    .api-balance-row:last-child {
      margin-bottom: 0;
    }

    .api-balance-label {
      color: #888;
    }

    .api-balance-value {
      font-weight: bold;
      color: #00d9ff;
    }

    .api-modal-close {
      position: absolute;
      top: 15px;
      right: 15px;
      background: none;
      border: none;
      color: #888;
      font-size: 1.5em;
      cursor: pointer;
    }

    .api-modal-close:hover {
      color: #fff;
    }

    .api-buttons {
      display: flex;
      gap: 10px;
    }

    .api-buttons button {
      flex: 1;
      padding: 12px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-api-save {
      background: linear-gradient(135deg, #f0b90b, #d4a00a);
      border: none;
      color: #1a1a2e;
    }

    .btn-api-save:hover {
      box-shadow: 0 5px 20px rgba(240, 185, 11, 0.4);
    }

    .btn-api-clear {
      background: transparent;
      border: 1px solid #ff5252;
      color: #ff5252;
    }

    .btn-api-clear:hover {
      background: rgba(255, 82, 82, 0.1);
    }

    .btn-api-test {
      background: linear-gradient(135deg, #00d9ff, #0099cc);
      border: none;
      color: #1a1a2e;
    }

    .btn-api-test:hover {
      box-shadow: 0 5px 20px rgba(0, 217, 255, 0.4);
    }

    /* Trading Button in Signal */
    .btn-trade-binance {
      background: linear-gradient(135deg, #f0b90b, #d4a00a) !important;
      color: #1a1a2e !important;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .btn-trade-binance:hover {
      box-shadow: 0 5px 20px rgba(240, 185, 11, 0.5) !important;
    }

    .btn-trade-binance:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .testnet-badge {
      background: #ff9800;
      color: #1a1a2e;
      font-size: 0.7em;
      padding: 2px 8px;
      border-radius: 10px;
      margin-left: 5px;
    }

    /* ===================== DONATE BUTTON & MODAL ===================== */
    .donate-container {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 1000;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .donate-label {
      background: linear-gradient(135deg, #ff6b6b, #feca57);
      color: #1a1a2e;
      padding: 8px 15px;
      border-radius: 20px;
      font-size: 0.85em;
      font-weight: bold;
      white-space: nowrap;
      box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
      animation: slideIn 0.5s ease, shake 3s ease-in-out infinite 2s;
      cursor: pointer;
    }

    @keyframes slideIn {
      from { opacity: 0; transform: translateX(20px); }
      to { opacity: 1; transform: translateX(0); }
    }

    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      10%, 30%, 50%, 70%, 90% { transform: translateX(-2px); }
      20%, 40%, 60%, 80% { transform: translateX(2px); }
    }

    .donate-float-btn {
      width: 55px;
      height: 55px;
      background: linear-gradient(135deg, #ff6b6b, #feca57);
      border: none;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.6em;
      box-shadow: 0 4px 20px rgba(255, 107, 107, 0.5);
      transition: all 0.3s ease;
      animation: pulse-donate 2s infinite, bounce 1s ease-in-out infinite 3s;
      position: relative;
    }

    .donate-float-btn::after {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      border: 2px solid rgba(255, 107, 107, 0.6);
      animation: ripple 1.5s infinite;
    }

    @keyframes ripple {
      0% { transform: scale(1); opacity: 1; }
      100% { transform: scale(1.5); opacity: 0; }
    }

    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-8px); }
    }

    .donate-float-btn:hover {
      transform: scale(1.15) rotate(10deg);
      box-shadow: 0 8px 30px rgba(255, 107, 107, 0.7);
    }

    .donate-float-btn:hover::after {
      animation: none;
    }

    @keyframes pulse-donate {
      0%, 100% { box-shadow: 0 4px 20px rgba(255, 107, 107, 0.5); }
      50% { box-shadow: 0 4px 35px rgba(255, 107, 107, 0.8); }
    }

    .donate-badge {
      position: absolute;
      top: -5px;
      right: -5px;
      background: #00ff88;
      color: #1a1a2e;
      font-size: 0.5em;
      padding: 2px 6px;
      border-radius: 10px;
      font-weight: bold;
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    .donate-modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10001;
      animation: fadeIn 0.2s ease;
    }

    .donate-modal-overlay.active {
      display: flex;
    }

    .donate-modal {
      background: linear-gradient(145deg, #1e1e2e, #252540);
      border-radius: 20px;
      padding: 30px;
      max-width: 380px;
      width: 90%;
      text-align: center;
      position: relative;
      border: 1px solid rgba(255, 107, 107, 0.3);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    .donate-modal-close {
      position: absolute;
      top: 15px;
      right: 15px;
      background: none;
      border: none;
      color: #888;
      font-size: 1.5em;
      cursor: pointer;
      transition: color 0.2s;
    }

    .donate-modal-close:hover {
      color: #fff;
    }

    .donate-title {
      font-size: 1.3em;
      margin-bottom: 8px;
      background: linear-gradient(135deg, #ff6b6b, #feca57);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .donate-subtitle {
      color: #888;
      font-size: 0.9em;
      margin-bottom: 20px;
    }

    .donate-qr-container {
      background: #fff;
      padding: 10px;
      border-radius: 15px;
      display: inline-block;
      margin-bottom: 15px;
    }

    .donate-qr-container img {
      width: 220px;
      height: auto;
      border-radius: 10px;
    }

    .donate-info {
      color: #aaa;
      font-size: 0.85em;
      line-height: 1.6;
    }

    .donate-info strong {
      color: #feca57;
    }

    .donate-thanks {
      margin-top: 15px;
      padding: 10px;
      background: rgba(0, 255, 136, 0.1);
      border-radius: 10px;
      color: #00ff88;
      font-size: 0.85em;
    }

    /* ===================== MOBILE RESPONSIVE ===================== */
    @media (max-width: 768px) {
      .container {
        padding: 10px;
      }

      header {
        padding: 15px 0;
        margin-bottom: 15px;
      }

      header h1 {
        font-size: 1.5em;
      }

      header p {
        font-size: 0.9em;
      }

      .tabs {
        flex-wrap: nowrap;
        overflow-x: auto;
        gap: 5px;
        padding-bottom: 5px;
      }

      .tab {
        padding: 10px 15px;
        font-size: 0.85em;
        white-space: nowrap;
        flex-shrink: 0;
      }

      .controls {
        flex-direction: column;
        padding: 15px;
        gap: 10px;
      }

      .control-group {
        min-width: 100%;
      }

      select, input {
        padding: 10px 12px;
        font-size: 16px; /* Prevent zoom on iOS */
      }

      button {
        padding: 12px 20px;
        font-size: 0.95em;
        width: 100%;
      }

      .signal-card {
        padding: 15px;
        border-radius: 12px;
      }

      .signal-header {
        flex-direction: column;
        text-align: center;
        gap: 10px;
      }

      .symbol-info {
        flex-direction: column;
        gap: 8px;
      }

      .symbol-name {
        font-size: 1.4em;
      }

      .price {
        font-size: 1.2em;
      }

      .signal-badge {
        padding: 8px 20px;
        font-size: 1em;
      }

      .indicators-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
      }

      .indicator-box {
        padding: 12px;
      }

      .indicator-box h4 {
        font-size: 0.75em;
      }

      .indicator-box .value {
        font-size: 1.1em;
      }

      .trade-setup {
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
        padding: 15px;
      }

      .trade-item .value {
        font-size: 1em;
      }

      .trade-item label {
        font-size: 0.75em;
      }

      .reasons {
        padding: 12px;
      }

      .reasons li {
        font-size: 0.9em;
        padding: 6px 0;
      }

      /* Order Entry Mobile */
      .order-entry {
        padding: 15px !important;
      }

      .order-grid {
        grid-template-columns: repeat(2, 1fr) !important;
        gap: 10px !important;
      }

      .order-buttons {
        flex-direction: column;
        gap: 10px;
      }

      .order-buttons button {
        width: 100%;
      }

      /* Position Cards Mobile */
      .position-card {
        padding: 12px;
      }

      .position-header {
        flex-direction: column;
        gap: 8px;
        text-align: center;
      }

      .position-symbol {
        font-size: 1.1em;
      }

      .position-pnl {
        font-size: 1em;
      }

      .position-details {
        grid-template-columns: repeat(2, 1fr) !important;
        gap: 8px;
      }

      .position-details .label {
        font-size: 0.7em;
      }

      .position-details .value {
        font-size: 0.85em;
      }

      .position-actions {
        flex-wrap: wrap;
        gap: 8px;
        justify-content: center;
      }

      .position-actions button {
        padding: 8px 12px;
        font-size: 0.8em;
        flex: 1;
        min-width: 70px;
      }

      /* Stats Mobile */
      .history-stats {
        grid-template-columns: repeat(2, 1fr) !important;
        gap: 10px;
        padding: 15px;
      }

      .stat-item {
        padding: 8px;
      }

      .stat-item .label {
        font-size: 0.7em;
      }

      .stat-item .value {
        font-size: 1em;
      }

      /* Calculator Mobile */
      .position-calculator {
        padding: 15px;
      }

      .calc-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
      }

      .calc-result {
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
        padding: 15px;
      }

      /* Multi Signal Scan Mobile */
      .mini-signal {
        grid-template-columns: 1fr;
        text-align: center;
        padding: 12px;
        gap: 8px;
      }

      .mini-signal .symbol {
        font-size: 1em;
      }

      .mini-badge {
        margin-top: 5px;
      }

      /* Toast Mobile */
      .toast-container {
        left: 10px;
        right: 10px;
        bottom: 10px;
        top: auto;
      }

      .toast {
        max-width: 100%;
        font-size: 0.9em;
      }

      /* Modal Mobile */
      .modal-overlay {
        padding: 15px;
        align-items: flex-end;
      }

      .modal {
        max-width: 100% !important;
        max-height: 85vh;
        overflow-y: auto;
        border-radius: 16px 16px 0 0;
        margin-bottom: 0;
      }

      .modal-header h3 {
        font-size: 1.1em;
      }

      .modal-body {
        font-size: 0.95em;
      }

      .modal-body input {
        font-size: 16px;
      }

      .modal-actions {
        flex-direction: column;
        gap: 10px;
      }

      .modal-btn {
        width: 100%;
        padding: 14px;
      }

      /* Tabs Content */
      .tab-content {
        padding: 0;
      }

      /* Section Headers */
      .section-header {
        font-size: 1.1em;
        padding: 12px;
      }
    }

    /* Extra small devices (phones in portrait) */
    @media (max-width: 400px) {
      header h1 {
        font-size: 1.3em;
      }

      .indicators-grid {
        grid-template-columns: 1fr;
      }

      .trade-setup {
        grid-template-columns: 1fr;
      }

      .position-details {
        grid-template-columns: 1fr !important;
      }

      .history-stats {
        grid-template-columns: 1fr !important;
      }

      .order-grid {
        grid-template-columns: 1fr !important;
      }

      .calc-grid {
        grid-template-columns: 1fr;
      }

      .calc-result {
        grid-template-columns: 1fr;
      }

      .position-actions button {
        min-width: 100%;
      }
    }

    /* Landscape mode on mobile */
    @media (max-width: 768px) and (orientation: landscape) {
      .modal {
        max-height: 90vh;
        border-radius: 16px;
      }

      .modal-overlay {
        align-items: center;
      }
    }

    /* Touch-friendly improvements */
    @media (hover: none) and (pointer: coarse) {
      button, .tab, .mini-signal, select, input {
        min-height: 44px; /* Apple's recommended touch target */
      }

      .position-actions button {
        min-height: 40px;
      }

      button:hover {
        transform: none;
        box-shadow: none;
      }

      .tab:hover {
        background: transparent;
      }

      .tab.active:hover {
        background: linear-gradient(45deg, #00d9ff, #00ff88);
      }
    }

  </style>
</head>
<body>
  <!-- Toast Container -->
  <div class="toast-container" id="toast-container"></div>

  <div class="container">
    <header>
      <h1>Trading Signal Bot</h1>
      <p>Ph√¢n t√≠ch t√≠n hi·ªáu Futures Long/Short v·ªõi Stop Loss t·ª± ƒë·ªông</p>
    </header>

    <div class="tabs">
      <div class="tab active" onclick="switchTab('single')">Ph√¢n t√≠ch 1 Symbol</div>
      <div class="tab" onclick="switchTab('multi')">Qu√©t nhi·ªÅu Symbol</div>
      <div class="tab" onclick="switchTab('positions')">L·ªánh ƒëang m·ªü (<span id="open-count">0</span>)</div>
      <div class="tab" onclick="switchTab('history')">L·ªãch s·ª≠</div>
    </div>

    <!-- Single Analysis -->
    <div id="single-tab">
      <div class="controls" style="align-items: flex-start;">
        <div class="control-group">
          <label>T√¨m Symbol</label>
          <div style="position: relative;">
            <input type="text" id="symbolSearch" placeholder="Nh·∫≠p t√™n coin (VD: BTC, ETH, SOL...)" autocomplete="off" oninput="filterSymbols()" onfocus="showSymbolList()">
            <div id="symbolList" class="symbol-dropdown" style="display: none;"></div>
          </div>
          <input type="hidden" id="symbol" value="BTCUSDT">
        </div>
        <div class="control-group">
          <label>Khung th·ªùi gian</label>
          <select id="interval">
            <option value="5m">5 Ph√∫t</option>
            <option value="15m">15 Ph√∫t</option>
            <option value="30m">30 Ph√∫t</option>
            <option value="1h" selected>1 Gi·ªù</option>
            <option value="4h">4 Gi·ªù</option>
            <option value="1d">1 Ng√†y</option>
          </select>
        </div>
        <div class="control-group">
          <label>Th·ªã tr∆∞·ªùng</label>
          <select id="market">
            <option value="futures" selected>Futures</option>
            <option value="spot">Spot</option>
          </select>
        </div>
        <div class="control-group">
          <label>&nbsp;</label>
          <button onclick="analyzeSignal()" id="analyzeBtn">Ph√¢n t√≠ch</button>
        </div>
      </div>

      <div id="signal-result"></div>
    </div>

    <!-- Multi Analysis -->
    <div id="multi-tab" style="display: none;">
      <div class="controls">
        <div class="control-group">
          <label>Khung th·ªùi gian</label>
          <select id="multi-interval">
            <option value="15m">15 Ph√∫t</option>
            <option value="1h" selected>1 Gi·ªù</option>
            <option value="4h">4 Gi·ªù</option>
          </select>
        </div>
        <div class="control-group" style="display: flex; align-items: flex-end;">
          <button onclick="scanSignals()" id="scanBtn">Qu√©t t·∫•t c·∫£</button>
        </div>
      </div>

      <div id="multi-result" class="multi-signals"></div>
    </div>

    <!-- Open Positions -->
    <div id="positions-tab" style="display: none;">
      <div class="history-stats">
        <div class="stat-item">
          <div class="label">T·ªïng l·ªánh ƒëang m·ªü</div>
          <div class="value" id="total-open">0</div>
        </div>
        <div class="stat-item">
          <div class="label">T·ªïng P/L ch∆∞a ch·ªët</div>
          <div class="value" id="total-unrealized-pnl">$0.00</div>
        </div>
        <div class="stat-item">
          <div class="label">T·ªïng margin</div>
          <div class="value" id="total-margin">$0.00</div>
        </div>
      </div>
      <div id="open-positions"></div>
    </div>

    <!-- History -->
    <div id="history-tab" style="display: none;">
      <div class="history-stats">
        <div class="stat-item">
          <div class="label">T·ªïng l·ªánh ƒë√£ ƒë√≥ng</div>
          <div class="value" id="total-closed">0</div>
        </div>
        <div class="stat-item">
          <div class="label">T·ªïng P/L</div>
          <div class="value" id="total-pnl">$0.00</div>
        </div>
        <div class="stat-item">
          <div class="label">Win Rate</div>
          <div class="value" id="win-rate">0%</div>
        </div>
        <div class="stat-item">
          <div class="label">L·ªánh th·∫Øng / Thua</div>
          <div class="value" id="win-loss">0 / 0</div>
        </div>
        <div class="stat-item" style="display: flex; align-items: center;">
          <button onclick="clearAllHistory()" style="background: linear-gradient(135deg, #ff5252 0%, #d32f2f 100%); border: none; color: white; padding: 8px 16px; border-radius: 8px; cursor: pointer; font-size: 0.85em;">üóëÔ∏è X√≥a t·∫•t c·∫£</button>
        </div>
      </div>
      <div id="closed-positions"></div>
    </div>
  </div>

  <script>
    const API_BASE = '';

    // ===================== ADMIN MODE (Secret Password) =====================
    const ADMIN_SECRET_KEY = 'chiennv1';
    let isAdminMode = false;

    // Check admin mode immediately on script load
    (function initAdminMode() {
      const urlParams = new URLSearchParams(window.location.search);
      const urlKey = urlParams.get('key');
      const savedKey = localStorage.getItem('admin_key');

      if (urlKey === ADMIN_SECRET_KEY) {
        isAdminMode = true;
        localStorage.setItem('admin_key', ADMIN_SECRET_KEY);
        window.history.replaceState({}, document.title, window.location.pathname);
      } else if (savedKey === ADMIN_SECRET_KEY) {
        isAdminMode = true;
      }
    })();

    // Detect if running on Cloudflare Workers (not localhost)
    const IS_CLOUDFLARE = !window.location.hostname.includes('localhost') &&
                          !window.location.hostname.includes('127.0.0.1') &&
                          !window.location.hostname.match(/^192\.168\./);

    // ===================== FORMAT PRICE HELPER =====================
    // Format gi√° th√¥ng minh d·ª±a tr√™n ƒë·ªô l·ªõn c·ªßa gi√°
    function formatPrice(price) {
      if (price === null || price === undefined || isNaN(price)) return 'N/A';

      const absPrice = Math.abs(price);
      let decimals;

      if (absPrice >= 1000) {
        decimals = 2;      // BTC: $94000.12
      } else if (absPrice >= 100) {
        decimals = 2;      // ETH: $3400.25
      } else if (absPrice >= 10) {
        decimals = 3;      // SOL: $180.456
      } else if (absPrice >= 1) {
        decimals = 4;      // XRP: $2.1234
      } else if (absPrice >= 0.1) {
        decimals = 5;      // SEI: $0.11734
      } else if (absPrice >= 0.01) {
        decimals = 6;      // SHIB: $0.000025
      } else {
        decimals = 8;      // Very small prices
      }

      return price.toFixed(decimals);
    }

    // ===================== TOAST NOTIFICATION SYSTEM =====================

    function showToast(options) {
      const { type = 'info', title, message, details = [], duration = 4000 } = options;

      const container = document.getElementById('toast-container');
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.style.position = 'relative';

      // Icon based on type
      const icons = {
        success: '<span style="color: #00ff88;">&#10003;</span>',
        error: '<span style="color: #ff5252;">&#10007;</span>',
        info: '<span style="color: #00d9ff;">&#9432;</span>'
      };

      // Build details HTML
      let detailsHtml = '';
      if (details.length > 0) {
        detailsHtml = details.map(d => `
          <div class="detail">
            <span class="label">${d.label}</span>
            <span class="value ${d.class || ''}">${d.value}</span>
          </div>
        `).join('');
      }

      toast.innerHTML = `
        <button class="toast-close" onclick="this.parentElement.remove()">&times;</button>
        <div class="toast-header">
          <span class="toast-icon">${icons[type] || icons.info}</span>
          <span class="toast-title">${title}</span>
        </div>
        <div class="toast-body">
          ${message ? `<p style="margin-bottom: 10px;">${message}</p>` : ''}
          ${detailsHtml}
        </div>
        <div class="toast-progress"></div>
      `;

      container.appendChild(toast);

      // Auto remove after duration
      setTimeout(() => {
        toast.style.animation = 'slideOut 0.3s ease-in forwards';
        setTimeout(() => toast.remove(), 300);
      }, duration);
    }

    // ===================== MODAL DIALOG SYSTEM =====================

    function showModal(options) {
      return new Promise((resolve) => {
        const { type = 'info', title, message, inputLabel, inputValue, confirmText = 'X√°c nh·∫≠n', cancelText = 'H·ªßy', showCancel = true, dangerMode = false } = options;

        const icons = {
          warning: '&#9888;',
          danger: '&#128308;',
          success: '&#10003;',
          info: '&#9432;'
        };

        const overlay = document.createElement('div');
        overlay.className = 'modal-overlay';

        const inputHtml = inputLabel ? `
          <label style="color: #888; font-size: 0.9em;">${inputLabel}</label>
          <input type="number" class="modal-input" id="modal-input" value="${inputValue || ''}" step="any">
        ` : '';

        overlay.innerHTML = `
          <div class="modal">
            <div class="modal-header">
              <span class="modal-icon ${type}">${icons[type] || icons.info}</span>
              <span class="modal-title">${title}</span>
            </div>
            <div class="modal-body">
              <p>${message}</p>
              ${inputHtml}
            </div>
            <div class="modal-footer">
              ${showCancel ? `<button class="modal-btn cancel" id="modal-cancel">${cancelText}</button>` : ''}
              <button class="modal-btn ${dangerMode ? 'danger' : 'confirm'}" id="modal-confirm">${confirmText}</button>
            </div>
          </div>
        `;

        document.body.appendChild(overlay);

        const input = overlay.querySelector('#modal-input');
        if (input) {
          input.focus();
          input.select();
        }

        const closeModal = (result) => {
          overlay.style.animation = 'fadeIn 0.2s ease-out reverse';
          setTimeout(() => overlay.remove(), 200);
          resolve(result);
        };

        overlay.querySelector('#modal-confirm').onclick = () => {
          if (input) {
            const value = parseFloat(input.value);
            closeModal({ confirmed: true, value: isNaN(value) ? null : value });
          } else {
            closeModal({ confirmed: true });
          }
        };

        if (showCancel) {
          overlay.querySelector('#modal-cancel').onclick = () => closeModal({ confirmed: false });
        }

        overlay.onclick = (e) => {
          if (e.target === overlay) closeModal({ confirmed: false });
        };

        // Enter key to confirm
        if (input) {
          input.onkeydown = (e) => {
            if (e.key === 'Enter') {
              overlay.querySelector('#modal-confirm').click();
            }
          };
        }
      });
    }

    function showConfirm(title, message, dangerMode = false) {
      return showModal({
        type: dangerMode ? 'danger' : 'warning',
        title,
        message,
        confirmText: 'X√°c nh·∫≠n',
        cancelText: 'H·ªßy',
        dangerMode
      });
    }

    function showPrompt(title, message, inputLabel, inputValue) {
      return showModal({
        type: 'info',
        title,
        message,
        inputLabel,
        inputValue,
        confirmText: 'X√°c nh·∫≠n',
        cancelText: 'H·ªßy'
      });
    }

    // ===================== CLIENT-SIDE BINANCE API & SIGNAL ENGINE =====================
    // Used when running on Cloudflare (because Binance blocks Cloudflare IPs)

    const BINANCE_FUTURES_API = 'https://fapi.binance.com';

    // Fetch klines directly from Binance
    async function fetchBinanceKlines(symbol, interval, limit = 100) {
      const url = `${BINANCE_FUTURES_API}/fapi/v1/klines?symbol=${symbol.toUpperCase()}&interval=${interval}&limit=${limit}`;
      const response = await fetch(url);
      if (!response.ok) throw new Error(`Binance API error: ${response.status}`);
      const data = await response.json();
      return data.map(k => ({
        openTime: k[0],
        open: parseFloat(k[1]),
        high: parseFloat(k[2]),
        low: parseFloat(k[3]),
        close: parseFloat(k[4]),
        volume: parseFloat(k[5]),
        closeTime: k[6]
      }));
    }

    // Fetch current price from Binance
    async function fetchBinancePrice(symbol) {
      const url = `${BINANCE_FUTURES_API}/fapi/v1/ticker/price?symbol=${symbol.toUpperCase()}`;
      const response = await fetch(url);
      if (!response.ok) throw new Error(`Binance API error: ${response.status}`);
      const data = await response.json();
      return { symbol: data.symbol, price: parseFloat(data.price) };
    }

    // ===================== CLIENT-SIDE TECHNICAL INDICATORS =====================

    class ClientTechnicalIndicators {
      // Simple Moving Average
      static SMA(data, period) {
        const result = [];
        for (let i = 0; i < data.length; i++) {
          if (i < period - 1) {
            result.push(null);
          } else {
            const sum = data.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
            result.push(sum / period);
          }
        }
        return result;
      }

      // Exponential Moving Average
      static EMA(data, period) {
        const result = [];
        const multiplier = 2 / (period + 1);
        let ema = data.slice(0, period).reduce((a, b) => a + b, 0) / period;
        for (let i = 0; i < data.length; i++) {
          if (i < period - 1) {
            result.push(null);
          } else if (i === period - 1) {
            result.push(ema);
          } else {
            ema = (data[i] - ema) * multiplier + ema;
            result.push(ema);
          }
        }
        return result;
      }

      // RSI
      static RSI(closes, period = 14) {
        const changes = [];
        for (let i = 1; i < closes.length; i++) {
          changes.push(closes[i] - closes[i - 1]);
        }

        const gains = changes.map(c => c > 0 ? c : 0);
        const losses = changes.map(c => c < 0 ? Math.abs(c) : 0);

        const result = [];
        let avgGain = gains.slice(0, period).reduce((a, b) => a + b, 0) / period;
        let avgLoss = losses.slice(0, period).reduce((a, b) => a + b, 0) / period;

        for (let i = 0; i < closes.length; i++) {
          if (i < period) {
            result.push(null);
          } else if (i === period) {
            const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
            result.push(100 - (100 / (1 + rs)));
          } else {
            avgGain = (avgGain * (period - 1) + gains[i - 1]) / period;
            avgLoss = (avgLoss * (period - 1) + losses[i - 1]) / period;
            const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
            result.push(100 - (100 / (1 + rs)));
          }
        }
        return result;
      }

      // MACD
      static MACD(closes, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
        const emaFast = this.EMA(closes, fastPeriod);
        const emaSlow = this.EMA(closes, slowPeriod);

        const macdLine = emaFast.map((fast, i) => {
          if (fast === null || emaSlow[i] === null) return null;
          return fast - emaSlow[i];
        });

        const validMacd = macdLine.filter(v => v !== null);
        const signalLine = this.EMA(validMacd, signalPeriod);

        const result = { macd: [], signal: [], histogram: [] };
        let signalIndex = 0;

        for (let i = 0; i < macdLine.length; i++) {
          if (macdLine[i] === null) {
            result.macd.push(null);
            result.signal.push(null);
            result.histogram.push(null);
          } else {
            result.macd.push(macdLine[i]);
            const sig = signalLine[signalIndex] || null;
            result.signal.push(sig);
            result.histogram.push(sig !== null ? macdLine[i] - sig : null);
            signalIndex++;
          }
        }
        return result;
      }

      // Bollinger Bands
      static BollingerBands(closes, period = 20, stdDev = 2) {
        const sma = this.SMA(closes, period);
        const result = { upper: [], middle: [], lower: [] };

        for (let i = 0; i < closes.length; i++) {
          if (sma[i] === null) {
            result.upper.push(null);
            result.middle.push(null);
            result.lower.push(null);
          } else {
            const slice = closes.slice(i - period + 1, i + 1);
            const mean = sma[i];
            const variance = slice.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / period;
            const std = Math.sqrt(variance);

            result.upper.push(mean + stdDev * std);
            result.middle.push(mean);
            result.lower.push(mean - stdDev * std);
          }
        }
        return result;
      }

      // ATR
      static ATR(candles, period = 14) {
        const trueRanges = [];
        for (let i = 0; i < candles.length; i++) {
          if (i === 0) {
            trueRanges.push(candles[i].high - candles[i].low);
          } else {
            const tr = Math.max(
              candles[i].high - candles[i].low,
              Math.abs(candles[i].high - candles[i - 1].close),
              Math.abs(candles[i].low - candles[i - 1].close)
            );
            trueRanges.push(tr);
          }
        }
        return this.EMA(trueRanges, period);
      }
    }

    // ===================== CLIENT-SIDE SIGNAL ENGINE (SMART MONEY CONCEPTS) =====================

    // Multi-Timeframe mapping
    const MTF_MAP = {
      '1m':  ['5m', '15m'],
      '3m':  ['15m', '1h'],
      '5m':  ['15m', '1h'],
      '15m': ['1h', '4h'],
      '30m': ['1h', '4h'],
      '1h':  ['4h', '1d'],
      '2h':  ['4h', '1d'],
      '4h':  ['1d', '1w'],
      '1d':  ['1w', '1M']
    };

    class ClientSignalEngine {
      constructor() {
        this.config = {
          rsiPeriod: 14,
          rsiOversold: 30,
          rsiOverbought: 70,
          atrMultiplier: 2.0,         // SL = 2x ATR
          riskRewardRatio: 2.0,       // TP = 2x SL distance
          minScoreToTrade: 5,         // ƒêi·ªÉm t·ªëi thi·ªÉu ƒë·ªÉ v√†o l·ªánh (tƒÉng t·ª´ 3 l√™n 5)
          volumeMultiplier: 1.2,      // Volume ph·∫£i > 1.2x MA ƒë·ªÉ x√°c nh·∫≠n
          swingLookback: 10,          // S·ªë n·∫øn ƒë·ªÉ t√¨m swing high/low
          useMTF: true                // Enable Multi-Timeframe Confirmation
        };
      }

      analyze(candles) {
        const closes = candles.map(c => c.close);
        const highs = candles.map(c => c.high);
        const lows = candles.map(c => c.low);
        const volumes = candles.map(c => c.volume);
        const currentPrice = closes[closes.length - 1];

        // Calculate indicators
        const rsi = ClientTechnicalIndicators.RSI(closes, 14);
        const macd = ClientTechnicalIndicators.MACD(closes);
        const ema9 = ClientTechnicalIndicators.EMA(closes, 9);
        const ema21 = ClientTechnicalIndicators.EMA(closes, 21);
        const ema50 = ClientTechnicalIndicators.EMA(closes, 50);
        const ema200 = ClientTechnicalIndicators.EMA(closes, Math.min(200, closes.length - 1));
        const bb = ClientTechnicalIndicators.BollingerBands(closes);
        const atr = ClientTechnicalIndicators.ATR(candles, 14);
        const volumeMA = ClientTechnicalIndicators.SMA(volumes, 20);

        const latestIndicators = {
          rsi: rsi[rsi.length - 1],
          macd: macd.macd[macd.macd.length - 1],
          macdSignal: macd.signal[macd.signal.length - 1],
          macdHistogram: macd.histogram[macd.histogram.length - 1],
          ema9: ema9[ema9.length - 1],
          ema21: ema21[ema21.length - 1],
          ema50: ema50[ema50.length - 1],
          ema200: ema200[ema200.length - 1],
          bbUpper: bb.upper[bb.upper.length - 1],
          bbMiddle: bb.middle[bb.middle.length - 1],
          bbLower: bb.lower[bb.lower.length - 1],
          atr: atr[atr.length - 1],
          volume: volumes[volumes.length - 1],
          volumeMA: volumeMA[volumeMA.length - 1]
        };

        // ==================== SMART MONEY ANALYSIS ====================

        // 1. Market Structure Analysis (HH/HL/LH/LL)
        const marketStructure = this.analyzeMarketStructure(candles);

        // 2. Volume Analysis
        const volumeAnalysis = this.analyzeVolume(latestIndicators);

        // 3. Order Block / Demand-Supply Zone
        const orderBlocks = this.findOrderBlocks(candles);

        // 4. Pullback Detection
        const pullback = this.detectPullback(candles, latestIndicators);

        // Analyze each indicator
        const analysis = {
          marketStructure,
          volumeAnalysis,
          orderBlocks,
          pullback,
          rsi: this.analyzeRSI(latestIndicators.rsi),
          macd: this.analyzeMACD(latestIndicators),
          ema: this.analyzeEMA(latestIndicators, currentPrice),
          bb: this.analyzeBB(latestIndicators, currentPrice),
          trend: this.analyzeTrend(latestIndicators, currentPrice)
        };

        // Calculate total score v·ªõi tr·ªçng s·ªë m·ªõi
        const totalScore = this.calculateSmartScore(analysis);

        let strength = 'Y·∫æU';
        if (Math.abs(totalScore) >= 8) strength = 'R·∫§T M·∫†NH';
        else if (Math.abs(totalScore) >= 5) strength = 'M·∫†NH';
        else if (Math.abs(totalScore) >= 3) strength = 'TRUNG B√åNH';

        // Generate signal
        const signal = this.generateSignal({ totalScore, strength, analysis }, currentPrice, latestIndicators, candles);

        return {
          currentPrice,
          indicators: {
            rsi: { current: latestIndicators.rsi, period: 14 },
            macd: {
              macd: latestIndicators.macd,
              signal: latestIndicators.macdSignal,
              histogram: latestIndicators.macdHistogram
            },
            ema: { ema9: latestIndicators.ema9, ema21: latestIndicators.ema21, ema50: latestIndicators.ema50, ema200: latestIndicators.ema200 },
            bollingerBands: { upper: latestIndicators.bbUpper, middle: latestIndicators.bbMiddle, lower: latestIndicators.bbLower },
            atr: { current: latestIndicators.atr, period: 14 },
            volume: { current: latestIndicators.volume, ma: latestIndicators.volumeMA }
          },
          analysis,
          signal
        };
      }

      // ==================== SMART MONEY FUNCTIONS ====================

      // Ph√¢n t√≠ch c·∫•u tr√∫c th·ªã tr∆∞·ªùng - t√¨m HH, HL, LH, LL
      analyzeMarketStructure(candles) {
        const lookback = this.config.swingLookback;
        const highs = candles.map(c => c.high);
        const lows = candles.map(c => c.low);

        // T√¨m c√°c swing points
        const swingHighs = [];
        const swingLows = [];

        for (let i = lookback; i < candles.length - lookback; i++) {
          // Swing High: ƒëi·ªÉm cao nh·∫•t trong v√πng lookback
          const leftHighs = highs.slice(i - lookback, i);
          const rightHighs = highs.slice(i + 1, i + lookback + 1);
          if (highs[i] >= Math.max(...leftHighs) && highs[i] >= Math.max(...rightHighs)) {
            swingHighs.push({ index: i, price: highs[i] });
          }

          // Swing Low: ƒëi·ªÉm th·∫•p nh·∫•t trong v√πng lookback
          const leftLows = lows.slice(i - lookback, i);
          const rightLows = lows.slice(i + 1, i + lookback + 1);
          if (lows[i] <= Math.min(...leftLows) && lows[i] <= Math.min(...rightLows)) {
            swingLows.push({ index: i, price: lows[i] });
          }
        }

        // X√°c ƒë·ªãnh trend structure
        let structure = 'SIDEWAY';
        let score = 0;
        let description = '';

        if (swingHighs.length >= 2 && swingLows.length >= 2) {
          const lastHighs = swingHighs.slice(-3);
          const lastLows = swingLows.slice(-3);

          // Check Higher Highs & Higher Lows (Uptrend)
          const isHH = lastHighs.length >= 2 && lastHighs[lastHighs.length - 1].price > lastHighs[lastHighs.length - 2].price;
          const isHL = lastLows.length >= 2 && lastLows[lastLows.length - 1].price > lastLows[lastLows.length - 2].price;

          // Check Lower Highs & Lower Lows (Downtrend)
          const isLH = lastHighs.length >= 2 && lastHighs[lastHighs.length - 1].price < lastHighs[lastHighs.length - 2].price;
          const isLL = lastLows.length >= 2 && lastLows[lastLows.length - 1].price < lastLows[lastLows.length - 2].price;

          if (isHH && isHL) {
            structure = 'UPTREND';
            score = 3;
            description = 'Higher Highs + Higher Lows = Uptrend m·∫°nh';
          } else if (isLH && isLL) {
            structure = 'DOWNTREND';
            score = -3;
            description = 'Lower Highs + Lower Lows = Downtrend m·∫°nh';
          } else if (isHH || isHL) {
            structure = 'WEAK_UPTREND';
            score = 1;
            description = 'C√≥ d·∫•u hi·ªáu uptrend nh∆∞ng ch∆∞a r√µ r√†ng';
          } else if (isLH || isLL) {
            structure = 'WEAK_DOWNTREND';
            score = -1;
            description = 'C√≥ d·∫•u hi·ªáu downtrend nh∆∞ng ch∆∞a r√µ r√†ng';
          }
        }

        return {
          structure,
          score,
          description,
          swingHighs: swingHighs.slice(-3),
          swingLows: swingLows.slice(-3),
          signal: structure
        };
      }

      // Ph√¢n t√≠ch Volume
      analyzeVolume(indicators) {
        const { volume, volumeMA } = indicators;
        if (!volume || !volumeMA) return { score: 0, signal: 'N/A', description: 'Kh√¥ng c√≥ d·ªØ li·ªáu volume' };

        const volumeRatio = volume / volumeMA;
        let score = 0;
        let signal = 'NEUTRAL';
        let description = '';

        if (volumeRatio >= 2.0) {
          score = 2;
          signal = 'VERY_HIGH';
          description = `Volume r·∫•t cao (${volumeRatio.toFixed(1)}x MA) - X√°c nh·∫≠n m·∫°nh`;
        } else if (volumeRatio >= this.config.volumeMultiplier) {
          score = 1;
          signal = 'HIGH';
          description = `Volume cao (${volumeRatio.toFixed(1)}x MA) - C√≥ x√°c nh·∫≠n`;
        } else if (volumeRatio < 0.7) {
          score = -1;
          signal = 'LOW';
          description = `Volume th·∫•p (${volumeRatio.toFixed(1)}x MA) - Kh√¥ng tin c·∫≠y`;
        } else {
          description = `Volume b√¨nh th∆∞·ªùng (${volumeRatio.toFixed(1)}x MA)`;
        }

        return { score, signal, volumeRatio: volumeRatio.toFixed(2), description };
      }

      // T√¨m Order Blocks (v√πng supply/demand)
      findOrderBlocks(candles) {
        const orderBlocks = [];
        const lookback = 20;
        const recentCandles = candles.slice(-lookback);

        for (let i = 1; i < recentCandles.length - 1; i++) {
          const prev = recentCandles[i - 1];
          const curr = recentCandles[i];
          const next = recentCandles[i + 1];

          // Bullish Order Block: n·∫øn gi·∫£m m·∫°nh ‚Üí n·∫øn tƒÉng m·∫°nh (v√πng demand)
          if (prev.close < prev.open && // n·∫øn gi·∫£m
              next.close > next.open && // n·∫øn tƒÉng
              next.close > prev.high && // break above
              (prev.open - prev.close) / prev.close > 0.005) { // n·∫øn gi·∫£m > 0.5%
            orderBlocks.push({
              type: 'DEMAND',
              high: prev.high,
              low: prev.low,
              index: candles.length - lookback + i - 1
            });
          }

          // Bearish Order Block: n·∫øn tƒÉng m·∫°nh ‚Üí n·∫øn gi·∫£m m·∫°nh (v√πng supply)
          if (prev.close > prev.open && // n·∫øn tƒÉng
              next.close < next.open && // n·∫øn gi·∫£m
              next.close < prev.low && // break below
              (prev.close - prev.open) / prev.open > 0.005) { // n·∫øn tƒÉng > 0.5%
            orderBlocks.push({
              type: 'SUPPLY',
              high: prev.high,
              low: prev.low,
              index: candles.length - lookback + i - 1
            });
          }
        }

        // Ki·ªÉm tra gi√° hi·ªán t·∫°i c√≥ g·∫ßn order block kh√¥ng
        const currentPrice = candles[candles.length - 1].close;
        const atr = ClientTechnicalIndicators.ATR(candles, 14);
        const currentATR = atr[atr.length - 1];

        let nearestBlock = null;
        let score = 0;
        let description = 'Kh√¥ng c√≥ Order Block g·∫ßn';

        for (const block of orderBlocks.slice(-5)) {
          const distanceToLow = Math.abs(currentPrice - block.low);
          const distanceToHigh = Math.abs(currentPrice - block.high);
          const minDistance = Math.min(distanceToLow, distanceToHigh);

          if (minDistance < currentATR * 1.5) {
            nearestBlock = block;
            if (block.type === 'DEMAND' && currentPrice <= block.high && currentPrice >= block.low * 0.99) {
              score = 2;
              description = 'Gi√° ƒëang ·ªü v√πng DEMAND - C∆° h·ªôi LONG';
            } else if (block.type === 'SUPPLY' && currentPrice >= block.low && currentPrice <= block.high * 1.01) {
              score = -2;
              description = 'Gi√° ƒëang ·ªü v√πng SUPPLY - C∆° h·ªôi SHORT';
            }
            break;
          }
        }

        return { blocks: orderBlocks.slice(-3), nearestBlock, score, signal: nearestBlock?.type || 'NONE', description };
      }

      // Ph√°t hi·ªán Pullback
      detectPullback(candles, indicators) {
        const { ema21, ema50 } = indicators;
        const currentPrice = candles[candles.length - 1].close;
        const recentCandles = candles.slice(-10);

        let score = 0;
        let signal = 'NONE';
        let description = '';

        // Uptrend pullback: gi√° tr√™n EMA50, v·ª´a ch·∫°m EMA21 v√† b·∫≠t l√™n
        if (currentPrice > ema50 && currentPrice > ema21) {
          const touchedEMA21 = recentCandles.some(c => c.low <= ema21 * 1.005 && c.low >= ema21 * 0.995);
          const bouncedUp = recentCandles.slice(-3).every((c, i, arr) => i === 0 || c.close >= arr[i-1].close);

          if (touchedEMA21 && bouncedUp) {
            score = 2;
            signal = 'BULLISH_PULLBACK';
            description = 'Pullback v·ªÅ EMA21 v√† b·∫≠t l√™n - Entry LONG t·ªët';
          }
        }

        // Downtrend pullback: gi√° d∆∞·ªõi EMA50, v·ª´a ch·∫°m EMA21 v√† gi·∫£m ti·∫øp
        if (currentPrice < ema50 && currentPrice < ema21) {
          const touchedEMA21 = recentCandles.some(c => c.high >= ema21 * 0.995 && c.high <= ema21 * 1.005);
          const bouncedDown = recentCandles.slice(-3).every((c, i, arr) => i === 0 || c.close <= arr[i-1].close);

          if (touchedEMA21 && bouncedDown) {
            score = -2;
            signal = 'BEARISH_PULLBACK';
            description = 'Pullback v·ªÅ EMA21 v√† gi·∫£m ti·∫øp - Entry SHORT t·ªët';
          }
        }

        return { score, signal, description };
      }

      // Ph√¢n t√≠ch Multi-Timeframe (ch·ªâ c·∫ßn trend direction t·ª´ EMA)
      analyzeHTFTrend(candles) {
        const closes = candles.map(c => c.close);
        const ema21 = ClientTechnicalIndicators.EMA(closes, 21);
        const ema50 = ClientTechnicalIndicators.EMA(closes, 50);
        const currentPrice = closes[closes.length - 1];

        const latestEma21 = ema21[ema21.length - 1];
        const latestEma50 = ema50[ema50.length - 1];

        // Trend direction t·ª´ EMA alignment
        if (currentPrice > latestEma21 && latestEma21 > latestEma50) {
          return { trend: 'BULLISH', score: 1, description: 'EMA aligned bullish' };
        } else if (currentPrice < latestEma21 && latestEma21 < latestEma50) {
          return { trend: 'BEARISH', score: -1, description: 'EMA aligned bearish' };
        }
        return { trend: 'NEUTRAL', score: 0, description: 'No clear trend' };
      }

      // T√≠nh ƒëi·ªÉm Smart Money (v·ªõi tr·ªçng s·ªë)
      calculateSmartScore(analysis) {
        let score = 0;

        // Market Structure (tr·ªçng s·ªë cao nh·∫•t: x2)
        score += analysis.marketStructure.score * 2;

        // Volume Confirmation (tr·ªçng s·ªë: x1.5)
        score += analysis.volumeAnalysis.score * 1.5;

        // Order Blocks (tr·ªçng s·ªë: x1.5)
        score += analysis.orderBlocks.score * 1.5;

        // Pullback (tr·ªçng s·ªë: x1.5)
        score += analysis.pullback.score * 1.5;

        // Traditional indicators (tr·ªçng s·ªë: x1)
        score += analysis.rsi.score;
        score += analysis.macd.score;
        score += analysis.ema.score;
        score += analysis.trend.score;

        // BB c√≥ tr·ªçng s·ªë th·∫•p h∆°n
        score += analysis.bb.score * 0.5;

        return Math.round(score * 10) / 10;
      }

      analyzeRSI(rsi) {
        if (rsi === null) return { score: 0, signal: 'N/A', description: 'N/A' };
        if (rsi < 25) return { score: 2, signal: 'OVERSOLD', description: `RSI ${rsi.toFixed(1)} - Qu√° b√°n m·∫°nh` };
        if (rsi < 35) return { score: 1, signal: 'BULLISH', description: `RSI ${rsi.toFixed(1)} - V√πng mua` };
        if (rsi > 75) return { score: -2, signal: 'OVERBOUGHT', description: `RSI ${rsi.toFixed(1)} - Qu√° mua m·∫°nh` };
        if (rsi > 65) return { score: -1, signal: 'BEARISH', description: `RSI ${rsi.toFixed(1)} - V√πng b√°n` };
        return { score: 0, signal: 'NEUTRAL', description: `RSI ${rsi.toFixed(1)} - Trung t√≠nh` };
      }

      analyzeMACD(indicators) {
        const { macd, macdSignal, macdHistogram } = indicators;
        if (macd === null || macdSignal === null) return { score: 0, signal: 'N/A', description: 'N/A' };

        let score = 0;
        let description = '';

        // MACD cross
        if (macd > macdSignal) {
          score += 1;
          description = 'MACD tr√™n Signal';
        } else {
          score -= 1;
          description = 'MACD d∆∞·ªõi Signal';
        }

        // Histogram momentum
        if (macdHistogram > 0 && macdHistogram > 0.0001) {
          score += 1;
          description += ', Histogram d∆∞∆°ng';
        } else if (macdHistogram < 0 && macdHistogram < -0.0001) {
          score -= 1;
          description += ', Histogram √¢m';
        }

        let signal = 'NEUTRAL';
        if (score >= 2) signal = 'BULLISH';
        else if (score <= -2) signal = 'BEARISH';

        return { score, signal, description };
      }

      analyzeEMA(indicators, currentPrice) {
        const { ema9, ema21, ema50, ema200 } = indicators;
        if (!ema9 || !ema21 || !ema50) return { score: 0, signal: 'N/A', description: 'N/A' };

        let score = 0;
        let descriptions = [];

        // EMA alignment
        if (ema9 > ema21 && ema21 > ema50) {
          score += 2;
          descriptions.push('EMA s·∫Øp x·∫øp tƒÉng (9>21>50)');
        } else if (ema9 < ema21 && ema21 < ema50) {
          score -= 2;
          descriptions.push('EMA s·∫Øp x·∫øp gi·∫£m (9<21<50)');
        }

        // Price vs EMA200 (trend filter)
        if (ema200 && currentPrice > ema200) {
          score += 1;
          descriptions.push('Tr√™n EMA200 (macro uptrend)');
        } else if (ema200 && currentPrice < ema200) {
          score -= 1;
          descriptions.push('D∆∞·ªõi EMA200 (macro downtrend)');
        }

        let signal = 'NEUTRAL';
        if (score >= 2) signal = 'BULLISH';
        else if (score <= -2) signal = 'BEARISH';

        return { score, signal, description: descriptions.join(', ') || 'Trung t√≠nh' };
      }

      analyzeBB(indicators, currentPrice) {
        const { bbUpper, bbMiddle, bbLower } = indicators;
        if (!bbUpper || !bbMiddle || !bbLower) return { score: 0, signal: 'N/A', pricePosition: 50, description: 'N/A' };

        const range = bbUpper - bbLower;
        const position = ((currentPrice - bbLower) / range * 100).toFixed(1);

        let score = 0;
        let signal = 'NEUTRAL';
        let description = '';

        if (currentPrice <= bbLower) {
          score = 1; // Gi·∫£m t·ª´ 2 xu·ªëng 1 v√¨ BB kh√¥ng ph·∫£i indicator ch√≠nh
          signal = 'OVERSOLD';
          description = 'Ch·∫°m BB d∆∞·ªõi - C√≥ th·ªÉ bounce';
        } else if (currentPrice >= bbUpper) {
          score = -1;
          signal = 'OVERBOUGHT';
          description = 'Ch·∫°m BB tr√™n - C√≥ th·ªÉ pullback';
        } else if (position < 30) {
          score = 0.5;
          signal = 'BULLISH';
          description = `V·ªã tr√≠ ${position}% - G·∫ßn BB d∆∞·ªõi`;
        } else if (position > 70) {
          score = -0.5;
          signal = 'BEARISH';
          description = `V·ªã tr√≠ ${position}% - G·∫ßn BB tr√™n`;
        } else {
          description = `V·ªã tr√≠ ${position}% - Gi·ªØa BB`;
        }

        return { score, signal, pricePosition: position, description };
      }

      analyzeTrend(indicators, currentPrice) {
        const { ema21, ema50, ema200 } = indicators;
        if (!ema21 || !ema50) return { score: 0, signal: 'N/A', description: 'N/A' };

        if (currentPrice > ema21 && ema21 > ema50 && (!ema200 || ema50 > ema200)) {
          return { score: 2, signal: 'STRONG_UPTREND', description: 'Uptrend m·∫°nh - T·∫•t c·∫£ EMA aligned' };
        } else if (currentPrice > ema50) {
          return { score: 1, signal: 'UPTREND', description: 'Uptrend - Gi√° tr√™n EMA50' };
        } else if (currentPrice < ema21 && ema21 < ema50 && (!ema200 || ema50 < ema200)) {
          return { score: -2, signal: 'STRONG_DOWNTREND', description: 'Downtrend m·∫°nh - T·∫•t c·∫£ EMA aligned' };
        } else if (currentPrice < ema50) {
          return { score: -1, signal: 'DOWNTREND', description: 'Downtrend - Gi√° d∆∞·ªõi EMA50' };
        }
        return { score: 0, signal: 'SIDEWAY', description: 'Sideway - Kh√¥ng c√≥ trend r√µ r√†ng' };
      }

      generateSignal(analysisData, currentPrice, latestIndicators, candles) {
        const { totalScore, strength, analysis } = analysisData;
        const atr = latestIndicators.atr;
        const reasons = [];

        let action = 'WAIT';
        let confidence = 0;

        // ƒêi·ªÅu ki·ªán v√†o l·ªánh ch·∫∑t h∆°n
        const minScore = this.config.minScoreToTrade;
        const hasVolumeConfirm = analysis.volumeAnalysis.score >= 1;
        const hasStructure = Math.abs(analysis.marketStructure.score) >= 2;

        // LONG: c·∫ßn score >= minScore + volume confirm ho·∫∑c structure confirm
        if (totalScore >= minScore && (hasVolumeConfirm || hasStructure)) {
          action = 'LONG';
          confidence = Math.min(95, 40 + totalScore * 5 + (hasVolumeConfirm ? 10 : 0) + (hasStructure ? 15 : 0));
          reasons.push(`Smart Score: ${totalScore} - ƒê·ªß ƒëi·ªÅu ki·ªán LONG`);

          if (analysis.marketStructure.structure === 'UPTREND') {
            reasons.push('Market Structure: Uptrend (HH+HL)');
          }
          if (analysis.pullback.signal === 'BULLISH_PULLBACK') {
            reasons.push('Pullback: Entry t·∫°i EMA21');
          }
          if (analysis.orderBlocks.score > 0) {
            reasons.push('Order Block: ƒêang ·ªü v√πng Demand');
          }
        }
        // SHORT: c·∫ßn score <= -minScore + volume confirm ho·∫∑c structure confirm
        else if (totalScore <= -minScore && (hasVolumeConfirm || hasStructure)) {
          action = 'SHORT';
          confidence = Math.min(95, 40 + Math.abs(totalScore) * 5 + (hasVolumeConfirm ? 10 : 0) + (hasStructure ? 15 : 0));
          reasons.push(`Smart Score: ${totalScore} - ƒê·ªß ƒëi·ªÅu ki·ªán SHORT`);

          if (analysis.marketStructure.structure === 'DOWNTREND') {
            reasons.push('Market Structure: Downtrend (LH+LL)');
          }
          if (analysis.pullback.signal === 'BEARISH_PULLBACK') {
            reasons.push('Pullback: Entry t·∫°i EMA21');
          }
          if (analysis.orderBlocks.score < 0) {
            reasons.push('Order Block: ƒêang ·ªü v√πng Supply');
          }
        }
        // ƒêi·ªÉm cao nh∆∞ng thi·∫øu confirm
        else if (Math.abs(totalScore) >= 3) {
          reasons.push(`Score ${totalScore} - Ch·ªù x√°c nh·∫≠n th√™m`);
          if (!hasVolumeConfirm) reasons.push('Thi·∫øu: Volume confirmation');
          if (!hasStructure) reasons.push('Thi·∫øu: Market structure r√µ r√†ng');
        }
        else {
          reasons.push('Th·ªã tr∆∞·ªùng sideway - Kh√¥ng c√≥ setup r√µ r√†ng');
        }

        // Add analysis details
        reasons.push(`Market: ${analysis.marketStructure.description}`);
        reasons.push(`Volume: ${analysis.volumeAnalysis.description}`);
        if (analysis.orderBlocks.nearestBlock) {
          reasons.push(`Order Block: ${analysis.orderBlocks.description}`);
        }

        // Calculate SL/TP v·ªõi logic m·ªõi
        const atrMultiplier = this.config.atrMultiplier;
        const rrRatio = this.config.riskRewardRatio;

        let stopLoss, takeProfit, leverage, leverageRisk;
        let slPrice, tpPrice;

        if (action === 'LONG') {
          // SL d∆∞·ªõi swing low g·∫ßn nh·∫•t ho·∫∑c 2x ATR
          const recentLow = Math.min(...candles.slice(-10).map(c => c.low));
          slPrice = Math.min(currentPrice - atr * atrMultiplier, recentLow * 0.995);
          tpPrice = currentPrice + Math.abs(currentPrice - slPrice) * rrRatio;

          stopLoss = formatPrice(slPrice);
          takeProfit = formatPrice(tpPrice);
        } else if (action === 'SHORT') {
          // SL tr√™n swing high g·∫ßn nh·∫•t ho·∫∑c 2x ATR
          const recentHigh = Math.max(...candles.slice(-10).map(c => c.high));
          slPrice = Math.max(currentPrice + atr * atrMultiplier, recentHigh * 1.005);
          tpPrice = currentPrice - Math.abs(slPrice - currentPrice) * rrRatio;

          stopLoss = formatPrice(slPrice);
          takeProfit = formatPrice(tpPrice);
        } else {
          // WAIT - v·∫´n t√≠nh SL/TP ƒë·ªÉ hi·ªÉn th·ªã
          slPrice = currentPrice - atr * atrMultiplier;
          tpPrice = currentPrice + atr * atrMultiplier * rrRatio;
          stopLoss = formatPrice(slPrice);
          takeProfit = formatPrice(tpPrice);
        }

        // Calculate leverage based on signal strength v√† risk
        const slPercent = Math.abs((currentPrice - parseFloat(stopLoss)) / currentPrice * 100);

        // Leverage logic m·ªõi: b·∫£o th·ªß h∆°n
        if (confidence >= 80 && slPercent <= 2) {
          leverage = 15;
          leverageRisk = 'MEDIUM-HIGH';
        } else if (confidence >= 70 && slPercent <= 3) {
          leverage = 10;
          leverageRisk = 'MEDIUM';
        } else if (confidence >= 60 && slPercent <= 4) {
          leverage = 7;
          leverageRisk = 'LOW-MEDIUM';
        } else {
          leverage = 5;
          leverageRisk = 'LOW';
        }

        const atrPercent = ((atr / currentPrice) * 100).toFixed(2);

        return {
          action,
          confidence: confidence + '%',
          totalScore,
          averageScore: (totalScore / 10).toFixed(2),
          strength,
          entry: currentPrice,
          stopLoss,
          takeProfit,
          riskPercent: `-${slPercent.toFixed(2)}%`,
          rewardPercent: `+${(slPercent * rrRatio).toFixed(2)}%`,
          riskReward: rrRatio,
          leverage,
          leverageRisk,
          atr: atr ? atr.toFixed(currentPrice > 100 ? 2 : 6) : 'N/A',
          atrPercent: atrPercent + '%',
          reasons,
          // Smart Money data
          marketStructure: analysis.marketStructure.structure,
          volumeConfirm: analysis.volumeAnalysis.signal,
          orderBlock: analysis.orderBlocks.nearestBlock?.type || 'NONE'
        };
      }
    }

    const clientSignalEngine = new ClientSignalEngine();

    // Danh s√°ch t·∫•t c·∫£ coin tr√™n Binance Futures (150+ coins)
    const ALL_SYMBOLS = [
      // Top coins
      'BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'XRPUSDT', 'SOLUSDT', 'ADAUSDT',
      'DOGEUSDT', 'TRXUSDT', 'DOTUSDT', 'LINKUSDT', 'AVAXUSDT', 'MATICUSDT',
      'LTCUSDT', 'BCHUSDT', 'XLMUSDT', 'ATOMUSDT', 'UNIUSDT', 'ETCUSDT',

      // Layer 1 & Layer 2
      'APTUSDT', 'ARBUSDT', 'OPUSDT', 'SUIUSDT', 'SEIUSDT', 'NEARUSDT',
      'FTMUSDT', 'ALGOUSDT', 'ICPUSDT', 'VETUSDT', 'HBARUSDT', 'QNTUSDT',
      'INJUSDT', 'TIAUSDT', 'STXUSDT', 'MANTAUSDT', 'BLURUSDT', 'STRKUSDT',
      'ZKUSDT', 'SCROLLUSDT', 'EIGENUSDT',

      // DeFi
      'AAVEUSDT', 'MKRUSDT', 'COMPUSDT', 'SNXUSDT', 'CRVUSDT', 'LDOUSDT',
      'GMXUSDT', 'DYDXUSDT', 'PENDLEUSDT', 'JUPUSDT', 'RAYDIUMUSDT',
      '1INCHUSDT', 'SUSHIUSDT', 'YFIUSDT', 'BALUSDT', 'ZABORUSDT',

      // Gaming & Metaverse
      'SANDUSDT', 'MANAUSDT', 'AXSUSDT', 'GALAUSDT', 'ENJUSDT', 'IMXUSDT',
      'ILVUSDT', 'MAGICUSDT', 'GMTUSDT', 'LOOKSUSDT', 'HIGHUSDT', 'ACEUSDT',
      'PIXELUSDT', 'PORTALUSDT', 'XABORUSDT', 'RONUSDT',

      // AI & Data
      'RNDRUSDT', 'FETUSDT', 'AGIXUSDT', 'OCEANUSDT', 'ARKMUSDT', 'WLDUSDT',
      'TAOUSDT', 'AIUSDT', 'NFPUSDT', 'ALTUSDT',

      // Meme coins
      'PEPEUSDT', 'SHIBUSDT', 'FLOKIUSDT', 'BONKUSDT', 'WIFUSDT', 'MEMEUSDT',
      'BOMEUSDT', 'PEOPLEUSDT', 'LUNCUSDT', 'NEIROUSDT', 'TURBOFLOKIUSDT',
      '1000PEPEUSDT', '1000SHIBUSDT', '1000FLOKIUSDT', '1000BONKUSDT',
      '1000LUNCUSDT', 'DOGEUSDT', 'BABYDOGEUSDT',

      // Storage & Infrastructure
      'FILUSDT', 'ARUSDT', 'STORJUSDT', 'SCUSDT', 'ABORUSDT',

      // Oracle & Cross-chain
      'BANDUSDT', 'APIUSDT', 'CELRUSDT', 'RENUSDT', 'COTIUSDT',

      // Exchange tokens
      'BNBUSDT', 'FTMUSDT', 'CAKEUSDT', 'OOKIUSDT',

      // Privacy coins
      'XMRUSDT', 'ZECUSDT', 'DASHUSDT',

      // New & Trending
      'ORDIUSDT', 'KASUSDT', 'RUNEUSDT', 'ENAUSDT', 'WUSDT', 'TONUSDT',
      'NOTUSDT', 'DOGSUSDT', 'CATIUSDT', 'HMSTRUSDT', 'SCRUSDT',
      'MOVEUSDT', 'MEUSDT', 'VANAUSDT', 'PENGUUSDT', 'USUALUSDT',

      // Others
      'GRTUSDT', 'CHZUSDT', 'APEUSDT', 'LRCUSDT', 'RSRUSDT', 'KAVAUSDT',
      'IOSTUSDT', 'ZILUSDT', 'ONTUSDT', 'IOTAUSDT', 'NEOUSDT', 'WAVESUSDT',
      'EOSUSDT', 'XTZUSDT', 'THETAUSDT', 'EGLDUSDT', 'FLOWUSDT', 'MINAUSDT',
      'CFXUSDT', 'ACHUSDT', 'ANKRUSDT', 'SKLUSDT', 'WOOUSDT', 'AGLDUSDT',
      'MASKUSDT', 'ENSUSDT', 'SSUSDT', 'BICOUSDT', 'TUSDT', 'EDUUSDT',
      'IDUSDT', 'RDNTUSDT', 'MAVUSDT', 'XVSUSDT', 'UMAUSDT', 'LEVERUSDT',
      'KEYUSDT', 'COMBOUSDT', 'NMRUSDT', 'MDTUSDT', 'XEMUSDT', 'BELUSDT',
      'LITUSDT', 'CKBUSDT', 'PERPUSDT', 'TRUUSDT', 'LQTYUSDT', 'UXLINKUSDT'
    ];

    // Symbol search functions
    function showSymbolList() {
      // X√≥a n·ªôi dung khi focus ƒë·ªÉ hi·ªÉn th·ªã t·∫•t c·∫£ coin
      const searchEl = document.getElementById('symbolSearch');
      const listEl = document.getElementById('symbolList');
      if (searchEl) searchEl.value = '';
      filterSymbols();
      if (listEl) listEl.style.display = 'block';
    }

    function hideSymbolList() {
      setTimeout(() => {
        const listEl = document.getElementById('symbolList');
        if (listEl) listEl.style.display = 'none';
      }, 200);
    }

    function filterSymbols() {
      const searchEl = document.getElementById('symbolSearch');
      const list = document.getElementById('symbolList');
      if (!searchEl || !list) return;

      const search = searchEl.value.toUpperCase();

      // N·∫øu ch∆∞a g√µ g√¨, hi·ªÉn th·ªã t·∫•t c·∫£ (c√≥ scroll), n·∫øu c√≥ search th√¨ filter
      const filtered = search
        ? ALL_SYMBOLS.filter(s => s.includes(search))
        : ALL_SYMBOLS;

      if (filtered.length === 0) {
        list.innerHTML = '<div class="symbol-dropdown-item"><span>Kh√¥ng t√¨m th·∫•y</span></div>';
      } else {
        list.innerHTML = filtered.map(s => {
          const coin = s.replace('USDT', '');
          return `
            <div class="symbol-dropdown-item" onclick="selectCoin('${s}')">
              <span class="coin-name">${coin}</span>
              <span class="coin-pair">${s}</span>
            </div>
          `;
        }).join('');
      }

      list.style.display = 'block';
    }

    function selectCoin(symbol) {
      const symbolEl = document.getElementById('symbol');
      const searchEl = document.getElementById('symbolSearch');
      const listEl = document.getElementById('symbolList');
      if (symbolEl) symbolEl.value = symbol;
      if (searchEl) searchEl.value = symbol.replace('USDT', '/USDT');
      if (listEl) listEl.style.display = 'none';
      analyzeSignal();
    }

    // Click outside to close dropdown
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.control-group')) {
        document.getElementById('symbolList').style.display = 'none';
      }
    });

    // Tab switching
    function switchTab(tab) {
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('[id$="-tab"]').forEach(t => t.style.display = 'none');

      event.target.classList.add('active');
      document.getElementById(tab + '-tab').style.display = 'block';
    }

    // Single symbol analysis
    async function analyzeSignal() {
      const symbol = document.getElementById('symbol').value;
      const interval = document.getElementById('interval').value;
      const market = document.getElementById('market').value;
      const btn = document.getElementById('analyzeBtn');
      const resultDiv = document.getElementById('signal-result');

      btn.disabled = true;
      btn.textContent = 'ƒêang ph√¢n t√≠ch...';
      resultDiv.innerHTML = '<div class="loading">ƒêang ph√¢n t√≠ch</div>';

      try {
        let data;

        if (IS_CLOUDFLARE) {
          // Client-side analysis for Cloudflare (bypass Binance IP block)
          console.log('[Cloudflare Mode] Fetching directly from Binance...');

          // Fetch main timeframe
          const candles = await fetchBinanceKlines(symbol, interval, 100);
          const result = clientSignalEngine.analyze(candles);
          result.symbol = symbol.toUpperCase();
          result.interval = interval;
          result.market = market;

          // Multi-Timeframe Analysis
          const htfIntervals = MTF_MAP[interval] || ['1h', '4h'];
          const mtfResults = [];

          resultDiv.innerHTML = '<div class="loading">ƒêang ph√¢n t√≠ch Multi-Timeframe...</div>';

          for (const htfInterval of htfIntervals) {
            try {
              const htfCandles = await fetchBinanceKlines(symbol, htfInterval, 60);
              const htfTrend = clientSignalEngine.analyzeHTFTrend(htfCandles);
              mtfResults.push({
                interval: htfInterval,
                ...htfTrend
              });
              await new Promise(resolve => setTimeout(resolve, 50)); // Rate limit
            } catch (err) {
              console.error(`Error fetching ${htfInterval}:`, err);
              mtfResults.push({
                interval: htfInterval,
                trend: 'UNKNOWN',
                score: 0,
                description: 'Kh√¥ng l·∫•y ƒë∆∞·ª£c d·ªØ li·ªáu'
              });
            }
          }

          // T√≠nh MTF Confirmation
          const mtfBullish = mtfResults.filter(r => r.trend === 'BULLISH').length;
          const mtfBearish = mtfResults.filter(r => r.trend === 'BEARISH').length;
          const totalMTF = mtfResults.length;

          let mtfConfirmation = {
            results: mtfResults,
            bullishCount: mtfBullish,
            bearishCount: mtfBearish,
            totalCount: totalMTF,
            signal: 'NEUTRAL',
            confirmed: false,
            description: ''
          };

          if (mtfBullish >= totalMTF * 0.5) {
            mtfConfirmation.signal = 'BULLISH';
            mtfConfirmation.confirmed = result.signal.action === 'LONG';
            mtfConfirmation.description = `${mtfBullish}/${totalMTF} HTF bullish - ${mtfConfirmation.confirmed ? 'X√ÅC NH·∫¨N LONG' : 'C·∫£nh b√°o: Ng∆∞·ª£c trend HTF'}`;
          } else if (mtfBearish >= totalMTF * 0.5) {
            mtfConfirmation.signal = 'BEARISH';
            mtfConfirmation.confirmed = result.signal.action === 'SHORT';
            mtfConfirmation.description = `${mtfBearish}/${totalMTF} HTF bearish - ${mtfConfirmation.confirmed ? 'X√ÅC NH·∫¨N SHORT' : 'C·∫£nh b√°o: Ng∆∞·ª£c trend HTF'}`;
          } else {
            mtfConfirmation.description = 'HTF kh√¥ng r√µ r√†ng - C·∫©n th·∫≠n';
          }

          // ƒêi·ªÅu ch·ªânh signal d·ª±a tr√™n MTF
          if (result.signal.action !== 'WAIT' && !mtfConfirmation.confirmed) {
            // Gi·∫£m confidence n·∫øu ng∆∞·ª£c trend HTF
            const currentConf = parseFloat(result.signal.confidence);
            result.signal.confidence = Math.max(40, currentConf - 20) + '%';
            result.signal.reasons.push(`‚ö†Ô∏è MTF: ${mtfConfirmation.description}`);
          } else if (mtfConfirmation.confirmed) {
            // TƒÉng confidence n·∫øu c√πng trend HTF
            const currentConf = parseFloat(result.signal.confidence);
            result.signal.confidence = Math.min(95, currentConf + 10) + '%';
            result.signal.reasons.push(`‚úÖ MTF: ${mtfConfirmation.description}`);
          }

          // Th√™m MTF data v√†o result
          result.analysis.mtf = mtfConfirmation;
          result.signal.mtfConfirmed = mtfConfirmation.confirmed;

          data = { success: true, data: result };
        } else {
          // Server-side analysis for local/VPS
          const response = await fetch(`${API_BASE}/api/signal/${symbol}?interval=${interval}&market=${market}`);
          data = await response.json();
        }

        if (data.success) {
          renderSignal(data.data);
        } else {
          resultDiv.innerHTML = `<div class="signal-card"><p style="color: #ff5252;">L·ªói: ${data.error}</p></div>`;
        }
      } catch (error) {
        resultDiv.innerHTML = `<div class="signal-card"><p style="color: #ff5252;">L·ªói k·∫øt n·ªëi: ${error.message}</p></div>`;
      }

      btn.disabled = false;
      btn.textContent = 'Ph√¢n t√≠ch';
    }

    // Render signal result
    function renderSignal(data) {
      const { signal, indicators, analysis, currentPrice, symbol, interval } = data;

      const signalClass = signal.action === 'LONG' ? 'signal-long' :
                         signal.action === 'SHORT' ? 'signal-short' : 'signal-wait';

      const html = `
        <div class="signal-card">
          <div class="signal-header">
            <div class="symbol-info">
              <span class="symbol-name">${symbol}</span>
              <span class="price">$${currentPrice.toLocaleString()}</span>
              <span style="color: #888; font-size: 0.9em;">${interval}</span>
              <button class="btn-chart" onclick="openChart('${symbol}')">üìà Xem Chart</button>
            </div>
            <div class="signal-badge ${signalClass}">
              ${signal.action} ${signal.action !== 'WAIT' ? `(${signal.confidence})` : ''}
            </div>
          </div>

          <div class="indicators-grid">
            <div class="indicator-box">
              <h4>RSI (14)</h4>
              <div class="value ${analysis.rsi.score > 0 ? 'bullish' : analysis.rsi.score < 0 ? 'bearish' : 'neutral'}">
                ${indicators.rsi.current ? indicators.rsi.current.toFixed(2) : 'N/A'}
              </div>
              <div class="status">${analysis.rsi.signal}</div>
            </div>

            <div class="indicator-box">
              <h4>MACD</h4>
              <div class="value ${analysis.macd.score > 0 ? 'bullish' : analysis.macd.score < 0 ? 'bearish' : 'neutral'}">
                ${indicators.macd.histogram ? indicators.macd.histogram.toFixed(4) : 'N/A'}
              </div>
              <div class="status">${analysis.macd.signal}</div>
            </div>

            <div class="indicator-box">
              <h4>EMA (9/21/50)</h4>
              <div class="value ${analysis.ema.score > 0 ? 'bullish' : analysis.ema.score < 0 ? 'bearish' : 'neutral'}">
                ${analysis.ema.signal}
              </div>
              <div class="status">${analysis.trend.signal}</div>
            </div>

            <div class="indicator-box">
              <h4>Bollinger Bands</h4>
              <div class="value ${analysis.bb.score > 0 ? 'bullish' : analysis.bb.score < 0 ? 'bearish' : 'neutral'}">
                ${analysis.bb.pricePosition}%
              </div>
              <div class="status">${analysis.bb.signal}</div>
            </div>

            <div class="indicator-box">
              <h4>ATR (14)</h4>
              <div class="value neutral">
                ${signal.atr || 'N/A'}
              </div>
              <div class="status">Volatility</div>
            </div>

            <div class="indicator-box">
              <h4>T·ªïng ƒëi·ªÉm</h4>
              <div class="value ${signal.totalScore > 0 ? 'bullish' : signal.totalScore < 0 ? 'bearish' : 'neutral'}">
                ${signal.totalScore} (${signal.averageScore})
              </div>
              <div class="status">${signal.strength}</div>
            </div>
          </div>

          ${signal.action !== 'WAIT' ? `
          <div class="trade-setup">
            <div class="trade-item">
              <label>Entry Price</label>
              <div class="value entry">$${signal.entry.toLocaleString()}</div>
            </div>
            <div class="trade-item">
              <label>Stop Loss</label>
              <div class="value stop-loss">$${parseFloat(signal.stopLoss).toLocaleString()}</div>
              <div style="color: #ff5252; font-size: 0.85em;">${signal.riskPercent}</div>
            </div>
            <div class="trade-item">
              <label>Take Profit</label>
              <div class="value take-profit">$${parseFloat(signal.takeProfit).toLocaleString()}</div>
              <div style="color: #00ff88; font-size: 0.85em;">${signal.rewardPercent}</div>
            </div>
            <div class="trade-item">
              <label>Risk/Reward</label>
              <div class="value neutral">1:${signal.riskReward}</div>
            </div>
            <div class="trade-item">
              <label>ƒê√≤n b·∫©y g·ª£i √Ω</label>
              <div class="value" style="color: ${signal.leverageRisk === 'SAFE' ? '#00ff88' : signal.leverageRisk === 'LOW' ? '#00d9ff' : '#ffd700'}; font-size: 1.5em;">
                ${signal.leverage}x
              </div>
              <div style="font-size: 0.85em; color: ${signal.leverageRisk === 'SAFE' ? '#00ff88' : signal.leverageRisk === 'LOW' ? '#00d9ff' : '#ffd700'};">
                ${signal.leverageRisk === 'SAFE' ? 'An to√†n' : signal.leverageRisk === 'LOW' ? 'R·ªßi ro th·∫•p' : 'R·ªßi ro TB'}
              </div>
            </div>
            <div class="trade-item">
              <label>ATR %</label>
              <div class="value neutral">${signal.atrPercent || 'N/A'}</div>
              <div style="font-size: 0.85em; color: #888;">Volatility</div>
            </div>
          </div>
          ` : ''}

          <div class="reasons">
            <h4>L√Ω do ${signal.action === 'WAIT' ? 'ch·ªù ƒë·ª£i' : signal.action}</h4>
            <ul>
              ${signal.reasons.map(r => `<li>${r}</li>`).join('')}
            </ul>
          </div>

          ${signal.action !== 'WAIT' ? `
          <div class="order-entry">
            <h4>M·ªü l·ªánh ${signal.action}</h4>
            <div class="order-grid">
              <div>
                <label style="display: block; margin-bottom: 5px; color: #888; font-size: 0.85em;">Margin (USDT)</label>
                <input type="number" id="order-margin" placeholder="VD: 5, 10, 50..." value="10" min="1" step="1">
              </div>
              <div>
                <label style="display: block; margin-bottom: 5px; color: #888; font-size: 0.85em;">Gi√° v√†o</label>
                <input type="number" id="order-entry" value="${signal.entry}" step="0.01">
              </div>
              <div>
                <label style="display: block; margin-bottom: 5px; color: #888; font-size: 0.85em;">Leverage</label>
                <input type="number" id="order-leverage" value="${signal.leverage}" min="1" max="125">
              </div>
              <div>
                <label style="display: block; margin-bottom: 5px; color: #888; font-size: 0.85em;">Stop Loss</label>
                <input type="number" id="order-sl" value="${signal.stopLoss}" step="0.01">
              </div>
              <div>
                <label style="display: block; margin-bottom: 5px; color: #888; font-size: 0.85em;">Take Profit</label>
                <input type="number" id="order-tp" value="${signal.takeProfit}" step="0.01">
              </div>
            </div>
            <div class="order-buttons">
              <button class="btn-long" onclick="openPosition('LONG')">Luu LONG (Local)</button>
              <button class="btn-short" onclick="openPosition('SHORT')">Luu SHORT (Local)</button>
            </div>
            <div class="order-buttons admin-only" style="margin-top: 10px; display: ${isAdminMode ? 'flex' : 'none'};">
              <button class="btn-trade-binance" onclick="openBinancePosition('${signal.action}')">
                <span style="font-size: 1.2em;">&#9889;</span> VAO LENH ${signal.action} TREN BINANCE
              </button>
            </div>
            <div class="admin-only" style="text-align: center; margin-top: 10px; font-size: 0.8em; color: #888; display: ${isAdminMode ? 'block' : 'none'};">
              Luu local: chi theo doi, khong giao dich that<br>
              Vao lenh Binance: dat lenh THAT tren Binance (can cau hinh API)
            </div>
          </div>
          ` : ''}
        </div>
      `;

      document.getElementById('signal-result').innerHTML = html;

      // Store current signal data for opening positions
      currentSignalData = data;

      // Auto-fill calculator
      if (signal.action !== 'WAIT') {
        const entryEl = document.getElementById('entry');
        const slEl = document.getElementById('sl');
        if (entryEl) entryEl.value = signal.entry;
        if (slEl) slEl.value = signal.stopLoss;
      }
    }

    // Scan multiple symbols - QU√âT TO√ÄN B·ªò TH·ªä TR∆Ø·ªúNG
    async function scanSignals() {
      const interval = document.getElementById('multi-interval').value;
      const btn = document.getElementById('scanBtn');
      const resultDiv = document.getElementById('multi-result');

      btn.disabled = true;
      btn.textContent = 'ƒêang qu√©t...';
      resultDiv.innerHTML = '<div class="loading">üîç ƒêang qu√©t TO√ÄN B·ªò th·ªã tr∆∞·ªùng Futures (~100+ ƒë·ªìng)...</div>';

      try {
        let data;

        if (IS_CLOUDFLARE) {
          // Client-side scan for Cloudflare - qu√©t t·ª´ Binance tr·ª±c ti·∫øp
          console.log('[Cloudflare Mode] Scanning ALL futures symbols from browser...');

          // L·∫•y t·∫•t c·∫£ futures symbols
          resultDiv.innerHTML = '<div class="loading">üîç ƒêang l·∫•y danh s√°ch symbols t·ª´ Binance...</div>';
          const exchangeInfo = await fetch('https://fapi.binance.com/fapi/v1/exchangeInfo').then(r => r.json());
          const ticker24h = await fetch('https://fapi.binance.com/fapi/v1/ticker/24hr').then(r => r.json());

          // T·∫°o map volume
          const volumeMap = {};
          ticker24h.forEach(t => {
            volumeMap[t.symbol] = {
              volume: parseFloat(t.quoteVolume),
              priceChange: parseFloat(t.priceChangePercent),
              lastPrice: parseFloat(t.lastPrice)
            };
          });

          // L·ªçc symbols c√≥ volume > 10M USDT
          const validSymbols = exchangeInfo.symbols
            .filter(s => {
              if (!s.symbol.endsWith('USDT')) return false;
              if (s.contractType !== 'PERPETUAL') return false;
              if (s.status !== 'TRADING') return false;
              if (s.symbol.includes('_')) return false;
              const vol = volumeMap[s.symbol];
              return vol && vol.volume > 10000000;
            })
            .map(s => ({ symbol: s.symbol, ...volumeMap[s.symbol] }))
            .sort((a, b) => b.volume - a.volume);

          console.log(`Found ${validSymbols.length} symbols with volume > 10M`);

          const results = [];
          let scanned = 0;

          for (const symInfo of validSymbols) {
            try {
              resultDiv.innerHTML = `<div class="loading">üîç ƒêang qu√©t ${symInfo.symbol}... (${scanned}/${validSymbols.length})</div>`;
              const candles = await fetchBinanceKlines(symInfo.symbol, interval, 100);
              const result = clientSignalEngine.analyze(candles);

              if (result.signal && result.signal.action !== 'WAIT') {
                results.push({
                  symbol: symInfo.symbol,
                  volume24h: symInfo.volume,
                  priceChange24h: symInfo.priceChange,
                  lastPrice: symInfo.lastPrice,
                  action: result.signal.action,
                  confidence: parseFloat(result.signal.confidence),
                  totalScore: result.signal.totalScore,
                  strength: result.signal.strength,
                  entry: result.signal.entry,
                  stopLoss: result.signal.stopLoss,
                  takeProfit: result.signal.takeProfit,
                  riskPercent: result.signal.riskPercent,
                  rewardPercent: result.signal.rewardPercent,
                  riskReward: result.signal.riskReward,
                  leverage: result.signal.leverage,
                  reason: result.signal.reason,
                  interval: interval
                });
              }
              scanned++;
              await new Promise(resolve => setTimeout(resolve, 30));
            } catch (err) {
              scanned++;
            }
          }

          // S·∫Øp x·∫øp v√† l·∫•y top 3
          results.sort((a, b) => {
            const scoreA = Math.abs(a.totalScore) * 10 + a.confidence + Math.log10(a.volume24h);
            const scoreB = Math.abs(b.totalScore) * 10 + b.confidence + Math.log10(b.volume24h);
            return scoreB - scoreA;
          });

          data = {
            success: true,
            totalScanned: validSymbols.length,
            totalSignals: results.length,
            top3: results.slice(0, 3),
            allSignals: results
          };
        } else {
          // Server-side scan - QU√âT TO√ÄN B·ªò
          const response = await fetch(`${API_BASE}/api/scan-all?interval=${interval}`);
          data = await response.json();
        }

        if (data.success) {
          renderTop3Signals(data);
        } else {
          resultDiv.innerHTML = `<div class="signal-card"><p style="color: #ff5252;">L·ªói: ${data.error}</p></div>`;
        }
      } catch (error) {
        resultDiv.innerHTML = `<div class="signal-card"><p style="color: #ff5252;">L·ªói k·∫øt n·ªëi: ${error.message}</p></div>`;
      }

      btn.disabled = false;
      btn.textContent = 'Qu√©t t·∫•t c·∫£';
    }

    // Render TOP 3 signals
    function renderTop3Signals(data) {
      const resultDiv = document.getElementById('multi-result');

      let html = `
        <div style="padding: 15px; background: linear-gradient(135deg, rgba(0,217,255,0.1), rgba(0,255,136,0.1)); border-radius: 12px; margin-bottom: 20px; text-align: center;">
          <h3 style="color: #00d9ff; margin-bottom: 10px;">üèÜ TOP 3 T√çN HI·ªÜU T·ªêT NH·∫§T</h3>
          <p style="color: #888; font-size: 0.9em;">
            ƒê√£ qu√©t <strong style="color: #00ff88;">${data.totalScanned}</strong> ƒë·ªìng |
            T√¨m th·∫•y <strong style="color: #ffd700;">${data.totalSignals}</strong> t√≠n hi·ªáu
          </p>
        </div>
      `;

      if (data.top3.length === 0) {
        html += `<div class="signal-card" style="text-align: center; padding: 30px;">
          <p style="color: #ffd700;">‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y t√≠n hi·ªáu n√†o ƒë·ªß m·∫°nh</p>
          <p style="color: #888; margin-top: 10px;">Th·ªã tr∆∞·ªùng ƒëang sideway ho·∫∑c ch∆∞a c√≥ ƒëi·ªÉm v√†o t·ªët</p>
        </div>`;
      } else {
        // L∆∞u data ƒë·ªÉ d√πng khi click
        window.scannedSignals = data.top3;

        // Render top 3
        data.top3.forEach((s, index) => {
          const rankEmoji = ['ü•á', 'ü•à', 'ü•â'][index];
          const signalClass = s.action === 'LONG' ? 'signal-long' : 'signal-short';
          const actionColor = s.action === 'LONG' ? '#10a050' : '#ab47bc';
          const volumeFormatted = (s.volume24h / 1000000).toFixed(1) + 'M';

          html += `
            <div class="signal-card ${signalClass}" style="margin-bottom: 15px; border: 1px solid ${actionColor}60; cursor: pointer;" onclick="openTradeFromSignal(${index})">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <div>
                  <span style="font-size: 1.5em;">${rankEmoji}</span>
                  <span style="font-size: 1.3em; font-weight: bold; margin-left: 10px;">${s.symbol}</span>
                  <span style="background: ${actionColor}; color: #fff; padding: 3px 10px; border-radius: 4px; font-weight: bold; margin-left: 10px;">${s.action}</span>
                </div>
                <div style="text-align: right;">
                  <div style="color: #00d9ff; font-size: 0.85em;">Score: ${s.totalScore}</div>
                  <div style="color: #888; font-size: 0.8em;">Vol: $${volumeFormatted}</div>
                </div>
              </div>

              <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-bottom: 15px;">
                <div style="background: rgba(255,255,255,0.05); padding: 10px; border-radius: 8px; text-align: center;">
                  <div style="color: #888; font-size: 0.75em;">Entry</div>
                  <div style="color: #fff; font-weight: bold;">$${parseFloat(s.entry).toFixed(4)}</div>
                </div>
                <div style="background: rgba(255,82,82,0.1); padding: 10px; border-radius: 8px; text-align: center;">
                  <div style="color: #888; font-size: 0.75em;">Stop Loss</div>
                  <div style="color: #ff5252; font-weight: bold;">$${s.stopLoss}</div>
                  <div style="color: #ff5252; font-size: 0.75em;">${s.riskPercent}</div>
                </div>
                <div style="background: rgba(0,255,136,0.1); padding: 10px; border-radius: 8px; text-align: center;">
                  <div style="color: #888; font-size: 0.75em;">Take Profit</div>
                  <div style="color: #00ff88; font-weight: bold;">$${s.takeProfit}</div>
                  <div style="color: #00ff88; font-size: 0.75em;">${s.rewardPercent}</div>
                </div>
                <div style="background: rgba(0,217,255,0.1); padding: 10px; border-radius: 8px; text-align: center;">
                  <div style="color: #888; font-size: 0.75em;">Leverage</div>
                  <div style="color: #00d9ff; font-weight: bold;">${s.leverage}x</div>
                  <div style="color: #ffd700; font-size: 0.75em;">R:R ${s.riskReward}</div>
                </div>
              </div>

              <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                <button onclick="event.stopPropagation(); openTradeFromSignal(${index})" class="btn-${s.action.toLowerCase()}" style="flex: 1; padding: 12px; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; font-size: 1em;">
                  üöÄ V√ÄO L·ªÜNH ${s.action}
                </button>
                <button onclick="event.stopPropagation(); openChart('${s.symbol}')" style="padding: 12px 20px; background: rgba(0,217,255,0.2); border: 1px solid #00d9ff; color: #00d9ff; border-radius: 8px; cursor: pointer;">
                  üìà
                </button>
              </div>

              <div style="background: rgba(255,255,255,0.03); padding: 10px; border-radius: 8px; font-size: 0.85em;">
                ${s.reason ? s.reason.slice(0, 3).map(r => `<div style="color: #aaa; margin: 3px 0;">${r}</div>`).join('') : ''}
              </div>
            </div>
          `;
        });
      }

      // Th√™m section hi·ªÉn th·ªã t·∫•t c·∫£ signals kh√°c
      if (data.allSignals && data.allSignals.length > 3) {
        html += `
          <div style="margin-top: 20px;">
            <details>
              <summary style="cursor: pointer; color: #00d9ff; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                üìã Xem th√™m ${data.allSignals.length - 3} t√≠n hi·ªáu kh√°c
              </summary>
              <div style="margin-top: 10px;">
        `;

        data.allSignals.slice(3).forEach((s, index) => {
          const actionColor = s.action === 'LONG' ? '#00ff88' : '#e040fb';
          html += `
            <div style="display: flex; justify-content: space-between; padding: 8px; background: rgba(255,255,255,0.02); margin: 5px 0; border-radius: 5px; border-left: 3px solid ${actionColor};">
              <span><strong>${s.symbol}</strong> <span style="color: ${actionColor};">${s.action}</span></span>
              <span style="color: #888;">Score: ${s.totalScore} | Entry: $${parseFloat(s.entry).toFixed(4)}</span>
            </div>
          `;
        });

        html += `</div></details></div>`;
      }

      resultDiv.innerHTML = html;
    }

    // Render multiple signals
    function renderMultiSignals(signals) {
      // L·ªçc b·ªè l·ªói v√† ch·ªâ l·∫•y nh·ªØng ƒë·ªìng c√≥ signal
      const validSignals = signals.filter(s => !s.error && s.signal);

      // Sort by signal strength (ƒëi·ªÉm cao nh·∫•t tr∆∞·ªõc)
      validSignals.sort((a, b) => {
        return Math.abs(b.signal.totalScore) - Math.abs(a.signal.totalScore);
      });

      // Ch·ªâ l·∫•y top 15 ƒë·ªìng c√≥ ƒëi·ªÉm cao nh·∫•t
      const top15 = validSignals.slice(0, 15);

      // Th√™m header hi·ªÉn th·ªã th√¥ng tin
      let headerHtml = `
        <div style="padding: 10px; background: rgba(255,215,0,0.1); border-radius: 8px; margin-bottom: 10px; text-align: center;">
          <span style="color: #ffd700;">üìä Top 15 ƒë·ªìng c√≥ t√≠n hi·ªáu m·∫°nh nh·∫•t</span>
          <span style="color: #888; font-size: 0.85em;"> (t·ª´ ${signals.length} ƒë·ªìng)</span>
        </div>
      `;

      const html = top15.map((s, index) => {
        const signalClass = s.signal.action === 'LONG' ? 'signal-long' :
                           s.signal.action === 'SHORT' ? 'signal-short' : 'signal-wait';

        const confidence = parseFloat(s.signal.confidence) || 0;
        const rankBadge = index < 3 ? ['ü•á', 'ü•à', 'ü•â'][index] : `#${index + 1}`;

        return `
          <div class="mini-signal" style="${index < 3 ? 'border: 1px solid #ffd700;' : ''}">
            <div onclick="selectSymbol('${s.symbol}')" style="cursor: pointer;">
              <div class="symbol">
                <span style="margin-right: 5px;">${rankBadge}</span>
                ${s.symbol.replace('USDT', '')}
              </div>
              <div class="price-info">$${s.currentPrice.toLocaleString()}</div>
            </div>
            <div onclick="selectSymbol('${s.symbol}')" style="cursor: pointer;">
              <div style="color: #888; font-size: 0.85em;">Score: ${s.signal.totalScore} | ${s.signal.strength}</div>
              <div class="confidence-bar">
                <div class="confidence-fill" style="width: ${confidence}%; background: ${s.signal.action === 'LONG' ? '#00ff88' : s.signal.action === 'SHORT' ? '#e040fb' : '#888'};"></div>
              </div>
            </div>
            <div style="display: flex; align-items: center; gap: 8px;">
              <button onclick="event.stopPropagation(); openChart('${s.symbol}')" style="background: none; border: 1px solid #00d9ff; color: #00d9ff; padding: 4px 10px; border-radius: 4px; cursor: pointer; font-size: 0.85em;">üìà</button>
              <div class="mini-badge ${signalClass}">${s.signal.action}</div>
            </div>
          </div>
        `;
      }).join('');

      document.getElementById('multi-result').innerHTML = headerHtml + html;
    }

    // Select symbol from multi scan
    function selectSymbol(symbol) {
      const symbolEl = document.getElementById('symbol');
      if (symbolEl) symbolEl.value = symbol;
      switchTab('single');
      const tabEl = document.querySelector('.tab');
      if (tabEl) tabEl.click();
      analyzeSignal();
    }

    // M·ªü form v√†o l·ªánh t·ª´ t√≠n hi·ªáu ƒë√£ qu√©t
    async function openTradeFromSignal(index) {
      const signal = window.scannedSignals[index];
      if (!signal) {
        showToast({ type: 'error', title: 'L·ªói', message: 'Kh√¥ng t√¨m th·∫•y t√≠n hi·ªáu!' });
        return;
      }

      // L∆∞u th√¥ng tin signal ƒë·ªÉ ƒëi·ªÅn sau khi ph√¢n t√≠ch
      window.pendingSignal = signal;

      // Ch·ªçn symbol v√† chuy·ªÉn sang tab single
      const symbolEl = document.getElementById('symbol');
      if (symbolEl) symbolEl.value = signal.symbol;
      switchTab('single');

      // Ph√¢n t√≠ch symbol
      await analyzeSignal();

      // Sau khi ph√¢n t√≠ch xong, ƒëi·ªÅn th√¥ng s·ªë t·ª´ signal ƒë√£ qu√©t
      setTimeout(() => {
        const orderEntry = document.getElementById('order-entry');
        const orderSl = document.getElementById('order-sl');
        const orderTp = document.getElementById('order-tp');
        const orderLeverage = document.getElementById('order-leverage');

        if (orderEntry) orderEntry.value = parseFloat(signal.entry).toFixed(6);
        if (orderSl) orderSl.value = parseFloat(signal.stopLoss);
        if (orderTp) orderTp.value = parseFloat(signal.takeProfit);
        if (orderLeverage) orderLeverage.value = signal.leverage;

        // Scroll ƒë·∫øn form v√†o l·ªánh
        const orderForm = document.querySelector('.order-entry');
        if (orderForm) {
          orderForm.scrollIntoView({ behavior: 'smooth', block: 'center' });
          orderForm.style.animation = 'pulse 0.5s ease-in-out 2';
        }

        showToast({ type: 'success', title: 'ƒê√£ ƒëi·ªÅn th√¥ng tin', message: `${signal.action} ${signal.symbol}` });
      }, 500);
    }

    // ===================== POSITION TRACKING =====================

    // Load positions from localStorage
    let openPositions = JSON.parse(localStorage.getItem('openPositions') || '[]');
    let closedPositions = JSON.parse(localStorage.getItem('closedPositions') || '[]');
    let currentSignalData = null;

    // Save positions to localStorage
    function savePositions() {
      localStorage.setItem('openPositions', JSON.stringify(openPositions));
      localStorage.setItem('closedPositions', JSON.stringify(closedPositions));
      updateOpenCount();
    }

    // Update open count in tab
    function updateOpenCount() {
      document.getElementById('open-count').textContent = openPositions.length;
    }

    // Open a new position
    function openPosition(type) {
      if (!currentSignalData) {
        showToast({
          type: 'error',
          title: 'L·ªói',
          message: 'Vui l√≤ng ph√¢n t√≠ch coin tr∆∞·ªõc!'
        });
        return;
      }

      // Get elements with null checks
      const marginEl = document.getElementById('order-margin');
      const entryEl = document.getElementById('order-entry');
      const leverageEl = document.getElementById('order-leverage');
      const slEl = document.getElementById('order-sl');
      const tpEl = document.getElementById('order-tp');

      // Check if required elements exist
      if (!marginEl || !entryEl || !leverageEl) {
        showToast({
          type: 'error',
          title: 'L·ªói',
          message: 'Vui l√≤ng ph√¢n t√≠ch symbol tr∆∞·ªõc khi v√†o l·ªánh.'
        });
        return;
      }

      const margin = parseFloat(marginEl.value);
      const entryPrice = parseFloat(entryEl.value);
      const leverage = parseInt(leverageEl.value);
      const sl = slEl ? parseFloat(slEl.value) : 0;
      const tp = tpEl ? parseFloat(tpEl.value) : 0;

      if (!margin || margin <= 0) {
        showToast({
          type: 'error',
          title: 'L·ªói',
          message: 'Vui l√≤ng nh·∫≠p s·ªë USDT margin!'
        });
        return;
      }

      const position = {
        id: Date.now(),
        symbol: currentSignalData.symbol,
        type: type, // 'LONG' or 'SHORT'
        margin: margin,
        leverage: leverage,
        entryPrice: entryPrice,
        stopLoss: sl,
        takeProfit: tp,
        quantity: (margin * leverage) / entryPrice,
        positionSize: margin * leverage,
        openTime: new Date().toISOString(),
        status: 'OPEN'
      };

      openPositions.push(position);
      savePositions();
      renderOpenPositions();

      // Calculate potential loss/profit for display
      let slLoss = 0, tpProfit = 0;
      if (sl && entryPrice && position.quantity) {
        if (type === 'LONG') {
          slLoss = (sl - entryPrice) * position.quantity;
          tpProfit = tp ? (tp - entryPrice) * position.quantity : 0;
        } else {
          slLoss = (entryPrice - sl) * position.quantity;
          tpProfit = tp ? (entryPrice - tp) * position.quantity : 0;
        }
      }

      showToast({
        type: 'success',
        title: `${type === 'LONG' ? '&#128994;' : '&#128308;'} M·ªü l·ªánh ${type} th√†nh c√¥ng!`,
        details: [
          { label: 'Symbol', value: currentSignalData.symbol, class: type.toLowerCase() },
          { label: 'Entry', value: '$' + entryPrice.toLocaleString() },
          { label: 'Margin', value: margin + ' USDT' },
          { label: 'Leverage', value: leverage + 'x' },
          { label: 'Size', value: '$' + position.positionSize.toLocaleString() },
          { label: 'Stop Loss', value: sl ? '$' + sl.toLocaleString() + ` (${slLoss.toFixed(2)}$)` : 'N/A' },
          { label: 'Take Profit', value: tp ? '$' + tp.toLocaleString() + ` (+${tpProfit.toFixed(2)}$)` : 'N/A' }
        ],
        duration: 5000
      });
    }

    // Close a position
    async function closePosition(id, closePrice = null) {
      const index = openPositions.findIndex(p => p.id === id);
      if (index === -1) return;

      const position = openPositions[index];

      // Fetch current price automatically
      if (!closePrice) {
        try {
          let currentPrice;
          if (IS_CLOUDFLARE) {
            const priceData = await fetchBinancePrice(position.symbol);
            currentPrice = priceData.price;
          } else {
            const response = await fetch(`${API_BASE}/api/price/${position.symbol}?market=futures`);
            const data = await response.json();
            if (data.success) currentPrice = data.data.price;
          }

          if (!currentPrice) {
            showToast({
              type: 'error',
              title: 'L·ªói',
              message: 'Kh√¥ng th·ªÉ l·∫•y gi√° hi·ªán t·∫°i. Vui l√≤ng th·ª≠ l·∫°i.',
              duration: 3000
            });
            return;
          }

          // Confirm close with current price
          const result = await showConfirm(
            'ƒê√≥ng l·ªánh ' + position.symbol,
            `Lo·∫°i: <strong style="color: ${position.type === 'LONG' ? '#00ff88' : '#e040fb'}">${position.type}</strong><br>
            Entry: <strong>$${position.entryPrice.toLocaleString()}</strong><br>
            Gi√° hi·ªán t·∫°i: <strong style="color: #ffc107;">$${currentPrice.toLocaleString()}</strong><br><br>
            <small style="color: #888;">L·ªánh s·∫Ω ƒë∆∞·ª£c ƒë√≥ng ngay v·ªõi gi√° th·ªã tr∆∞·ªùng hi·ªán t·∫°i.</small>`,
            true
          );

          if (!result.confirmed) return;
          closePrice = currentPrice;
        } catch (e) {
          showToast({
            type: 'error',
            title: 'L·ªói',
            message: 'Kh√¥ng th·ªÉ l·∫•y gi√°. Vui l√≤ng th·ª≠ l·∫°i.',
            duration: 3000
          });
          return;
        }
      }

      // Calculate P/L
      let pnl;
      if (position.type === 'LONG') {
        pnl = (closePrice - position.entryPrice) * position.quantity;
      } else {
        pnl = (position.entryPrice - closePrice) * position.quantity;
      }

      const pnlPercent = (pnl / position.margin) * 100;

      // Move to closed positions
      const closedPosition = {
        ...position,
        closePrice: closePrice,
        closeTime: new Date().toISOString(),
        pnl: pnl,
        pnlPercent: pnlPercent,
        status: pnl >= 0 ? 'WIN' : 'LOSS',
        closeReason: 'Manual'
      };

      closedPositions.unshift(closedPosition);
      openPositions.splice(index, 1);
      savePositions();
      renderOpenPositions();
      renderClosedPositions();
      updateStats();

      // Show result toast
      showToast({
        type: pnl >= 0 ? 'success' : 'error',
        title: pnl >= 0 ? '&#127881; ƒê√≥ng l·ªánh th·∫Øng!' : '&#128532; ƒê√≥ng l·ªánh thua',
        details: [
          { label: 'Symbol', value: position.symbol },
          { label: 'Lo·∫°i', value: position.type, class: position.type.toLowerCase() },
          { label: 'Entry', value: '$' + position.entryPrice.toLocaleString() },
          { label: 'ƒê√≥ng t·∫°i', value: '$' + closePrice.toLocaleString() },
          { label: 'P/L', value: (pnl >= 0 ? '+' : '') + pnl.toFixed(2) + '$ (' + (pnlPercent >= 0 ? '+' : '') + pnlPercent.toFixed(2) + '%)', class: pnl >= 0 ? 'long' : 'short' }
        ],
        duration: 5000
      });
    }

    // Delete a position (without closing)
    async function deletePosition(id) {
      const index = openPositions.findIndex(p => p.id === id);
      if (index === -1) return;

      const position = openPositions[index];

      const result = await showConfirm(
        'X√≥a l·ªánh',
        `B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a l·ªánh <strong>${position.symbol}</strong> kh·ªèi danh s√°ch?<br><br><small style="color: #888;">L·ªánh s·∫Ω b·ªã x√≥a v√† kh√¥ng ƒë∆∞·ª£c l∆∞u v√†o l·ªãch s·ª≠.</small>`,
        true
      );

      if (!result.confirmed) return;

      openPositions.splice(index, 1);
      savePositions();
      renderOpenPositions();

      showToast({
        type: 'info',
        title: 'ƒê√£ x√≥a l·ªánh',
        message: `L·ªánh ${position.type} ${position.symbol} ƒë√£ ƒë∆∞·ª£c x√≥a kh·ªèi danh s√°ch.`,
        duration: 3000
      });
    }

    // Delete closed position from history
    async function deleteClosedPosition(id) {
      const index = closedPositions.findIndex(p => p.id === id);
      if (index === -1) return;

      const position = closedPositions[index];

      const result = await showConfirm(
        'X√≥a kh·ªèi l·ªãch s·ª≠',
        `X√≥a l·ªánh <strong>${position.symbol}</strong> kh·ªèi l·ªãch s·ª≠ giao d·ªãch?`,
        true
      );

      if (!result.confirmed) return;

      closedPositions.splice(index, 1);
      savePositions();
      renderClosedPositions();
      updateStats();

      showToast({
        type: 'info',
        title: 'ƒê√£ x√≥a',
        message: `ƒê√£ x√≥a l·ªánh ${position.symbol} kh·ªèi l·ªãch s·ª≠.`,
        duration: 3000
      });
    }

    // Clear all history
    async function clearAllHistory() {
      if (closedPositions.length === 0) {
        showToast({
          type: 'info',
          title: 'Th√¥ng b√°o',
          message: 'Kh√¥ng c√≥ l·ªãch s·ª≠ ƒë·ªÉ x√≥a.',
          duration: 2000
        });
        return;
      }

      const result = await showConfirm(
        'üóëÔ∏è X√≥a to√†n b·ªô l·ªãch s·ª≠',
        `B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a <strong style="color: #ff5252;">${closedPositions.length}</strong> l·ªánh trong l·ªãch s·ª≠?<br><br><small style="color: #888;">H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c!</small>`,
        true
      );

      if (!result.confirmed) return;

      const count = closedPositions.length;
      closedPositions = [];
      savePositions();
      renderClosedPositions();
      updateStats();

      showToast({
        type: 'success',
        title: 'üóëÔ∏è ƒê√£ x√≥a!',
        message: `ƒê√£ x√≥a ${count} l·ªánh kh·ªèi l·ªãch s·ª≠.`,
        duration: 3000
      });
    }

    // Copy position info to clipboard
    function copyPosition(id) {
      const position = openPositions.find(p => p.id === id);
      if (!position) return;

      // Calculate SL loss and TP profit
      let slLoss = 0, tpProfit = 0;
      if (position.stopLoss && position.entryPrice && position.quantity) {
        if (position.type === 'LONG') {
          slLoss = (position.stopLoss - position.entryPrice) * position.quantity;
          tpProfit = position.takeProfit ? (position.takeProfit - position.entryPrice) * position.quantity : 0;
        } else {
          slLoss = (position.entryPrice - position.stopLoss) * position.quantity;
          tpProfit = position.takeProfit ? (position.entryPrice - position.takeProfit) * position.quantity : 0;
        }
      }

      const text = `üìä ${position.symbol} - ${position.type}
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üí∞ Margin: ${position.margin.toFixed(2)} USDT
‚ö° Leverage: ${position.leverage}x
üìà Size: $${position.positionSize.toLocaleString()}
üéØ Entry: $${position.entryPrice.toLocaleString()}
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üõë Stop Loss: $${position.stopLoss ? position.stopLoss.toLocaleString() : 'N/A'}
‚úÖ Take Profit: $${position.takeProfit ? position.takeProfit.toLocaleString() : 'N/A'}`;

      navigator.clipboard.writeText(text).then(() => {
        showToast({
          type: 'success',
          title: 'ƒê√£ copy!',
          message: `Th√¥ng tin l·ªánh ${position.symbol} ƒë√£ ƒë∆∞·ª£c copy v√†o clipboard.`,
          duration: 2000
        });
      }).catch(err => {
        showToast({
          type: 'error',
          title: 'L·ªói',
          message: 'Kh√¥ng th·ªÉ copy. Vui l√≤ng th·ª≠ l·∫°i.',
          duration: 3000
        });
      });
    }

    // Edit SL/TP for open position
    async function editPositionSLTP(id) {
      const position = openPositions.find(p => p.id === id);
      if (!position) return;

      // Create custom modal for editing SL/TP
      return new Promise((resolve) => {
        const overlay = document.createElement('div');
        overlay.className = 'modal-overlay';
        overlay.innerHTML = `
          <div class="modal" style="max-width: 400px;">
            <div class="modal-header">
              <span class="modal-icon">‚öôÔ∏è</span>
              <h3>Ch·ªânh s·ª≠a SL/TP</h3>
            </div>
            <div class="modal-body">
              <p style="margin-bottom: 15px;">
                <strong>${position.symbol}</strong> -
                <span style="color: ${position.type === 'LONG' ? '#00ff88' : '#e040fb'}">${position.type}</span>
                <br><small style="color: #888;">Entry: $${position.entryPrice.toLocaleString()}</small>
              </p>
              <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em;">üõë Stop Loss</label>
                <input type="number" id="edit-sl" value="${position.stopLoss || ''}" step="0.0001"
                  style="width: 100%; padding: 12px; background: rgba(255,82,82,0.1); border: 1px solid rgba(255,82,82,0.3); border-radius: 8px; color: #ff5252; font-size: 1em;"
                  placeholder="Nh·∫≠p gi√° Stop Loss">
              </div>
              <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em;">‚úÖ Take Profit</label>
                <input type="number" id="edit-tp" value="${position.takeProfit || ''}" step="0.0001"
                  style="width: 100%; padding: 12px; background: rgba(0,255,136,0.1); border: 1px solid rgba(0,255,136,0.3); border-radius: 8px; color: #00ff88; font-size: 1em;"
                  placeholder="Nh·∫≠p gi√° Take Profit">
              </div>
              <div id="edit-sltp-preview" style="background: rgba(255,255,255,0.05); padding: 10px; border-radius: 8px; font-size: 0.9em; color: #888;"></div>
            </div>
            <div class="modal-actions">
              <button class="modal-btn modal-btn-cancel" id="edit-cancel">H·ªßy</button>
              <button class="modal-btn modal-btn-confirm" id="edit-save">üíæ L∆∞u thay ƒë·ªïi</button>
            </div>
          </div>
        `;

        document.body.appendChild(overlay);

        const slInput = overlay.querySelector('#edit-sl');
        const tpInput = overlay.querySelector('#edit-tp');
        const previewDiv = overlay.querySelector('#edit-sltp-preview');

        // Update preview when inputs change
        const updatePreview = () => {
          const sl = parseFloat(slInput.value);
          const tp = parseFloat(tpInput.value);
          let slLoss = 0, tpProfit = 0;

          if (sl && position.quantity) {
            if (position.type === 'LONG') {
              slLoss = (sl - position.entryPrice) * position.quantity;
            } else {
              slLoss = (position.entryPrice - sl) * position.quantity;
            }
          }

          if (tp && position.quantity) {
            if (position.type === 'LONG') {
              tpProfit = (tp - position.entryPrice) * position.quantity;
            } else {
              tpProfit = (position.entryPrice - tp) * position.quantity;
            }
          }

          previewDiv.innerHTML = `
            <div style="display: flex; justify-content: space-between;">
              <span>L·ªó n·∫øu SL:</span>
              <span style="color: #ff5252;">${slLoss ? slLoss.toFixed(2) + '$' : 'N/A'}</span>
            </div>
            <div style="display: flex; justify-content: space-between; margin-top: 5px;">
              <span>L√£i n·∫øu TP:</span>
              <span style="color: #00ff88;">${tpProfit ? '+' + tpProfit.toFixed(2) + '$' : 'N/A'}</span>
            </div>
          `;
        };

        slInput.addEventListener('input', updatePreview);
        tpInput.addEventListener('input', updatePreview);
        updatePreview();

        // Focus SL input
        setTimeout(() => slInput.focus(), 100);

        const closeModal = (saved) => {
          overlay.style.animation = 'fadeOut 0.2s ease-out forwards';
          setTimeout(() => {
            overlay.remove();
            resolve(saved);
          }, 200);
        };

        overlay.querySelector('#edit-cancel').onclick = () => closeModal(false);
        overlay.querySelector('#edit-save').onclick = () => {
          const newSL = parseFloat(slInput.value) || null;
          const newTP = parseFloat(tpInput.value) || null;

          // Update position
          position.stopLoss = newSL;
          position.takeProfit = newTP;
          savePositions();
          renderOpenPositions();

          showToast({
            type: 'success',
            title: '‚úÖ ƒê√£ c·∫≠p nh·∫≠t!',
            details: [
              { label: 'Symbol', value: position.symbol },
              { label: 'Stop Loss', value: newSL ? '$' + newSL.toLocaleString() : 'Kh√¥ng ƒë·∫∑t', class: 'short' },
              { label: 'Take Profit', value: newTP ? '$' + newTP.toLocaleString() : 'Kh√¥ng ƒë·∫∑t', class: 'long' }
            ],
            duration: 3000
          });

          closeModal(true);
        };

        // Close on overlay click
        overlay.onclick = (e) => {
          if (e.target === overlay) closeModal(false);
        };

        // Close on Escape
        const handleEscape = (e) => {
          if (e.key === 'Escape') {
            document.removeEventListener('keydown', handleEscape);
            closeModal(false);
          }
        };
        document.addEventListener('keydown', handleEscape);
      });
    }

    // Render open positions
    function renderOpenPositions() {
      const container = document.getElementById('open-positions');

      if (openPositions.length === 0) {
        container.innerHTML = '<div class="no-positions">Ch∆∞a c√≥ l·ªánh n√†o ƒëang m·ªü</div>';
        document.getElementById('total-open').textContent = '0';
        document.getElementById('total-unrealized-pnl').textContent = '$0.00';
        document.getElementById('total-margin').textContent = '$0.00';
        return;
      }

      container.innerHTML = openPositions.map(p => {
        // Calculate estimated SL loss and TP profit
        let slLoss = 0, tpProfit = 0;
        if (p.stopLoss && p.entryPrice && p.quantity) {
          if (p.type === 'LONG') {
            slLoss = (p.stopLoss - p.entryPrice) * p.quantity;
            tpProfit = p.takeProfit ? (p.takeProfit - p.entryPrice) * p.quantity : 0;
          } else {
            slLoss = (p.entryPrice - p.stopLoss) * p.quantity;
            tpProfit = p.takeProfit ? (p.entryPrice - p.takeProfit) * p.quantity : 0;
          }
        }

        return `
        <div class="position-card ${p.type.toLowerCase()}" data-symbol="${p.symbol}" data-id="${p.id}">
          <div class="position-header">
            <div>
              <span class="position-symbol">${p.symbol}</span>
              <span class="signal-badge signal-${p.type.toLowerCase()}" style="font-size: 0.8em; padding: 3px 10px;">${p.type}</span>
            </div>
            <div class="position-pnl" id="pnl-${p.id}">ƒêang t·∫£i...</div>
          </div>
          <div class="position-details">
            <div>
              <span class="label">Margin</span>
              <span class="value">${p.margin.toFixed(2)} USDT</span>
            </div>
            <div>
              <span class="label">Leverage</span>
              <span class="value">${p.leverage}x</span>
            </div>
            <div>
              <span class="label">Entry</span>
              <span class="value">$${p.entryPrice.toLocaleString()}</span>
            </div>
            <div>
              <span class="label">Gi√° hi·ªán t·∫°i</span>
              <span class="value" id="current-price-${p.id}">...</span>
            </div>
            <div>
              <span class="label">Stop Loss</span>
              <span class="value stop-loss">$${p.stopLoss ? p.stopLoss.toLocaleString() : 'N/A'} ${slLoss ? `<span style="font-size:0.85em">(${slLoss.toFixed(2)}$)</span>` : ''}</span>
            </div>
            <div>
              <span class="label">Take Profit</span>
              <span class="value take-profit">$${p.takeProfit ? p.takeProfit.toLocaleString() : 'N/A'} ${tpProfit ? `<span style="font-size:0.85em">(+${tpProfit.toFixed(2)}$)</span>` : ''}</span>
            </div>
          </div>
          <div class="position-actions">
            <button class="btn-copy" onclick="copyPosition(${p.id})">üìã Copy</button>
            <button class="btn-edit" onclick="editPositionSLTP(${p.id})" style="background: linear-gradient(135deg, #ffc107 0%, #ff9800 100%);">‚öôÔ∏è SL/TP</button>
            <button class="btn-close-profit" onclick="closePosition(${p.id})">ƒê√≥ng l·ªánh</button>
            <button class="btn-delete" onclick="deletePosition(${p.id})">X√≥a</button>
          </div>
          ${isAdminMode ? `<div class="position-actions" style="margin-top: 5px;">
            <button onclick="closePositionOnBinance(${p.id})" style="flex: 1; background: linear-gradient(135deg, #f0b90b 0%, #d4a40a 100%); border: none; color: #000; padding: 10px 15px; border-radius: 8px; cursor: pointer; font-weight: bold;">‚ö° Dong lenh tren Binance</button>
          </div>` : ''}
        </div>
      `}).join('');

      // Update P/L for all positions
      updateAllPositionsPnL();
    }

    // Render closed positions
    function renderClosedPositions() {
      const container = document.getElementById('closed-positions');

      if (closedPositions.length === 0) {
        container.innerHTML = '<div class="no-positions">Ch∆∞a c√≥ l·ªãch s·ª≠ giao d·ªãch</div>';
        return;
      }

      container.innerHTML = closedPositions.map(p => {
        // Calculate estimated SL loss and TP profit (from original position)
        let slLoss = 0, tpProfit = 0;
        if (p.stopLoss && p.entryPrice && p.quantity) {
          if (p.type === 'LONG') {
            slLoss = (p.stopLoss - p.entryPrice) * p.quantity;
            tpProfit = p.takeProfit ? (p.takeProfit - p.entryPrice) * p.quantity : 0;
          } else {
            slLoss = (p.entryPrice - p.stopLoss) * p.quantity;
            tpProfit = p.takeProfit ? (p.entryPrice - p.takeProfit) * p.quantity : 0;
          }
        }

        return `
        <div class="position-card ${p.type.toLowerCase()} ${p.pnl >= 0 ? 'profit' : 'loss'}">
          <div class="position-header">
            <div>
              <span class="position-symbol">${p.symbol}</span>
              <span class="signal-badge signal-${p.type.toLowerCase()}" style="font-size: 0.8em; padding: 3px 10px;">${p.type}</span>
              <span style="color: ${p.pnl >= 0 ? '#00ff88' : '#ff5252'}; font-size: 0.85em; margin-left: 10px;">${p.status}</span>
              ${p.closeReason ? `<span style="background: ${p.closeReason === 'TP' ? 'rgba(0,255,136,0.2)' : p.closeReason === 'SL' ? 'rgba(255,82,82,0.2)' : 'rgba(255,193,7,0.2)'}; color: ${p.closeReason === 'TP' ? '#00ff88' : p.closeReason === 'SL' ? '#ff5252' : '#ffc107'}; padding: 2px 8px; border-radius: 4px; font-size: 0.75em; margin-left: 8px;">${p.closeReason === 'TP' ? 'üéØ Auto TP' : p.closeReason === 'SL' ? 'üõë Auto SL' : '‚úã Manual'}</span>` : ''}
            </div>
            <div class="position-pnl ${p.pnl >= 0 ? 'profit' : 'loss'}">
              ${p.pnl >= 0 ? '+' : ''}$${p.pnl.toFixed(2)} (${p.pnlPercent >= 0 ? '+' : ''}${p.pnlPercent.toFixed(1)}%)
            </div>
          </div>
          <div class="position-details">
            <div>
              <span class="label">Margin</span>
              <span class="value">${p.margin.toFixed(2)} USDT</span>
            </div>
            <div>
              <span class="label">Leverage</span>
              <span class="value">${p.leverage}x</span>
            </div>
            <div>
              <span class="label">Entry</span>
              <span class="value">$${p.entryPrice.toLocaleString()}</span>
            </div>
            <div>
              <span class="label">ƒê√≥ng t·∫°i</span>
              <span class="value">$${p.closePrice.toLocaleString()}</span>
            </div>
            <div>
              <span class="label">Stop Loss</span>
              <span class="value stop-loss">$${p.stopLoss ? p.stopLoss.toLocaleString() : 'N/A'} ${slLoss ? `<span style="font-size:0.85em">(${slLoss.toFixed(2)}$)</span>` : ''}</span>
            </div>
            <div>
              <span class="label">Take Profit</span>
              <span class="value take-profit">$${p.takeProfit ? p.takeProfit.toLocaleString() : 'N/A'} ${tpProfit ? `<span style="font-size:0.85em">(+${tpProfit.toFixed(2)}$)</span>` : ''}</span>
            </div>
          </div>
          <div class="position-actions">
            <button class="btn-delete" onclick="deleteClosedPosition(${p.id})">X√≥a kh·ªèi l·ªãch s·ª≠</button>
          </div>
        </div>
      `}).join('');
    }

    // Update stats
    function updateStats() {
      const totalClosed = closedPositions.length;
      const totalPnL = closedPositions.reduce((sum, p) => sum + p.pnl, 0);
      const wins = closedPositions.filter(p => p.pnl >= 0).length;
      const losses = closedPositions.filter(p => p.pnl < 0).length;
      const winRate = totalClosed > 0 ? (wins / totalClosed * 100).toFixed(1) : 0;

      document.getElementById('total-closed').textContent = totalClosed;
      document.getElementById('total-pnl').textContent = `${totalPnL >= 0 ? '+' : ''}$${totalPnL.toFixed(2)}`;
      document.getElementById('total-pnl').style.color = totalPnL >= 0 ? '#00ff88' : '#ff5252';
      document.getElementById('win-rate').textContent = `${winRate}%`;
      document.getElementById('win-rate').style.color = winRate >= 50 ? '#00ff88' : '#ff5252';
      document.getElementById('win-loss').textContent = `${wins} / ${losses}`;
    }

    // Update P/L for all open positions
    // Auto close position when hit SL/TP
    async function autoClosePosition(position, closePrice, reason) {
      const index = openPositions.findIndex(p => p.id === position.id);
      if (index === -1) return;

      // Calculate P/L
      let pnl;
      if (position.type === 'LONG') {
        pnl = (closePrice - position.entryPrice) * position.quantity;
      } else {
        pnl = (position.entryPrice - closePrice) * position.quantity;
      }

      const pnlPercent = (pnl / position.margin) * 100;

      // Move to closed positions
      const closedPosition = {
        ...position,
        closePrice: closePrice,
        closeTime: new Date().toISOString(),
        pnl: pnl,
        pnlPercent: pnlPercent,
        status: pnl >= 0 ? 'WIN' : 'LOSS',
        closeReason: reason // 'SL' or 'TP'
      };

      closedPositions.unshift(closedPosition);
      openPositions.splice(index, 1);
      savePositions();
      renderOpenPositions();
      renderClosedPositions();
      updateStats();

      // Show auto-close toast
      const isTP = reason === 'TP';
      showToast({
        type: isTP ? 'success' : 'error',
        title: isTP ? 'üéØ Take Profit ƒë√£ ch·∫°m!' : 'üõë Stop Loss ƒë√£ ch·∫°m!',
        details: [
          { label: 'Symbol', value: position.symbol },
          { label: 'Lo·∫°i', value: position.type, class: position.type.toLowerCase() },
          { label: 'Entry', value: '$' + position.entryPrice.toLocaleString() },
          { label: isTP ? 'TP' : 'SL', value: '$' + closePrice.toLocaleString() },
          { label: 'P/L', value: (pnl >= 0 ? '+' : '') + pnl.toFixed(2) + '$ (' + (pnlPercent >= 0 ? '+' : '') + pnlPercent.toFixed(2) + '%)', class: pnl >= 0 ? 'long' : 'short' }
        ],
        duration: 8000
      });

      // Play sound notification
      try {
        const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1jZWlrd3x/g4aGhYOBgX99e3p5eXl5eXl6e3x+gIKEhoeIiIiHhYOBf3x6eHZ1dHR0dHV2eHl8f4GDhoeIiYmJiIeGhIJ/fXp4dnRzc3NzdHV3eXx+gYOFh4iJiYmJiIeGhIJ/fXp4dnRzc3NzdHV3eXt+gYOFh4iJiYmJiIeGhIJ/fXp4dnRzc3Nz');
        audio.volume = 0.5;
        audio.play().catch(() => {});
      } catch (e) {}
    }

    async function updateAllPositionsPnL() {
      let totalUnrealizedPnL = 0;
      let totalMargin = 0;
      const positionsToAutoClose = []; // Collect positions to auto close

      for (const position of openPositions) {
        try {
          let currentPrice;

          if (IS_CLOUDFLARE) {
            // Fetch price directly from Binance for Cloudflare
            const priceData = await fetchBinancePrice(position.symbol);
            currentPrice = priceData.price;
          } else {
            const response = await fetch(`${API_BASE}/api/price/${position.symbol}?market=futures`);
            const data = await response.json();
            if (!data.success) continue;
            currentPrice = data.data.price;
          }

          if (currentPrice) {
            // Check SL/TP hit
            const sl = position.stopLoss ? parseFloat(position.stopLoss) : null;
            const tp = position.takeProfit ? parseFloat(position.takeProfit) : null;

            if (position.type === 'LONG') {
              // LONG: SL khi gi√° xu·ªëng d∆∞·ªõi SL, TP khi gi√° l√™n tr√™n TP
              if (sl && currentPrice <= sl) {
                positionsToAutoClose.push({ position, closePrice: sl, reason: 'SL' });
                continue;
              }
              if (tp && currentPrice >= tp) {
                positionsToAutoClose.push({ position, closePrice: tp, reason: 'TP' });
                continue;
              }
            } else {
              // SHORT: SL khi gi√° l√™n tr√™n SL, TP khi gi√° xu·ªëng d∆∞·ªõi TP
              if (sl && currentPrice >= sl) {
                positionsToAutoClose.push({ position, closePrice: sl, reason: 'SL' });
                continue;
              }
              if (tp && currentPrice <= tp) {
                positionsToAutoClose.push({ position, closePrice: tp, reason: 'TP' });
                continue;
              }
            }

            let pnl;

            if (position.type === 'LONG') {
              pnl = (currentPrice - position.entryPrice) * position.quantity;
            } else {
              pnl = (position.entryPrice - currentPrice) * position.quantity;
            }

            const pnlPercent = (pnl / position.margin) * 100;
            totalUnrealizedPnL += pnl;
            totalMargin += position.margin;

            // Update UI
            const pnlEl = document.getElementById(`pnl-${position.id}`);
            const priceEl = document.getElementById(`current-price-${position.id}`);

            if (pnlEl) {
              pnlEl.textContent = `${pnl >= 0 ? '+' : ''}$${pnl.toFixed(2)} (${pnlPercent >= 0 ? '+' : ''}${pnlPercent.toFixed(1)}%)`;
              pnlEl.className = `position-pnl ${pnl >= 0 ? 'profit' : 'loss'}`;
            }

            if (priceEl) {
              priceEl.textContent = `$${currentPrice.toLocaleString()}`;
            }
          }
        } catch (e) {
          console.error(`Error fetching price for ${position.symbol}:`, e);
        }
      }

      // Auto close positions that hit SL/TP (do this after the loop to avoid modifying array while iterating)
      for (const item of positionsToAutoClose) {
        await autoClosePosition(item.position, item.closePrice, item.reason);
      }

      // Update totals
      document.getElementById('total-open').textContent = openPositions.length;
      document.getElementById('total-unrealized-pnl').textContent = `${totalUnrealizedPnL >= 0 ? '+' : ''}$${totalUnrealizedPnL.toFixed(2)}`;
      document.getElementById('total-unrealized-pnl').style.color = totalUnrealizedPnL >= 0 ? '#00ff88' : '#ff5252';
      document.getElementById('total-margin').textContent = `$${totalMargin.toFixed(2)}`;
    }

    // Auto-refresh price and P/L
    setInterval(async () => {
      const symbol = document.getElementById('symbol').value;
      try {
        let price;

        if (IS_CLOUDFLARE) {
          const priceData = await fetchBinancePrice(symbol);
          price = priceData.price;
        } else {
          const response = await fetch(`${API_BASE}/api/price/${symbol}`);
          const data = await response.json();
          if (data.success) price = data.data.price;
        }

        if (price) {
          const priceEl = document.querySelector('.price');
          if (priceEl) {
            priceEl.textContent = '$' + price.toLocaleString();
          }
        }
      } catch (e) {}

      // Update open positions P/L
      if (openPositions.length > 0) {
        updateAllPositionsPnL();
      }
    }, 5000); // Update every 5 seconds

    // Initialize
    function initPositions() {
      updateOpenCount();
      renderOpenPositions();
      renderClosedPositions();
      updateStats();
    }

    // Initial analysis
    analyzeSignal();
    initPositions();

    // ===================== CHART MODAL FUNCTIONS =====================
    function openChart(symbol) {
      const cleanSymbol = symbol.replace('USDT', '');
      const chartSymbol = `BINANCE:${cleanSymbol}USDT.P`; // .P for Perpetual Futures

      document.getElementById('chart-modal-title').textContent = `${cleanSymbol}/USDT - Binance Futures`;

      // TradingView Widget URL
      const widgetUrl = `https://s.tradingview.com/widgetembed/?frameElementId=tradingview_chart&symbol=${chartSymbol}&interval=60&hidesidetoolbar=0&symboledit=1&saveimage=1&toolbarbg=1a1a2e&studies=%5B%5D&theme=dark&style=1&timezone=Asia%2FHo_Chi_Minh&studies_overrides=%7B%7D&overrides=%7B%7D&enabled_features=%5B%5D&disabled_features=%5B%5D&locale=vi_VN&utm_source=&utm_medium=widget&utm_campaign=chart&utm_term=${chartSymbol}`;

      document.getElementById('tradingview-chart').src = widgetUrl;
      document.getElementById('chart-modal-overlay').classList.add('active');
      document.body.style.overflow = 'hidden';
    }

    function closeChart() {
      document.getElementById('chart-modal-overlay').classList.remove('active');
      document.getElementById('tradingview-chart').src = '';
      document.body.style.overflow = '';
    }

    // Chart modal events - s·∫Ω ƒë∆∞·ª£c kh·ªüi t·∫°o trong DOMContentLoaded
    function initChartModal() {
      const chartOverlay = document.getElementById('chart-modal-overlay');
      if (chartOverlay) {
        chartOverlay.addEventListener('click', function(e) {
          if (e.target === this) {
            closeChart();
          }
        });
      }

      // Close chart modal on Escape key
      document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
          closeChart();
        }
      });
    }
  </script>

  <!-- Chart Modal -->
  <div id="chart-modal-overlay" class="chart-modal-overlay">
    <div class="chart-modal">
      <div class="chart-modal-header">
        <div class="chart-modal-title">
          <span id="chart-modal-title">BTC/USDT - Binance Futures</span>
        </div>
        <button class="chart-modal-close" onclick="closeChart()">&times;</button>
      </div>
      <div class="chart-modal-body">
        <iframe id="tradingview-chart" src="" allowfullscreen></iframe>
      </div>
    </div>
  </div>

  <!-- Binance API Config Button (Admin Only) -->
  <button class="api-config-btn admin-only" id="api-config-btn" onclick="openApiConfig()" title="Cau hinh Binance API" style="display: none;">
    <span id="api-icon">&#128274;</span>
  </button>

  <!-- Binance API Config Modal -->
  <div id="api-modal-overlay" class="api-modal-overlay" onclick="closeApiConfig(event)">
    <div class="api-modal" onclick="event.stopPropagation()">
      <button class="api-modal-close" onclick="closeApiConfig()">&times;</button>
      <h3><span>&#128274;</span> Binance API Config</h3>
      <div class="subtitle">Ket noi tai khoan Binance de giao dich truc tiep</div>

      <div class="api-warning">
        <strong>Luu y bao mat:</strong>
        API Key duoc luu LOCAL tren trinh duyet cua ban, KHONG gui len server. Chi cap quyen FUTURES, khong cap quyen rut tien.
      </div>

      <div id="api-status-display" class="api-status disconnected">
        <span>&#9679;</span> Chua ket noi
      </div>

      <div id="api-balance-display" class="api-balance" style="display: none;">
        <div class="api-balance-row">
          <span class="api-balance-label">Tong so du:</span>
          <span class="api-balance-value" id="api-total-balance">0.00 USDT</span>
        </div>
        <div class="api-balance-row">
          <span class="api-balance-label">Kha dung:</span>
          <span class="api-balance-value" id="api-available-balance">0.00 USDT</span>
        </div>
        <div class="api-balance-row">
          <span class="api-balance-label">PnL chua thuc hien:</span>
          <span class="api-balance-value" id="api-unrealized-pnl">0.00 USDT</span>
        </div>
      </div>

      <div class="api-input-group">
        <label>API Key</label>
        <input type="text" id="api-key-input" placeholder="Nhap Binance API Key">
      </div>

      <div class="api-input-group">
        <label>Secret Key</label>
        <input type="password" id="api-secret-input" placeholder="Nhap Binance Secret Key">
      </div>

      <div class="api-input-group">
        <label style="display: flex; align-items: center; gap: 10px;">
          <input type="checkbox" id="api-testnet-checkbox" style="width: auto;">
          Su dung Testnet <span class="testnet-badge">Demo</span>
        </label>
      </div>

      <div class="api-buttons">
        <button class="btn-api-test" onclick="testApiConnection()">Test ket noi</button>
        <button class="btn-api-save" onclick="saveApiConfig()">Luu API</button>
      </div>
      <div class="api-buttons" style="margin-top: 10px;">
        <button class="btn-api-clear" onclick="clearApiConfig()">Xoa API</button>
      </div>
    </div>
  </div>

  <!-- Donate Float Button -->
  <div class="donate-container" onclick="openDonate()">
    <div class="donate-label">Ung ho tac gia</div>
    <button class="donate-float-btn" title="Mua tac gia ly cafe">
      <span>&#9749;</span>
      <span class="donate-badge">NEW</span>
    </button>
  </div>

  <!-- Donate Modal -->
  <div id="donate-modal-overlay" class="donate-modal-overlay" onclick="closeDonate(event)">
    <div class="donate-modal" onclick="event.stopPropagation()">
      <button class="donate-modal-close" onclick="closeDonate()">&times;</button>
      <div class="donate-title">Mua tac gia ly cafe</div>
      <div class="donate-subtitle">Trade co loi? Ung ho de phat trien them tinh nang moi nhe!</div>
      <div class="donate-qr-container">
        <img src="donate-qr.jpg" alt="QR Donate Techcombank">
      </div>
      <div class="donate-info">
        <strong>Techcombank</strong><br>
        Quet ma QR bang app ngan hang bat ky
      </div>
      <div class="donate-thanks">
        Cam on ban da ung ho! Chuc ban trade thanh cong!
      </div>
    </div>
  </div>

  <script>
    // Donate modal functions
    function openDonate() {
      document.getElementById('donate-modal-overlay').classList.add('active');
    }

    function closeDonate(event) {
      if (!event || event.target.id === 'donate-modal-overlay' || event.target.classList.contains('donate-modal-close')) {
        document.getElementById('donate-modal-overlay').classList.remove('active');
      }
    }

    // Close donate modal on Escape key
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape') {
        closeDonate();
        closeApiConfig();
      }
    });
  </script>

  <script>
    // Show/Hide Binance features based on admin mode
    function showBinanceFeatures() {
      const elements = document.querySelectorAll('.admin-only');
      elements.forEach(el => {
        el.style.display = isAdminMode ? '' : 'none';
      });
    }

    // ===================== BINANCE TRADING SERVICE (Client-side) =====================

    const BINANCE_LIVE_URL = 'https://fapi.binance.com';
    const BINANCE_TESTNET_URL = 'https://testnet.binancefuture.com';

    // API Config state
    let binanceApiConfig = {
      apiKey: '',
      secretKey: '',
      testnet: false,
      connected: false,
      balance: null
    };

    // Load saved API config on page load
    function loadApiConfig() {
      const saved = localStorage.getItem('binance_api_config');
      if (saved) {
        try {
          const config = JSON.parse(saved);
          binanceApiConfig.apiKey = config.apiKey || '';
          binanceApiConfig.secretKey = config.secretKey || '';
          binanceApiConfig.testnet = config.testnet || false;

          // Fill form (with null checks)
          const apiKeyEl = document.getElementById('api-key-input');
          const apiSecretEl = document.getElementById('api-secret-input');
          const testnetEl = document.getElementById('api-testnet-checkbox');
          if (apiKeyEl) apiKeyEl.value = binanceApiConfig.apiKey;
          if (apiSecretEl) apiSecretEl.value = binanceApiConfig.secretKey;
          if (testnetEl) testnetEl.checked = binanceApiConfig.testnet;

          // Auto test connection if keys exist
          if (binanceApiConfig.apiKey && binanceApiConfig.secretKey) {
            testApiConnection();
          }
        } catch (e) {
          console.error('Error loading API config:', e);
        }
      }
    }

    // Open API config modal
    function openApiConfig() {
      document.getElementById('api-modal-overlay').classList.add('active');
      loadApiConfig();
    }

    // Close API config modal
    function closeApiConfig(event) {
      if (!event || event.target.id === 'api-modal-overlay' || event.target.classList.contains('api-modal-close')) {
        document.getElementById('api-modal-overlay').classList.remove('active');
      }
    }

    // Create HMAC SHA256 signature
    async function createSignature(queryString, secretKey) {
      const encoder = new TextEncoder();
      const keyData = encoder.encode(secretKey);
      const messageData = encoder.encode(queryString);

      const cryptoKey = await crypto.subtle.importKey(
        'raw',
        keyData,
        { name: 'HMAC', hash: 'SHA-256' },
        false,
        ['sign']
      );

      const signature = await crypto.subtle.sign('HMAC', cryptoKey, messageData);
      return Array.from(new Uint8Array(signature))
        .map(b => b.toString(16).padStart(2, '0'))
        .join('');
    }

    // Send signed request to Binance
    async function binanceSignedRequest(method, endpoint, params = {}) {
      const baseUrl = binanceApiConfig.testnet ? BINANCE_TESTNET_URL : BINANCE_LIVE_URL;
      const timestamp = Date.now();
      const queryParams = { ...params, timestamp };

      const queryString = Object.keys(queryParams)
        .map(key => `${key}=${queryParams[key]}`)
        .join('&');

      const signature = await createSignature(queryString, binanceApiConfig.secretKey);
      const url = `${baseUrl}${endpoint}?${queryString}&signature=${signature}`;

      const response = await fetch(url, {
        method,
        headers: {
          'X-MBX-APIKEY': binanceApiConfig.apiKey
        }
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.msg || `Binance API error: ${response.status}`);
      }

      return data;
    }

    // Test API connection
    async function testApiConnection() {
      const apiKey = document.getElementById('api-key-input').value.trim();
      const secretKey = document.getElementById('api-secret-input').value.trim();
      const testnet = document.getElementById('api-testnet-checkbox').checked;

      if (!apiKey || !secretKey) {
        showToast({ type: 'error', title: 'Loi', message: 'Vui long nhap API Key va Secret Key' });
        return;
      }

      // Temporarily set config for testing
      binanceApiConfig.apiKey = apiKey;
      binanceApiConfig.secretKey = secretKey;
      binanceApiConfig.testnet = testnet;

      const statusDisplay = document.getElementById('api-status-display');
      const balanceDisplay = document.getElementById('api-balance-display');

      statusDisplay.innerHTML = '<span>&#8987;</span> Dang ket noi...';
      statusDisplay.className = 'api-status disconnected';

      try {
        // Get account info
        const account = await binanceSignedRequest('GET', '/fapi/v2/account');

        // Find USDT balance
        const usdtAsset = account.assets.find(a => a.asset === 'USDT');
        const totalBalance = parseFloat(usdtAsset?.walletBalance || 0);
        const availableBalance = parseFloat(usdtAsset?.availableBalance || 0);
        const unrealizedPnl = parseFloat(usdtAsset?.unrealizedProfit || 0);

        binanceApiConfig.connected = true;
        binanceApiConfig.balance = { totalBalance, availableBalance, unrealizedPnl };

        // Update UI
        statusDisplay.innerHTML = '<span>&#9679;</span> Da ket noi' + (testnet ? ' <span class="testnet-badge">Testnet</span>' : '');
        statusDisplay.className = 'api-status connected';

        document.getElementById('api-total-balance').textContent = totalBalance.toFixed(2) + ' USDT';
        document.getElementById('api-available-balance').textContent = availableBalance.toFixed(2) + ' USDT';
        document.getElementById('api-unrealized-pnl').textContent = (unrealizedPnl >= 0 ? '+' : '') + unrealizedPnl.toFixed(2) + ' USDT';
        document.getElementById('api-unrealized-pnl').style.color = unrealizedPnl >= 0 ? '#00ff88' : '#ff5252';
        balanceDisplay.style.display = 'block';

        // Update button state
        document.getElementById('api-config-btn').classList.add('connected');
        document.getElementById('api-icon').innerHTML = '&#9989;';

        showToast({ type: 'success', title: 'Ket noi thanh cong!', message: `So du: ${totalBalance.toFixed(2)} USDT` });

      } catch (error) {
        binanceApiConfig.connected = false;
        binanceApiConfig.balance = null;

        statusDisplay.innerHTML = '<span>&#9679;</span> Ket noi that bai: ' + error.message;
        statusDisplay.className = 'api-status disconnected';
        balanceDisplay.style.display = 'none';

        document.getElementById('api-config-btn').classList.remove('connected');
        document.getElementById('api-icon').innerHTML = '&#128274;';

        showToast({ type: 'error', title: 'Ket noi that bai', message: error.message });
      }
    }

    // Save API config
    function saveApiConfig() {
      const apiKey = document.getElementById('api-key-input').value.trim();
      const secretKey = document.getElementById('api-secret-input').value.trim();
      const testnet = document.getElementById('api-testnet-checkbox').checked;

      if (!apiKey || !secretKey) {
        showToast({ type: 'error', title: 'Loi', message: 'Vui long nhap API Key va Secret Key' });
        return;
      }

      localStorage.setItem('binance_api_config', JSON.stringify({
        apiKey,
        secretKey,
        testnet
      }));

      binanceApiConfig.apiKey = apiKey;
      binanceApiConfig.secretKey = secretKey;
      binanceApiConfig.testnet = testnet;

      showToast({ type: 'success', title: 'Da luu!', message: 'API Key da duoc luu vao trinh duyet' });
      closeApiConfig();
    }

    // Clear API config
    function clearApiConfig() {
      localStorage.removeItem('binance_api_config');

      binanceApiConfig = {
        apiKey: '',
        secretKey: '',
        testnet: false,
        connected: false,
        balance: null
      };

      // Clear form with null checks
      const setVal = (id, val) => { const e = document.getElementById(id); if (e) e.value = val; };
      const setHtml = (id, html) => { const e = document.getElementById(id); if (e) e.innerHTML = html; };
      const setStyle = (id, prop, val) => { const e = document.getElementById(id); if (e) e.style[prop] = val; };

      setVal('api-key-input', '');
      setVal('api-secret-input', '');
      const testnetEl = document.getElementById('api-testnet-checkbox');
      if (testnetEl) testnetEl.checked = false;

      const statusEl = document.getElementById('api-status-display');
      if (statusEl) {
        statusEl.innerHTML = '<span>&#9679;</span> Chua ket noi';
        statusEl.className = 'api-status disconnected';
      }

      setStyle('api-balance-display', 'display', 'none');

      const configBtn = document.getElementById('api-config-btn');
      if (configBtn) configBtn.classList.remove('connected');

      setHtml('api-icon', '&#128274;');

      showToast({ type: 'info', title: 'Da xoa!', message: 'API Key da bi xoa khoi trinh duyet' });
    }

    // ===================== BINANCE POSITION SYNC =====================

    // Close position on Binance
    async function closeBinancePosition(localPosition) {
      if (!binanceApiConfig.connected) {
        showToast({ type: 'error', title: 'Loi', message: 'Chua ket noi Binance API' });
        return false;
      }

      try {
        const side = localPosition.type === 'LONG' ? 'SELL' : 'BUY';
        const symbolInfo = await getSymbolInfo(localPosition.symbol);
        const quantity = roundQuantity(localPosition.quantity, symbolInfo.stepSize);

        const result = await placeBinanceOrder(localPosition.symbol, side, quantity, 'MARKET');

        showToast({
          type: 'success',
          title: 'Da dong lenh tren Binance!',
          message: `${localPosition.symbol} ${localPosition.type} - Order ID: ${result.orderId}`
        });

        return true;
      } catch (error) {
        showToast({ type: 'error', title: 'Loi dong lenh', message: error.message });
        return false;
      }
    }

    // Wrapper function to close position on Binance by ID
    async function closePositionOnBinance(positionId) {
      const position = openPositions.find(p => p.id === positionId);
      if (!position) {
        showToast({ type: 'error', title: 'Loi', message: 'Khong tim thay lenh' });
        return;
      }

      if (!binanceApiConfig.connected) {
        showToast({ type: 'error', title: 'Loi', message: 'Chua ket noi Binance API. Click vao nut khoa de cau hinh.' });
        return;
      }

      // Confirm before closing
      const confirmed = await showConfirm(
        'Xac nhan dong lenh tren Binance',
        `Symbol: ${position.symbol}<br>` +
        `Loai: ${position.type}<br>` +
        `So luong: ${position.quantity.toFixed(6)}<br>` +
        `<br><strong style="color: #ff5252;">Lenh se duoc DONG THAT tren Binance!</strong>`,
        false
      );

      if (!confirmed.confirmed) return;

      showToast({ type: 'info', title: 'Dang dong lenh...', message: 'Vui long doi...' });

      const success = await closeBinancePosition(position);

      if (success) {
        // Also close local position
        closePosition(positionId);
        // Refresh balance
        testApiConnection();
      }
    }

    // Get symbol info for precision
    async function getSymbolInfo(symbol) {
      const baseUrl = binanceApiConfig.testnet ? BINANCE_TESTNET_URL : BINANCE_LIVE_URL;
      const response = await fetch(`${baseUrl}/fapi/v1/exchangeInfo`);
      const data = await response.json();
      const symbolInfo = data.symbols.find(s => s.symbol === symbol);

      if (!symbolInfo) {
        throw new Error(`Symbol ${symbol} khong ton tai`);
      }

      const lotSizeFilter = symbolInfo.filters.find(f => f.filterType === 'LOT_SIZE');
      const priceFilter = symbolInfo.filters.find(f => f.filterType === 'PRICE_FILTER');

      return {
        pricePrecision: symbolInfo.pricePrecision,
        quantityPrecision: symbolInfo.quantityPrecision,
        stepSize: parseFloat(lotSizeFilter?.stepSize || 0),
        tickSize: parseFloat(priceFilter?.tickSize || 0)
      };
    }

    // Round quantity to correct precision
    function roundQuantity(quantity, stepSize) {
      const precision = Math.round(-Math.log10(stepSize));
      return Math.floor(quantity * Math.pow(10, precision)) / Math.pow(10, precision);
    }

    // Round price to correct precision
    function roundPrice(price, tickSize) {
      const precision = Math.round(-Math.log10(tickSize));
      return Math.round(price * Math.pow(10, precision)) / Math.pow(10, precision);
    }

    // Place order on Binance
    async function placeBinanceOrder(symbol, side, quantity, orderType = 'MARKET', price = null) {
      const params = {
        symbol: symbol.toUpperCase(),
        side,
        type: orderType,
        quantity
      };

      if (orderType === 'LIMIT' && price) {
        params.price = price;
        params.timeInForce = 'GTC';
      }

      return binanceSignedRequest('POST', '/fapi/v1/order', params);
    }

    // Place stop loss order - Su dung STOP LIMIT order
    async function placeStopLoss(symbol, side, quantity, stopPrice) {
      const closeSide = side === 'BUY' ? 'SELL' : 'BUY';
      const params = {
        symbol: symbol.toUpperCase(),
        side: closeSide,
        type: 'STOP',
        stopPrice: stopPrice.toString(),
        price: stopPrice.toString(),
        quantity: quantity.toString(),
        reduceOnly: 'true',
        timeInForce: 'GTC',
        workingType: 'MARK_PRICE'
      };
      console.log('[placeStopLoss] Params:', params);
      return binanceSignedRequest('POST', '/fapi/v1/order', params);
    }

    // Place take profit order - Su dung TAKE_PROFIT LIMIT order
    async function placeTakeProfit(symbol, side, quantity, stopPrice) {
      const closeSide = side === 'BUY' ? 'SELL' : 'BUY';
      const params = {
        symbol: symbol.toUpperCase(),
        side: closeSide,
        type: 'TAKE_PROFIT',
        stopPrice: stopPrice.toString(),
        price: stopPrice.toString(),
        quantity: quantity.toString(),
        reduceOnly: 'true',
        timeInForce: 'GTC',
        workingType: 'MARK_PRICE'
      };
      console.log('[placeTakeProfit] Params:', params);
      return binanceSignedRequest('POST', '/fapi/v1/order', params);
    }

    // Set leverage
    async function setLeverage(symbol, leverage) {
      return binanceSignedRequest('POST', '/fapi/v1/leverage', {
        symbol: symbol.toUpperCase(),
        leverage
      });
    }

    // Set margin type
    async function setMarginType(symbol, marginType = 'ISOLATED') {
      try {
        return await binanceSignedRequest('POST', '/fapi/v1/marginType', {
          symbol: symbol.toUpperCase(),
          marginType
        });
      } catch (error) {
        // Ignore if already set to this type
        if (!error.message.includes('No need to change margin type')) {
          throw error;
        }
      }
    }

    // Execute trade on Binance with SL/TP
    async function executeBinanceTrade(symbol, side, margin, leverage, entryPrice, stopLoss, takeProfit) {
      if (!binanceApiConfig.connected) {
        throw new Error('Chua ket noi Binance API. Vui long cau hinh API truoc.');
      }

      const results = {
        leverage: null,
        mainOrder: null,
        slOrder: null,
        tpOrder: null,
        errors: []
      };

      try {
        // 1. Get symbol info
        const symbolInfo = await getSymbolInfo(symbol);

        // 2. Calculate position size
        const positionValue = margin * leverage;
        const quantity = roundQuantity(positionValue / entryPrice, symbolInfo.stepSize);

        if (quantity <= 0) {
          throw new Error('So luong qua nho, tang margin hoac leverage');
        }

        // 3. Set leverage
        results.leverage = await setLeverage(symbol, leverage);

        // 4. Set margin type
        await setMarginType(symbol, 'ISOLATED');

        // 5. Place main order
        const orderSide = side === 'LONG' ? 'BUY' : 'SELL';
        results.mainOrder = await placeBinanceOrder(symbol, orderSide, quantity, 'MARKET');
        console.log('[Trade] Main order result:', results.mainOrder);

        // Doi 500ms de lenh duoc xu ly hoan toan
        await new Promise(resolve => setTimeout(resolve, 500));

        // Lay gia thuc te va so luong thuc te tu lenh
        const actualEntryPrice = parseFloat(results.mainOrder.avgPrice) || entryPrice;
        const actualQuantity = parseFloat(results.mainOrder.executedQty) || quantity;
        console.log('[Trade] Actual entry price:', actualEntryPrice, 'Original entry:', entryPrice);
        console.log('[Trade] Actual quantity:', actualQuantity, 'Original quantity:', quantity);

        // NOTE: SL/TP khong duoc ho tro qua API Binance voi quyen hien tai
        // Ban can tu dat SL/TP tren app Binance sau khi vao lenh
        console.log('[Trade] SL/TP khong ho tro qua API - Vui long dat thu cong tren Binance');
        if (stopLoss && stopLoss > 0) {
          results.slNote = `Dat SL thu cong: ${roundPrice(stopLoss, symbolInfo.tickSize)}`;
          console.log('[Trade]', results.slNote);
        }
        if (takeProfit && takeProfit > 0) {
          results.tpNote = `Dat TP thu cong: ${roundPrice(takeProfit, symbolInfo.tickSize)}`;
          console.log('[Trade]', results.tpNote);
        }

        return results;

      } catch (error) {
        results.errors.push(error.message);
        throw { results, error: error.message };
      }
    }

    // Open position on Binance from signal
    async function openBinancePosition(side) {
      if (!binanceApiConfig.connected) {
        showToast({
          type: 'error',
          title: 'Chua ket noi Binance',
          message: 'Click vao nut khoa de cau hinh API Key truoc khi giao dich.'
        });
        return;
      }

      // Get elements with null checks
      const symbolEl = document.getElementById('symbol');
      const marginEl = document.getElementById('order-margin');
      const entryEl = document.getElementById('order-entry');
      const leverageEl = document.getElementById('order-leverage');
      const slEl = document.getElementById('order-sl');
      const tpEl = document.getElementById('order-tp');

      // Check if required elements exist
      if (!symbolEl || !marginEl || !entryEl || !leverageEl) {
        showToast({
          type: 'error',
          title: 'Loi',
          message: 'Vui long phan tich symbol truoc khi vao lenh. Chuyen sang tab "Phan tich 1 Symbol".'
        });
        return;
      }

      const symbol = symbolEl.value;
      const margin = parseFloat(marginEl.value);
      const entryPrice = parseFloat(entryEl.value);
      const leverage = parseInt(leverageEl.value);
      const stopLoss = slEl ? parseFloat(slEl.value) : 0;
      const takeProfit = tpEl ? parseFloat(tpEl.value) : 0;

      // Debug log
      console.log('[openBinancePosition] Form values:', {
        symbol,
        margin,
        entryPrice,
        leverage,
        stopLoss,
        takeProfit,
        slElValue: slEl?.value,
        tpElValue: tpEl?.value
      });

      if (!margin || !entryPrice || !leverage) {
        showToast({ type: 'error', title: 'Loi', message: 'Vui long nhap day du thong tin lenh' });
        return;
      }

      // Confirm before trading
      const confirmed = await showConfirm(
        `Xac nhan mo lenh ${side}`,
        `Symbol: ${symbol}<br>` +
        `Margin: ${margin} USDT<br>` +
        `Leverage: ${leverage}x<br>` +
        `Entry: ~$${entryPrice}<br>` +
        `<br><strong style="color: #ffc107;">Luu y: SL/TP can dat THU CONG tren app Binance sau khi vao lenh!</strong><br>` +
        `- Stop Loss de nghi: $${stopLoss}<br>` +
        `- Take Profit de nghi: $${takeProfit}<br>` +
        `<br><strong style="color: #ff5252;">Lenh se duoc thuc hien THAT tren Binance ${binanceApiConfig.testnet ? '(Testnet)' : '(Live)'}!</strong>`,
        false
      );

      if (!confirmed.confirmed) return;

      showToast({ type: 'info', title: 'Dang dat lenh...', message: 'Vui long doi...' });

      try {
        const results = await executeBinanceTrade(symbol, side, margin, leverage, entryPrice, stopLoss, takeProfit);

        const details = [
          { label: 'Order ID', value: results.mainOrder?.orderId || 'N/A' },
          { label: 'Quantity', value: results.mainOrder?.origQty || 'N/A' },
          { label: 'Gia vao', value: '$' + (results.mainOrder?.avgPrice || 'N/A') },
          { label: 'Status', value: results.mainOrder?.status || 'N/A' }
        ];

        // Hien thi huong dan dat SL/TP thu cong
        if (results.slNote) {
          details.push({ label: 'Stop Loss', value: results.slNote, class: 'warning' });
        }
        if (results.tpNote) {
          details.push({ label: 'Take Profit', value: results.tpNote, class: 'warning' });
        }

        showToast({
          type: 'success',
          title: `Lenh ${side} da mo thanh cong!`,
          message: `${symbol} - ${leverage}x | Dat SL/TP thu cong tren Binance!`,
          details,
          duration: 10000
        });

        // Also save to local positions for tracking
        openPosition(side);

        // Refresh balance
        testApiConnection();

      } catch (error) {
        const errMsg = error.error || error.message || 'Unknown error';
        showToast({
          type: 'error',
          title: 'Dat lenh that bai',
          message: errMsg,
          duration: 6000
        });
      }
    }

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', function() {
      // Show/hide admin-only features
      showBinanceFeatures();

      loadApiConfig();

      // Init chart modal
      initChartModal();
    });
  </script>
</body>
</html>
