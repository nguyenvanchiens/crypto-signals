<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Trading Signal Bot - Futures Long/Short</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #fff;
      min-height: 100vh;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    header {
      text-align: center;
      padding: 30px 0;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      margin-bottom: 30px;
    }

    header h1 {
      font-size: 2.5em;
      background: linear-gradient(45deg, #00d9ff, #00ff88);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 10px;
    }

    header p {
      color: #888;
      font-size: 1.1em;
    }

    .controls {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      margin-bottom: 30px;
      padding: 20px;
      background: rgba(255,255,255,0.05);
      border-radius: 15px;
    }

    .control-group {
      flex: 1;
      min-width: 200px;
    }

    .control-group label {
      display: block;
      margin-bottom: 8px;
      color: #00d9ff;
      font-weight: 500;
    }

    select, input {
      width: 100%;
      padding: 12px 15px;
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 8px;
      background: #1a1a2e;
      color: #fff;
      font-size: 1em;
      cursor: pointer;
    }

    select option {
      background: #1a1a2e;
      color: #fff;
      padding: 10px;
    }

    select:focus, input:focus {
      outline: none;
      border-color: #00d9ff;
    }

    button {
      padding: 12px 30px;
      background: linear-gradient(45deg, #00d9ff, #00ff88);
      border: none;
      border-radius: 8px;
      color: #1a1a2e;
      font-size: 1em;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(0, 217, 255, 0.4);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .signal-card {
      background: rgba(255,255,255,0.05);
      border-radius: 15px;
      padding: 25px;
      margin-bottom: 20px;
      border: 1px solid rgba(255,255,255,0.1);
    }

    .signal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      flex-wrap: wrap;
      gap: 10px;
    }

    .symbol-info {
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .symbol-name {
      font-size: 1.8em;
      font-weight: bold;
    }

    .price {
      font-size: 1.5em;
      color: #00ff88;
    }

    .signal-badge {
      padding: 10px 25px;
      border-radius: 25px;
      font-weight: bold;
      font-size: 1.2em;
      text-transform: uppercase;
    }

    .signal-long {
      background: linear-gradient(45deg, #00c853, #00e676);
      color: #1a1a2e;
    }

    .signal-short {
      background: linear-gradient(45deg, #ff1744, #ff5252);
      color: #fff;
    }

    .signal-wait {
      background: rgba(255,255,255,0.2);
      color: #fff;
    }

    .indicators-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }

    .indicator-box {
      background: rgba(0,0,0,0.3);
      padding: 15px;
      border-radius: 10px;
    }

    .indicator-box h4 {
      color: #888;
      font-size: 0.85em;
      text-transform: uppercase;
      margin-bottom: 8px;
    }

    .indicator-box .value {
      font-size: 1.3em;
      font-weight: bold;
    }

    .indicator-box .status {
      font-size: 0.9em;
      margin-top: 5px;
    }

    .bullish { color: #00ff88; }
    .bearish { color: #ff5252; }
    .neutral { color: #ffd700; }

    .trade-setup {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
      padding: 20px;
      background: rgba(0,0,0,0.3);
      border-radius: 10px;
      margin-bottom: 20px;
    }

    .trade-item {
      text-align: center;
    }

    .trade-item label {
      display: block;
      color: #888;
      font-size: 0.85em;
      margin-bottom: 5px;
    }

    .trade-item .value {
      font-size: 1.2em;
      font-weight: bold;
    }

    .entry { color: #00d9ff; }
    .stop-loss { color: #ff5252; }
    .take-profit { color: #00ff88; }

    .reasons {
      background: rgba(0,0,0,0.3);
      padding: 15px;
      border-radius: 10px;
    }

    .reasons h4 {
      color: #00d9ff;
      margin-bottom: 10px;
    }

    .reasons ul {
      list-style: none;
      padding-left: 0;
    }

    .reasons li {
      padding: 8px 0;
      border-bottom: 1px solid rgba(255,255,255,0.05);
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .reasons li:before {
      content: "→";
      color: #00d9ff;
    }

    .reasons li:last-child {
      border-bottom: none;
    }

    .position-calculator {
      background: rgba(255,255,255,0.05);
      border-radius: 15px;
      padding: 25px;
      margin-top: 30px;
    }

    .position-calculator h3 {
      color: #00d9ff;
      margin-bottom: 20px;
    }

    .calc-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }

    .calc-result {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
      padding: 20px;
      background: rgba(0,0,0,0.3);
      border-radius: 10px;
    }

    .loading {
      text-align: center;
      padding: 50px;
      color: #888;
    }

    .loading::after {
      content: "";
      display: inline-block;
      width: 30px;
      height: 30px;
      border: 3px solid rgba(0, 217, 255, 0.3);
      border-top-color: #00d9ff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-left: 10px;
      vertical-align: middle;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .multi-signals {
      display: grid;
      gap: 15px;
    }

    .mini-signal {
      display: grid;
      grid-template-columns: 1fr 1fr auto;
      gap: 20px;
      align-items: center;
      background: rgba(255,255,255,0.05);
      padding: 15px 20px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.1);
    }

    .mini-signal:hover {
      border-color: #00d9ff;
      cursor: pointer;
    }

    .mini-signal .symbol {
      font-weight: bold;
      font-size: 1.1em;
    }

    .mini-signal .price-info {
      color: #888;
    }

    .mini-signal .mini-badge {
      padding: 5px 15px;
      border-radius: 15px;
      font-size: 0.9em;
      font-weight: bold;
    }

    .confidence-bar {
      height: 6px;
      background: rgba(255,255,255,0.1);
      border-radius: 3px;
      overflow: hidden;
    }

    /* Order Entry Form */
    .order-entry {
      background: rgba(0,217,255,0.1);
      border: 1px solid #00d9ff;
      border-radius: 10px;
      padding: 20px;
      margin-top: 15px;
    }

    .order-entry h4 {
      color: #00d9ff;
      margin-bottom: 15px;
    }

    .order-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 10px;
      margin-bottom: 15px;
    }

    .order-grid input {
      padding: 10px;
      font-size: 0.95em;
    }

    .order-buttons {
      display: flex;
      gap: 10px;
    }

    .order-buttons button {
      flex: 1;
      padding: 12px;
    }

    .btn-long {
      background: linear-gradient(45deg, #00c853, #00e676) !important;
    }

    .btn-short {
      background: linear-gradient(45deg, #ff1744, #ff5252) !important;
      color: #fff !important;
    }

    /* Position History */
    .position-card {
      background: rgba(255,255,255,0.05);
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 10px;
      border-left: 4px solid #888;
    }

    .position-card.long {
      border-left-color: #00ff88;
    }

    .position-card.short {
      border-left-color: #ff5252;
    }

    .position-card.profit {
      background: rgba(0,255,136,0.1);
    }

    .position-card.loss {
      background: rgba(255,82,82,0.1);
    }

    .position-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .position-symbol {
      font-weight: bold;
      font-size: 1.1em;
    }

    .position-pnl {
      font-weight: bold;
      font-size: 1.2em;
    }

    .position-pnl.profit {
      color: #00ff88;
    }

    .position-pnl.loss {
      color: #ff5252;
    }

    .position-details {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      gap: 10px;
      font-size: 0.9em;
      color: #888;
    }

    .position-details span {
      display: block;
    }

    .position-details .label {
      color: #666;
      font-size: 0.85em;
    }

    .position-details .value {
      color: #fff;
    }

    .position-actions {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }

    .position-actions button {
      padding: 8px 15px;
      font-size: 0.85em;
    }

    .btn-close-profit {
      background: linear-gradient(45deg, #00c853, #00e676) !important;
    }

    .btn-close-loss {
      background: linear-gradient(45deg, #ff1744, #ff5252) !important;
      color: #fff !important;
    }

    .btn-delete {
      background: rgba(255,255,255,0.1) !important;
      color: #888 !important;
    }

    .btn-copy {
      background: linear-gradient(45deg, #00d9ff, #0099cc) !important;
      color: #fff !important;
    }

    .btn-copy:hover {
      box-shadow: 0 3px 15px rgba(0, 217, 255, 0.4);
    }

    .no-positions {
      text-align: center;
      padding: 40px;
      color: #666;
    }

    .history-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
      padding: 20px;
      background: rgba(0,0,0,0.3);
      border-radius: 10px;
    }

    .stat-item {
      text-align: center;
    }

    .stat-item .label {
      color: #888;
      font-size: 0.85em;
      margin-bottom: 5px;
    }

    .stat-item .value {
      font-size: 1.3em;
      font-weight: bold;
      margin-top: 5px;
    }

    .confidence-fill {
      height: 100%;
      border-radius: 3px;
      transition: width 0.3s;
    }

    .tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    }

    .tab {
      padding: 10px 20px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .tab:hover, .tab.active {
      background: rgba(0, 217, 255, 0.2);
      border-color: #00d9ff;
    }

    .symbol-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: #1a1a2e;
      border: 1px solid #00d9ff;
      border-radius: 8px;
      max-height: 300px;
      overflow-y: auto;
      z-index: 1000;
      margin-top: 5px;
    }

    .symbol-dropdown-item {
      padding: 12px 15px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }

    .symbol-dropdown-item:hover {
      background: rgba(0, 217, 255, 0.2);
    }

    .symbol-dropdown-item .coin-name {
      font-weight: bold;
      color: #fff;
    }

    .symbol-dropdown-item .coin-pair {
      color: #888;
      font-size: 0.9em;
    }

    /* Toast Notification */
    .toast-container {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 9999;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .toast {
      min-width: 320px;
      max-width: 420px;
      padding: 16px 20px;
      border-radius: 12px;
      background: rgba(26, 26, 46, 0.98);
      border: 1px solid rgba(255,255,255,0.1);
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
      animation: slideIn 0.3s ease-out;
      backdrop-filter: blur(10px);
    }

    .toast.success {
      border-left: 4px solid #00ff88;
    }

    .toast.error {
      border-left: 4px solid #ff5252;
    }

    .toast.info {
      border-left: 4px solid #00d9ff;
    }

    .toast-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
    }

    .toast-icon {
      font-size: 1.5em;
    }

    .toast-title {
      font-weight: bold;
      font-size: 1.1em;
      color: #fff;
    }

    .toast-body {
      color: #ccc;
      font-size: 0.95em;
      line-height: 1.5;
    }

    .toast-body .detail {
      display: flex;
      justify-content: space-between;
      padding: 4px 0;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }

    .toast-body .detail:last-child {
      border-bottom: none;
    }

    .toast-body .detail .label {
      color: #888;
    }

    .toast-body .detail .value {
      font-weight: 500;
    }

    .toast-body .value.long {
      color: #00ff88;
    }

    .toast-body .value.short {
      color: #ff5252;
    }

    .toast-close {
      position: absolute;
      top: 10px;
      right: 10px;
      background: none;
      border: none;
      color: #888;
      font-size: 1.2em;
      cursor: pointer;
      padding: 5px;
    }

    .toast-close:hover {
      color: #fff;
    }

    .toast-progress {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 3px;
      background: linear-gradient(90deg, #00d9ff, #00ff88);
      border-radius: 0 0 0 12px;
      animation: progress 4s linear forwards;
    }

    /* Modal Dialog */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      animation: fadeIn 0.2s ease-out;
    }

    .modal {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      border-radius: 16px;
      padding: 25px;
      min-width: 350px;
      max-width: 450px;
      border: 1px solid rgba(255,255,255,0.1);
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
      animation: scaleIn 0.2s ease-out;
    }

    .modal-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 20px;
    }

    .modal-icon {
      font-size: 2em;
    }

    .modal-icon.warning { color: #ffc107; }
    .modal-icon.danger { color: #ff5252; }
    .modal-icon.success { color: #00ff88; }
    .modal-icon.info { color: #00d9ff; }

    .modal-title {
      font-size: 1.3em;
      font-weight: bold;
      color: #fff;
    }

    .modal-body {
      color: #ccc;
      margin-bottom: 20px;
      line-height: 1.6;
    }

    .modal-input {
      width: 100%;
      padding: 12px 15px;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      background: rgba(0,0,0,0.3);
      color: #fff;
      font-size: 1.1em;
      margin-top: 10px;
    }

    .modal-input:focus {
      outline: none;
      border-color: #00d9ff;
    }

    .modal-footer {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }

    .modal-btn {
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 1em;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .modal-btn.cancel {
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      color: #ccc;
    }

    .modal-btn.cancel:hover {
      background: rgba(255,255,255,0.2);
    }

    .modal-btn.confirm {
      background: linear-gradient(45deg, #00d9ff, #00ff88);
      border: none;
      color: #1a1a2e;
    }

    .modal-btn.confirm:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(0, 217, 255, 0.4);
    }

    .modal-btn.danger {
      background: linear-gradient(45deg, #ff5252, #ff1744);
      border: none;
      color: #fff;
    }

    .modal-btn.danger:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(255, 82, 82, 0.4);
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes scaleIn {
      from { transform: scale(0.9); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes slideOut {
      from {
        transform: translateX(0);
        opacity: 1;
      }
      to {
        transform: translateX(100%);
        opacity: 0;
      }
    }

    @keyframes progress {
      from { width: 100%; }
      to { width: 0%; }
    }

    @media (max-width: 768px) {
      .controls {
        flex-direction: column;
      }

      .signal-header {
        flex-direction: column;
        text-align: center;
      }

      .mini-signal {
        grid-template-columns: 1fr;
        text-align: center;
      }
    }
  </style>
</head>
<body>
  <!-- Toast Container -->
  <div class="toast-container" id="toast-container"></div>

  <div class="container">
    <header>
      <h1>Trading Signal Bot</h1>
      <p>Phân tích tín hiệu Futures Long/Short với Stop Loss tự động</p>
    </header>

    <div class="tabs">
      <div class="tab active" onclick="switchTab('single')">Phân tích 1 Symbol</div>
      <div class="tab" onclick="switchTab('multi')">Quét nhiều Symbol</div>
      <div class="tab" onclick="switchTab('positions')">Lệnh đang mở (<span id="open-count">0</span>)</div>
      <div class="tab" onclick="switchTab('history')">Lịch sử</div>
    </div>

    <!-- Single Analysis -->
    <div id="single-tab">
      <div class="controls" style="align-items: flex-start;">
        <div class="control-group">
          <label>Tìm Symbol</label>
          <div style="position: relative;">
            <input type="text" id="symbolSearch" placeholder="Nhập tên coin (VD: BTC, ETH, SOL...)" autocomplete="off" oninput="filterSymbols()" onfocus="showSymbolList()">
            <div id="symbolList" class="symbol-dropdown" style="display: none;"></div>
            <div id="selectedSymbol" style="position: absolute; bottom: -24px; left: 0; color: #00ff88; font-weight: bold; font-size: 0.9em;">BTC/USDT</div>
          </div>
          <input type="hidden" id="symbol" value="BTCUSDT">
        </div>
        <div class="control-group">
          <label>Khung thời gian</label>
          <select id="interval">
            <option value="5m">5 Phút</option>
            <option value="15m">15 Phút</option>
            <option value="30m">30 Phút</option>
            <option value="1h" selected>1 Giờ</option>
            <option value="4h">4 Giờ</option>
            <option value="1d">1 Ngày</option>
          </select>
        </div>
        <div class="control-group">
          <label>Thị trường</label>
          <select id="market">
            <option value="futures" selected>Futures</option>
            <option value="spot">Spot</option>
          </select>
        </div>
        <div class="control-group">
          <label>&nbsp;</label>
          <button onclick="analyzeSignal()" id="analyzeBtn">Phân tích</button>
        </div>
      </div>

      <div id="signal-result"></div>
    </div>

    <!-- Multi Analysis -->
    <div id="multi-tab" style="display: none;">
      <div class="controls">
        <div class="control-group">
          <label>Khung thời gian</label>
          <select id="multi-interval">
            <option value="15m">15 Phút</option>
            <option value="1h" selected>1 Giờ</option>
            <option value="4h">4 Giờ</option>
          </select>
        </div>
        <div class="control-group" style="display: flex; align-items: flex-end;">
          <button onclick="scanSignals()" id="scanBtn">Quét tất cả</button>
        </div>
      </div>

      <div id="multi-result" class="multi-signals"></div>
    </div>

    <!-- Position Calculator -->
    <div id="calculator-tab" style="display: none;">
      <div class="position-calculator">
        <h3>Tính Position Size</h3>
        <div class="calc-grid">
          <div class="control-group">
            <label>Số dư tài khoản (USDT)</label>
            <input type="number" id="balance" value="1000" min="0">
          </div>
          <div class="control-group">
            <label>% Rủi ro mỗi lệnh</label>
            <input type="number" id="risk" value="2" min="0.1" max="10" step="0.1">
          </div>
          <div class="control-group">
            <label>Giá vào lệnh</label>
            <input type="number" id="entry" value="0" step="0.01">
          </div>
          <div class="control-group">
            <label>Stop Loss</label>
            <input type="number" id="sl" value="0" step="0.01">
          </div>
          <div class="control-group">
            <label>Đòn bẩy (Leverage)</label>
            <input type="number" id="leverage" value="10" min="1" max="125">
          </div>
          <div class="control-group" style="display: flex; align-items: flex-end;">
            <button onclick="calculatePosition()">Tính toán</button>
          </div>
        </div>

        <div id="calc-result" class="calc-result" style="display: none;"></div>
      </div>
    </div>

    <!-- Open Positions -->
    <div id="positions-tab" style="display: none;">
      <div class="history-stats">
        <div class="stat-item">
          <div class="label">Tổng lệnh đang mở</div>
          <div class="value" id="total-open">0</div>
        </div>
        <div class="stat-item">
          <div class="label">Tổng P/L chưa chốt</div>
          <div class="value" id="total-unrealized-pnl">$0.00</div>
        </div>
        <div class="stat-item">
          <div class="label">Tổng margin</div>
          <div class="value" id="total-margin">$0.00</div>
        </div>
      </div>
      <div id="open-positions"></div>
    </div>

    <!-- History -->
    <div id="history-tab" style="display: none;">
      <div class="history-stats">
        <div class="stat-item">
          <div class="label">Tổng lệnh đã đóng</div>
          <div class="value" id="total-closed">0</div>
        </div>
        <div class="stat-item">
          <div class="label">Tổng P/L</div>
          <div class="value" id="total-pnl">$0.00</div>
        </div>
        <div class="stat-item">
          <div class="label">Win Rate</div>
          <div class="value" id="win-rate">0%</div>
        </div>
        <div class="stat-item">
          <div class="label">Lệnh thắng / Thua</div>
          <div class="value" id="win-loss">0 / 0</div>
        </div>
      </div>
      <div id="closed-positions"></div>
    </div>
  </div>

  <script>
    const API_BASE = '';

    // Detect if running on Cloudflare Workers (not localhost)
    const IS_CLOUDFLARE = !window.location.hostname.includes('localhost') &&
                          !window.location.hostname.includes('127.0.0.1') &&
                          !window.location.hostname.match(/^192\.168\./);

    // ===================== TOAST NOTIFICATION SYSTEM =====================

    function showToast(options) {
      const { type = 'info', title, message, details = [], duration = 4000 } = options;

      const container = document.getElementById('toast-container');
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.style.position = 'relative';

      // Icon based on type
      const icons = {
        success: '<span style="color: #00ff88;">&#10003;</span>',
        error: '<span style="color: #ff5252;">&#10007;</span>',
        info: '<span style="color: #00d9ff;">&#9432;</span>'
      };

      // Build details HTML
      let detailsHtml = '';
      if (details.length > 0) {
        detailsHtml = details.map(d => `
          <div class="detail">
            <span class="label">${d.label}</span>
            <span class="value ${d.class || ''}">${d.value}</span>
          </div>
        `).join('');
      }

      toast.innerHTML = `
        <button class="toast-close" onclick="this.parentElement.remove()">&times;</button>
        <div class="toast-header">
          <span class="toast-icon">${icons[type] || icons.info}</span>
          <span class="toast-title">${title}</span>
        </div>
        <div class="toast-body">
          ${message ? `<p style="margin-bottom: 10px;">${message}</p>` : ''}
          ${detailsHtml}
        </div>
        <div class="toast-progress"></div>
      `;

      container.appendChild(toast);

      // Auto remove after duration
      setTimeout(() => {
        toast.style.animation = 'slideOut 0.3s ease-in forwards';
        setTimeout(() => toast.remove(), 300);
      }, duration);
    }

    // ===================== MODAL DIALOG SYSTEM =====================

    function showModal(options) {
      return new Promise((resolve) => {
        const { type = 'info', title, message, inputLabel, inputValue, confirmText = 'Xác nhận', cancelText = 'Hủy', showCancel = true, dangerMode = false } = options;

        const icons = {
          warning: '&#9888;',
          danger: '&#128308;',
          success: '&#10003;',
          info: '&#9432;'
        };

        const overlay = document.createElement('div');
        overlay.className = 'modal-overlay';

        const inputHtml = inputLabel ? `
          <label style="color: #888; font-size: 0.9em;">${inputLabel}</label>
          <input type="number" class="modal-input" id="modal-input" value="${inputValue || ''}" step="any">
        ` : '';

        overlay.innerHTML = `
          <div class="modal">
            <div class="modal-header">
              <span class="modal-icon ${type}">${icons[type] || icons.info}</span>
              <span class="modal-title">${title}</span>
            </div>
            <div class="modal-body">
              <p>${message}</p>
              ${inputHtml}
            </div>
            <div class="modal-footer">
              ${showCancel ? `<button class="modal-btn cancel" id="modal-cancel">${cancelText}</button>` : ''}
              <button class="modal-btn ${dangerMode ? 'danger' : 'confirm'}" id="modal-confirm">${confirmText}</button>
            </div>
          </div>
        `;

        document.body.appendChild(overlay);

        const input = overlay.querySelector('#modal-input');
        if (input) {
          input.focus();
          input.select();
        }

        const closeModal = (result) => {
          overlay.style.animation = 'fadeIn 0.2s ease-out reverse';
          setTimeout(() => overlay.remove(), 200);
          resolve(result);
        };

        overlay.querySelector('#modal-confirm').onclick = () => {
          if (input) {
            const value = parseFloat(input.value);
            closeModal({ confirmed: true, value: isNaN(value) ? null : value });
          } else {
            closeModal({ confirmed: true });
          }
        };

        if (showCancel) {
          overlay.querySelector('#modal-cancel').onclick = () => closeModal({ confirmed: false });
        }

        overlay.onclick = (e) => {
          if (e.target === overlay) closeModal({ confirmed: false });
        };

        // Enter key to confirm
        if (input) {
          input.onkeydown = (e) => {
            if (e.key === 'Enter') {
              overlay.querySelector('#modal-confirm').click();
            }
          };
        }
      });
    }

    function showConfirm(title, message, dangerMode = false) {
      return showModal({
        type: dangerMode ? 'danger' : 'warning',
        title,
        message,
        confirmText: 'Xác nhận',
        cancelText: 'Hủy',
        dangerMode
      });
    }

    function showPrompt(title, message, inputLabel, inputValue) {
      return showModal({
        type: 'info',
        title,
        message,
        inputLabel,
        inputValue,
        confirmText: 'Xác nhận',
        cancelText: 'Hủy'
      });
    }

    // ===================== CLIENT-SIDE BINANCE API & SIGNAL ENGINE =====================
    // Used when running on Cloudflare (because Binance blocks Cloudflare IPs)

    const BINANCE_FUTURES_API = 'https://fapi.binance.com';

    // Fetch klines directly from Binance
    async function fetchBinanceKlines(symbol, interval, limit = 100) {
      const url = `${BINANCE_FUTURES_API}/fapi/v1/klines?symbol=${symbol.toUpperCase()}&interval=${interval}&limit=${limit}`;
      const response = await fetch(url);
      if (!response.ok) throw new Error(`Binance API error: ${response.status}`);
      const data = await response.json();
      return data.map(k => ({
        openTime: k[0],
        open: parseFloat(k[1]),
        high: parseFloat(k[2]),
        low: parseFloat(k[3]),
        close: parseFloat(k[4]),
        volume: parseFloat(k[5]),
        closeTime: k[6]
      }));
    }

    // Fetch current price from Binance
    async function fetchBinancePrice(symbol) {
      const url = `${BINANCE_FUTURES_API}/fapi/v1/ticker/price?symbol=${symbol.toUpperCase()}`;
      const response = await fetch(url);
      if (!response.ok) throw new Error(`Binance API error: ${response.status}`);
      const data = await response.json();
      return { symbol: data.symbol, price: parseFloat(data.price) };
    }

    // ===================== CLIENT-SIDE TECHNICAL INDICATORS =====================

    class ClientTechnicalIndicators {
      // Simple Moving Average
      static SMA(data, period) {
        const result = [];
        for (let i = 0; i < data.length; i++) {
          if (i < period - 1) {
            result.push(null);
          } else {
            const sum = data.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
            result.push(sum / period);
          }
        }
        return result;
      }

      // Exponential Moving Average
      static EMA(data, period) {
        const result = [];
        const multiplier = 2 / (period + 1);
        let ema = data.slice(0, period).reduce((a, b) => a + b, 0) / period;
        for (let i = 0; i < data.length; i++) {
          if (i < period - 1) {
            result.push(null);
          } else if (i === period - 1) {
            result.push(ema);
          } else {
            ema = (data[i] - ema) * multiplier + ema;
            result.push(ema);
          }
        }
        return result;
      }

      // RSI
      static RSI(closes, period = 14) {
        const changes = [];
        for (let i = 1; i < closes.length; i++) {
          changes.push(closes[i] - closes[i - 1]);
        }

        const gains = changes.map(c => c > 0 ? c : 0);
        const losses = changes.map(c => c < 0 ? Math.abs(c) : 0);

        const result = [];
        let avgGain = gains.slice(0, period).reduce((a, b) => a + b, 0) / period;
        let avgLoss = losses.slice(0, period).reduce((a, b) => a + b, 0) / period;

        for (let i = 0; i < closes.length; i++) {
          if (i < period) {
            result.push(null);
          } else if (i === period) {
            const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
            result.push(100 - (100 / (1 + rs)));
          } else {
            avgGain = (avgGain * (period - 1) + gains[i - 1]) / period;
            avgLoss = (avgLoss * (period - 1) + losses[i - 1]) / period;
            const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
            result.push(100 - (100 / (1 + rs)));
          }
        }
        return result;
      }

      // MACD
      static MACD(closes, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
        const emaFast = this.EMA(closes, fastPeriod);
        const emaSlow = this.EMA(closes, slowPeriod);

        const macdLine = emaFast.map((fast, i) => {
          if (fast === null || emaSlow[i] === null) return null;
          return fast - emaSlow[i];
        });

        const validMacd = macdLine.filter(v => v !== null);
        const signalLine = this.EMA(validMacd, signalPeriod);

        const result = { macd: [], signal: [], histogram: [] };
        let signalIndex = 0;

        for (let i = 0; i < macdLine.length; i++) {
          if (macdLine[i] === null) {
            result.macd.push(null);
            result.signal.push(null);
            result.histogram.push(null);
          } else {
            result.macd.push(macdLine[i]);
            const sig = signalLine[signalIndex] || null;
            result.signal.push(sig);
            result.histogram.push(sig !== null ? macdLine[i] - sig : null);
            signalIndex++;
          }
        }
        return result;
      }

      // Bollinger Bands
      static BollingerBands(closes, period = 20, stdDev = 2) {
        const sma = this.SMA(closes, period);
        const result = { upper: [], middle: [], lower: [] };

        for (let i = 0; i < closes.length; i++) {
          if (sma[i] === null) {
            result.upper.push(null);
            result.middle.push(null);
            result.lower.push(null);
          } else {
            const slice = closes.slice(i - period + 1, i + 1);
            const mean = sma[i];
            const variance = slice.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / period;
            const std = Math.sqrt(variance);

            result.upper.push(mean + stdDev * std);
            result.middle.push(mean);
            result.lower.push(mean - stdDev * std);
          }
        }
        return result;
      }

      // ATR
      static ATR(candles, period = 14) {
        const trueRanges = [];
        for (let i = 0; i < candles.length; i++) {
          if (i === 0) {
            trueRanges.push(candles[i].high - candles[i].low);
          } else {
            const tr = Math.max(
              candles[i].high - candles[i].low,
              Math.abs(candles[i].high - candles[i - 1].close),
              Math.abs(candles[i].low - candles[i - 1].close)
            );
            trueRanges.push(tr);
          }
        }
        return this.EMA(trueRanges, period);
      }
    }

    // ===================== CLIENT-SIDE SIGNAL ENGINE =====================

    class ClientSignalEngine {
      constructor() {
        this.config = {
          rsiPeriod: 14,
          rsiOversold: 30,
          rsiOverbought: 70,
          atrMultiplier: 1.5,
          riskRewardRatio: 2
        };
      }

      analyze(candles) {
        const closes = candles.map(c => c.close);
        const highs = candles.map(c => c.high);
        const lows = candles.map(c => c.low);
        const currentPrice = closes[closes.length - 1];

        // Calculate indicators
        const rsi = ClientTechnicalIndicators.RSI(closes, 14);
        const macd = ClientTechnicalIndicators.MACD(closes);
        const ema9 = ClientTechnicalIndicators.EMA(closes, 9);
        const ema21 = ClientTechnicalIndicators.EMA(closes, 21);
        const ema50 = ClientTechnicalIndicators.EMA(closes, 50);
        const bb = ClientTechnicalIndicators.BollingerBands(closes);
        const atr = ClientTechnicalIndicators.ATR(candles, 14);

        const latestIndicators = {
          rsi: rsi[rsi.length - 1],
          macd: macd.macd[macd.macd.length - 1],
          macdSignal: macd.signal[macd.signal.length - 1],
          macdHistogram: macd.histogram[macd.histogram.length - 1],
          ema9: ema9[ema9.length - 1],
          ema21: ema21[ema21.length - 1],
          ema50: ema50[ema50.length - 1],
          bbUpper: bb.upper[bb.upper.length - 1],
          bbMiddle: bb.middle[bb.middle.length - 1],
          bbLower: bb.lower[bb.lower.length - 1],
          atr: atr[atr.length - 1]
        };

        // Analyze each indicator
        const analysis = {
          rsi: this.analyzeRSI(latestIndicators.rsi),
          macd: this.analyzeMACD(latestIndicators),
          ema: this.analyzeEMA(latestIndicators, currentPrice),
          bb: this.analyzeBB(latestIndicators, currentPrice),
          trend: this.analyzeTrend(latestIndicators, currentPrice)
        };

        // Calculate total score
        const scores = Object.values(analysis).map(a => a.score);
        const totalScore = scores.reduce((a, b) => a + b, 0);
        const avgScore = (totalScore / scores.length).toFixed(2);

        let strength = 'YẾU';
        if (Math.abs(totalScore) >= 4) strength = 'MẠNH';
        else if (Math.abs(totalScore) >= 2) strength = 'TRUNG BÌNH';

        // Generate signal
        const signal = this.generateSignal({ totalScore, strength }, currentPrice, latestIndicators);

        return {
          currentPrice,
          indicators: {
            rsi: { current: latestIndicators.rsi, period: 14 },
            macd: {
              macd: latestIndicators.macd,
              signal: latestIndicators.macdSignal,
              histogram: latestIndicators.macdHistogram
            },
            ema: { ema9: latestIndicators.ema9, ema21: latestIndicators.ema21, ema50: latestIndicators.ema50 },
            bollingerBands: { upper: latestIndicators.bbUpper, middle: latestIndicators.bbMiddle, lower: latestIndicators.bbLower },
            atr: { current: latestIndicators.atr, period: 14 }
          },
          analysis,
          signal
        };
      }

      analyzeRSI(rsi) {
        if (rsi === null) return { score: 0, signal: 'N/A' };
        if (rsi < 30) return { score: 2, signal: 'OVERSOLD' };
        if (rsi < 40) return { score: 1, signal: 'BULLISH' };
        if (rsi > 70) return { score: -2, signal: 'OVERBOUGHT' };
        if (rsi > 60) return { score: -1, signal: 'BEARISH' };
        return { score: 0, signal: 'NEUTRAL' };
      }

      analyzeMACD(indicators) {
        const { macd, macdSignal, macdHistogram } = indicators;
        if (macd === null || macdSignal === null) return { score: 0, signal: 'N/A' };

        let score = 0;
        if (macd > macdSignal) score += 1;
        else score -= 1;

        if (macdHistogram > 0) score += 1;
        else score -= 1;

        let signal = 'NEUTRAL';
        if (score >= 2) signal = 'BULLISH';
        else if (score <= -2) signal = 'BEARISH';

        return { score, signal };
      }

      analyzeEMA(indicators, currentPrice) {
        const { ema9, ema21, ema50 } = indicators;
        if (!ema9 || !ema21 || !ema50) return { score: 0, signal: 'N/A' };

        let score = 0;
        if (currentPrice > ema9) score += 1;
        else score -= 1;

        if (ema9 > ema21) score += 1;
        else score -= 1;

        if (currentPrice > ema50) score += 1;
        else score -= 1;

        let signal = 'NEUTRAL';
        if (score >= 2) signal = 'BULLISH';
        else if (score <= -2) signal = 'BEARISH';

        return { score, signal };
      }

      analyzeBB(indicators, currentPrice) {
        const { bbUpper, bbMiddle, bbLower } = indicators;
        if (!bbUpper || !bbMiddle || !bbLower) return { score: 0, signal: 'N/A', pricePosition: 50 };

        const range = bbUpper - bbLower;
        const position = ((currentPrice - bbLower) / range * 100).toFixed(1);

        let score = 0;
        let signal = 'NEUTRAL';

        if (currentPrice <= bbLower) {
          score = 2;
          signal = 'OVERSOLD';
        } else if (currentPrice >= bbUpper) {
          score = -2;
          signal = 'OVERBOUGHT';
        } else if (currentPrice < bbMiddle) {
          score = 1;
          signal = 'BULLISH';
        } else {
          score = -1;
          signal = 'BEARISH';
        }

        return { score, signal, pricePosition: position };
      }

      analyzeTrend(indicators, currentPrice) {
        const { ema21, ema50 } = indicators;
        if (!ema21 || !ema50) return { score: 0, signal: 'N/A' };

        if (currentPrice > ema21 && ema21 > ema50) {
          return { score: 2, signal: 'STRONG_UPTREND' };
        } else if (currentPrice > ema50) {
          return { score: 1, signal: 'UPTREND' };
        } else if (currentPrice < ema21 && ema21 < ema50) {
          return { score: -2, signal: 'STRONG_DOWNTREND' };
        } else if (currentPrice < ema50) {
          return { score: -1, signal: 'DOWNTREND' };
        }
        return { score: 0, signal: 'SIDEWAY' };
      }

      generateSignal(analysis, currentPrice, latestIndicators) {
        const { totalScore, strength } = analysis;
        const atr = latestIndicators.atr;
        const reasons = [];

        let action = 'WAIT';
        let confidence = 0;

        if (totalScore >= 3) {
          action = 'LONG';
          confidence = Math.min(95, 50 + totalScore * 8);
          reasons.push(`Tổng điểm ${totalScore} - Xu hướng LONG mạnh`);
        } else if (totalScore <= -3) {
          action = 'SHORT';
          confidence = Math.min(95, 50 + Math.abs(totalScore) * 8);
          reasons.push(`Tổng điểm ${totalScore} - Xu hướng SHORT mạnh`);
        } else {
          reasons.push('Tín hiệu chưa rõ ràng, chờ đợi');
        }

        // Add indicator reasons
        if (latestIndicators.rsi < 30) reasons.push('RSI quá bán (< 30)');
        else if (latestIndicators.rsi > 70) reasons.push('RSI quá mua (> 70)');

        if (latestIndicators.macdHistogram > 0) reasons.push('MACD Histogram dương');
        else if (latestIndicators.macdHistogram < 0) reasons.push('MACD Histogram âm');

        if (currentPrice > latestIndicators.ema50) reasons.push('Giá trên EMA50 - Uptrend');
        else reasons.push('Giá dưới EMA50 - Downtrend');

        // Calculate SL/TP
        const atrMultiplier = this.config.atrMultiplier;
        const rrRatio = this.config.riskRewardRatio;

        let stopLoss, takeProfit, leverage, leverageRisk;

        if (action === 'LONG') {
          stopLoss = (currentPrice - atr * atrMultiplier).toFixed(currentPrice > 100 ? 2 : 6);
          takeProfit = (currentPrice + atr * atrMultiplier * rrRatio).toFixed(currentPrice > 100 ? 2 : 6);
        } else if (action === 'SHORT') {
          stopLoss = (currentPrice + atr * atrMultiplier).toFixed(currentPrice > 100 ? 2 : 6);
          takeProfit = (currentPrice - atr * atrMultiplier * rrRatio).toFixed(currentPrice > 100 ? 2 : 6);
        }

        // Calculate leverage based on signal strength
        const slPercent = Math.abs((currentPrice - parseFloat(stopLoss)) / currentPrice * 100);
        if (slPercent > 5) { leverage = 3; leverageRisk = 'SAFE'; }
        else if (slPercent > 3) { leverage = 5; leverageRisk = 'LOW'; }
        else if (slPercent > 2) { leverage = 10; leverageRisk = 'MEDIUM'; }
        else { leverage = 20; leverageRisk = 'HIGH'; }

        // Adjust leverage based on confidence
        if (confidence < 60) leverage = Math.max(3, Math.floor(leverage * 0.5));

        const atrPercent = ((atr / currentPrice) * 100).toFixed(2);

        return {
          action,
          confidence: confidence + '%',
          totalScore,
          averageScore: (totalScore / 5).toFixed(2),
          strength,
          entry: currentPrice,
          stopLoss,
          takeProfit,
          riskPercent: `-${slPercent.toFixed(2)}%`,
          rewardPercent: `+${(slPercent * rrRatio).toFixed(2)}%`,
          riskReward: rrRatio,
          leverage,
          leverageRisk,
          atr: atr ? atr.toFixed(currentPrice > 100 ? 2 : 6) : 'N/A',
          atrPercent: atrPercent + '%',
          reasons
        };
      }
    }

    const clientSignalEngine = new ClientSignalEngine();

    // Danh sách tất cả coin trên Binance Futures (150+ coins)
    const ALL_SYMBOLS = [
      // Top coins
      'BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'XRPUSDT', 'SOLUSDT', 'ADAUSDT',
      'DOGEUSDT', 'TRXUSDT', 'DOTUSDT', 'LINKUSDT', 'AVAXUSDT', 'MATICUSDT',
      'LTCUSDT', 'BCHUSDT', 'XLMUSDT', 'ATOMUSDT', 'UNIUSDT', 'ETCUSDT',

      // Layer 1 & Layer 2
      'APTUSDT', 'ARBUSDT', 'OPUSDT', 'SUIUSDT', 'SEIUSDT', 'NEARUSDT',
      'FTMUSDT', 'ALGOUSDT', 'ICPUSDT', 'VETUSDT', 'HBARUSDT', 'QNTUSDT',
      'INJUSDT', 'TIAUSDT', 'STXUSDT', 'MANTAUSDT', 'BLURUSDT', 'STRKUSDT',
      'ZKUSDT', 'SCROLLUSDT', 'EIGENUSDT',

      // DeFi
      'AAVEUSDT', 'MKRUSDT', 'COMPUSDT', 'SNXUSDT', 'CRVUSDT', 'LDOUSDT',
      'GMXUSDT', 'DYDXUSDT', 'PENDLEUSDT', 'JUPUSDT', 'RAYDIUMUSDT',
      '1INCHUSDT', 'SUSHIUSDT', 'YFIUSDT', 'BALUSDT', 'ZABORUSDT',

      // Gaming & Metaverse
      'SANDUSDT', 'MANAUSDT', 'AXSUSDT', 'GALAUSDT', 'ENJUSDT', 'IMXUSDT',
      'ILVUSDT', 'MAGICUSDT', 'GMTUSDT', 'LOOKSUSDT', 'HIGHUSDT', 'ACEUSDT',
      'PIXELUSDT', 'PORTALUSDT', 'XABORUSDT', 'RONUSDT',

      // AI & Data
      'RNDRUSDT', 'FETUSDT', 'AGIXUSDT', 'OCEANUSDT', 'ARKMUSDT', 'WLDUSDT',
      'TAOUSDT', 'AIUSDT', 'NFPUSDT', 'ALTUSDT',

      // Meme coins
      'PEPEUSDT', 'SHIBUSDT', 'FLOKIUSDT', 'BONKUSDT', 'WIFUSDT', 'MEMEUSDT',
      'BOMEUSDT', 'PEOPLEUSDT', 'LUNCUSDT', 'NEIROUSDT', 'TURBOFLOKIUSDT',
      '1000PEPEUSDT', '1000SHIBUSDT', '1000FLOKIUSDT', '1000BONKUSDT',
      '1000LUNCUSDT', 'DOGEUSDT', 'BABYDOGEUSDT',

      // Storage & Infrastructure
      'FILUSDT', 'ARUSDT', 'STORJUSDT', 'SCUSDT', 'ABORUSDT',

      // Oracle & Cross-chain
      'BANDUSDT', 'APIUSDT', 'CELRUSDT', 'RENUSDT', 'COTIUSDT',

      // Exchange tokens
      'BNBUSDT', 'FTMUSDT', 'CAKEUSDT', 'OOKIUSDT',

      // Privacy coins
      'XMRUSDT', 'ZECUSDT', 'DASHUSDT',

      // New & Trending
      'ORDIUSDT', 'KASUSDT', 'RUNEUSDT', 'ENAUSDT', 'WUSDT', 'TONUSDT',
      'NOTUSDT', 'DOGSUSDT', 'CATIUSDT', 'HMSTRUSDT', 'SCRUSDT',
      'MOVEUSDT', 'MEUSDT', 'VANAUSDT', 'PENGUUSDT', 'USUALUSDT',

      // Others
      'GRTUSDT', 'CHZUSDT', 'APEUSDT', 'LRCUSDT', 'RSRUSDT', 'KAVAUSDT',
      'IOSTUSDT', 'ZILUSDT', 'ONTUSDT', 'IOTAUSDT', 'NEOUSDT', 'WAVESUSDT',
      'EOSUSDT', 'XTZUSDT', 'THETAUSDT', 'EGLDUSDT', 'FLOWUSDT', 'MINAUSDT',
      'CFXUSDT', 'ACHUSDT', 'ANKRUSDT', 'SKLUSDT', 'WOOUSDT', 'AGLDUSDT',
      'MASKUSDT', 'ENSUSDT', 'SSUSDT', 'BICOUSDT', 'TUSDT', 'EDUUSDT',
      'IDUSDT', 'RDNTUSDT', 'MAVUSDT', 'XVSUSDT', 'UMAUSDT', 'LEVERUSDT',
      'KEYUSDT', 'COMBOUSDT', 'NMRUSDT', 'MDTUSDT', 'XEMUSDT', 'BELUSDT',
      'LITUSDT', 'CKBUSDT', 'PERPUSDT', 'TRUUSDT', 'LQTYUSDT', 'UXLINKUSDT'
    ];

    // Symbol search functions
    function showSymbolList() {
      filterSymbols();
      document.getElementById('symbolList').style.display = 'block';
    }

    function hideSymbolList() {
      setTimeout(() => {
        document.getElementById('symbolList').style.display = 'none';
      }, 200);
    }

    function filterSymbols() {
      const search = document.getElementById('symbolSearch').value.toUpperCase();
      const list = document.getElementById('symbolList');

      // Nếu chưa gõ gì, hiển thị tất cả (có scroll), nếu có search thì filter
      const filtered = search
        ? ALL_SYMBOLS.filter(s => s.includes(search))
        : ALL_SYMBOLS;

      if (filtered.length === 0) {
        list.innerHTML = '<div class="symbol-dropdown-item"><span>Không tìm thấy</span></div>';
      } else {
        list.innerHTML = filtered.map(s => {
          const coin = s.replace('USDT', '');
          return `
            <div class="symbol-dropdown-item" onclick="selectCoin('${s}')">
              <span class="coin-name">${coin}</span>
              <span class="coin-pair">${s}</span>
            </div>
          `;
        }).join('');
      }

      list.style.display = 'block';
    }

    function selectCoin(symbol) {
      document.getElementById('symbol').value = symbol;
      document.getElementById('symbolSearch').value = '';
      document.getElementById('selectedSymbol').textContent = symbol.replace('USDT', '/USDT');
      document.getElementById('symbolList').style.display = 'none';
      analyzeSignal();
    }

    // Click outside to close dropdown
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.control-group')) {
        document.getElementById('symbolList').style.display = 'none';
      }
    });

    // Tab switching
    function switchTab(tab) {
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('[id$="-tab"]').forEach(t => t.style.display = 'none');

      event.target.classList.add('active');
      document.getElementById(tab + '-tab').style.display = 'block';
    }

    // Single symbol analysis
    async function analyzeSignal() {
      const symbol = document.getElementById('symbol').value;
      const interval = document.getElementById('interval').value;
      const market = document.getElementById('market').value;
      const btn = document.getElementById('analyzeBtn');
      const resultDiv = document.getElementById('signal-result');

      btn.disabled = true;
      btn.textContent = 'Đang phân tích...';
      resultDiv.innerHTML = '<div class="loading">Đang phân tích</div>';

      try {
        let data;

        if (IS_CLOUDFLARE) {
          // Client-side analysis for Cloudflare (bypass Binance IP block)
          console.log('[Cloudflare Mode] Fetching directly from Binance...');
          const candles = await fetchBinanceKlines(symbol, interval, 100);
          const result = clientSignalEngine.analyze(candles);
          result.symbol = symbol.toUpperCase();
          result.interval = interval;
          result.market = market;
          data = { success: true, data: result };
        } else {
          // Server-side analysis for local/VPS
          const response = await fetch(`${API_BASE}/api/signal/${symbol}?interval=${interval}&market=${market}`);
          data = await response.json();
        }

        if (data.success) {
          renderSignal(data.data);
        } else {
          resultDiv.innerHTML = `<div class="signal-card"><p style="color: #ff5252;">Lỗi: ${data.error}</p></div>`;
        }
      } catch (error) {
        resultDiv.innerHTML = `<div class="signal-card"><p style="color: #ff5252;">Lỗi kết nối: ${error.message}</p></div>`;
      }

      btn.disabled = false;
      btn.textContent = 'Phân tích';
    }

    // Render signal result
    function renderSignal(data) {
      const { signal, indicators, analysis, currentPrice, symbol, interval } = data;

      const signalClass = signal.action === 'LONG' ? 'signal-long' :
                         signal.action === 'SHORT' ? 'signal-short' : 'signal-wait';

      const html = `
        <div class="signal-card">
          <div class="signal-header">
            <div class="symbol-info">
              <span class="symbol-name">${symbol}</span>
              <span class="price">$${currentPrice.toLocaleString()}</span>
              <span style="color: #888; font-size: 0.9em;">${interval}</span>
            </div>
            <div class="signal-badge ${signalClass}">
              ${signal.action} ${signal.action !== 'WAIT' ? `(${signal.confidence})` : ''}
            </div>
          </div>

          <div class="indicators-grid">
            <div class="indicator-box">
              <h4>RSI (14)</h4>
              <div class="value ${analysis.rsi.score > 0 ? 'bullish' : analysis.rsi.score < 0 ? 'bearish' : 'neutral'}">
                ${indicators.rsi.current ? indicators.rsi.current.toFixed(2) : 'N/A'}
              </div>
              <div class="status">${analysis.rsi.signal}</div>
            </div>

            <div class="indicator-box">
              <h4>MACD</h4>
              <div class="value ${analysis.macd.score > 0 ? 'bullish' : analysis.macd.score < 0 ? 'bearish' : 'neutral'}">
                ${indicators.macd.histogram ? indicators.macd.histogram.toFixed(4) : 'N/A'}
              </div>
              <div class="status">${analysis.macd.signal}</div>
            </div>

            <div class="indicator-box">
              <h4>EMA (9/21/50)</h4>
              <div class="value ${analysis.ema.score > 0 ? 'bullish' : analysis.ema.score < 0 ? 'bearish' : 'neutral'}">
                ${analysis.ema.signal}
              </div>
              <div class="status">${analysis.trend.signal}</div>
            </div>

            <div class="indicator-box">
              <h4>Bollinger Bands</h4>
              <div class="value ${analysis.bb.score > 0 ? 'bullish' : analysis.bb.score < 0 ? 'bearish' : 'neutral'}">
                ${analysis.bb.pricePosition}%
              </div>
              <div class="status">${analysis.bb.signal}</div>
            </div>

            <div class="indicator-box">
              <h4>ATR (14)</h4>
              <div class="value neutral">
                ${signal.atr || 'N/A'}
              </div>
              <div class="status">Volatility</div>
            </div>

            <div class="indicator-box">
              <h4>Tổng điểm</h4>
              <div class="value ${signal.totalScore > 0 ? 'bullish' : signal.totalScore < 0 ? 'bearish' : 'neutral'}">
                ${signal.totalScore} (${signal.averageScore})
              </div>
              <div class="status">${signal.strength}</div>
            </div>
          </div>

          ${signal.action !== 'WAIT' ? `
          <div class="trade-setup">
            <div class="trade-item">
              <label>Entry Price</label>
              <div class="value entry">$${signal.entry.toLocaleString()}</div>
            </div>
            <div class="trade-item">
              <label>Stop Loss</label>
              <div class="value stop-loss">$${parseFloat(signal.stopLoss).toLocaleString()}</div>
              <div style="color: #ff5252; font-size: 0.85em;">${signal.riskPercent}</div>
            </div>
            <div class="trade-item">
              <label>Take Profit</label>
              <div class="value take-profit">$${parseFloat(signal.takeProfit).toLocaleString()}</div>
              <div style="color: #00ff88; font-size: 0.85em;">${signal.rewardPercent}</div>
            </div>
            <div class="trade-item">
              <label>Risk/Reward</label>
              <div class="value neutral">1:${signal.riskReward}</div>
            </div>
            <div class="trade-item">
              <label>Đòn bẩy gợi ý</label>
              <div class="value" style="color: ${signal.leverageRisk === 'SAFE' ? '#00ff88' : signal.leverageRisk === 'LOW' ? '#00d9ff' : '#ffd700'}; font-size: 1.5em;">
                ${signal.leverage}x
              </div>
              <div style="font-size: 0.85em; color: ${signal.leverageRisk === 'SAFE' ? '#00ff88' : signal.leverageRisk === 'LOW' ? '#00d9ff' : '#ffd700'};">
                ${signal.leverageRisk === 'SAFE' ? 'An toàn' : signal.leverageRisk === 'LOW' ? 'Rủi ro thấp' : 'Rủi ro TB'}
              </div>
            </div>
            <div class="trade-item">
              <label>ATR %</label>
              <div class="value neutral">${signal.atrPercent || 'N/A'}</div>
              <div style="font-size: 0.85em; color: #888;">Volatility</div>
            </div>
          </div>
          ` : ''}

          <div class="reasons">
            <h4>Lý do ${signal.action === 'WAIT' ? 'chờ đợi' : signal.action}</h4>
            <ul>
              ${signal.reasons.map(r => `<li>${r}</li>`).join('')}
            </ul>
          </div>

          ${signal.action !== 'WAIT' ? `
          <div class="order-entry">
            <h4>Mở lệnh ${signal.action}</h4>
            <div class="order-grid">
              <div>
                <label style="display: block; margin-bottom: 5px; color: #888; font-size: 0.85em;">Margin (USDT)</label>
                <input type="number" id="order-margin" placeholder="VD: 5, 10, 50..." value="10" min="1" step="1">
              </div>
              <div>
                <label style="display: block; margin-bottom: 5px; color: #888; font-size: 0.85em;">Giá vào</label>
                <input type="number" id="order-entry" value="${signal.entry}" step="0.01">
              </div>
              <div>
                <label style="display: block; margin-bottom: 5px; color: #888; font-size: 0.85em;">Leverage</label>
                <input type="number" id="order-leverage" value="${signal.leverage}" min="1" max="125">
              </div>
              <div>
                <label style="display: block; margin-bottom: 5px; color: #888; font-size: 0.85em;">Stop Loss</label>
                <input type="number" id="order-sl" value="${signal.stopLoss}" step="0.01">
              </div>
              <div>
                <label style="display: block; margin-bottom: 5px; color: #888; font-size: 0.85em;">Take Profit</label>
                <input type="number" id="order-tp" value="${signal.takeProfit}" step="0.01">
              </div>
            </div>
            <div class="order-buttons">
              <button class="btn-long" onclick="openPosition('LONG')">Mở LONG</button>
              <button class="btn-short" onclick="openPosition('SHORT')">Mở SHORT</button>
            </div>
          </div>
          ` : ''}
        </div>
      `;

      document.getElementById('signal-result').innerHTML = html;

      // Store current signal data for opening positions
      currentSignalData = data;

      // Auto-fill calculator
      if (signal.action !== 'WAIT') {
        document.getElementById('entry').value = signal.entry;
        document.getElementById('sl').value = signal.stopLoss;
      }
    }

    // Scan multiple symbols
    async function scanSignals() {
      const interval = document.getElementById('multi-interval').value;
      const btn = document.getElementById('scanBtn');
      const resultDiv = document.getElementById('multi-result');

      btn.disabled = true;
      btn.textContent = 'Đang quét...';
      resultDiv.innerHTML = '<div class="loading">Đang quét tín hiệu</div>';

      try {
        let data;

        if (IS_CLOUDFLARE) {
          // Client-side scan for Cloudflare
          console.log('[Cloudflare Mode] Scanning symbols from browser...');
          const topSymbols = ['BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'SOLUSDT', 'XRPUSDT'];
          const results = [];

          for (const symbol of topSymbols) {
            try {
              const candles = await fetchBinanceKlines(symbol, interval, 100);
              const result = clientSignalEngine.analyze(candles);
              result.symbol = symbol;
              result.interval = interval;
              results.push(result);
              // Small delay to avoid rate limit
              await new Promise(resolve => setTimeout(resolve, 100));
            } catch (err) {
              console.error(`Error scanning ${symbol}:`, err);
              results.push({ symbol, error: err.message });
            }
          }

          data = { success: true, data: results };
        } else {
          // Server-side scan for local/VPS
          const response = await fetch(`${API_BASE}/api/signals?interval=${interval}`);
          data = await response.json();
        }

        if (data.success) {
          renderMultiSignals(data.data);
        } else {
          resultDiv.innerHTML = `<div class="signal-card"><p style="color: #ff5252;">Lỗi: ${data.error}</p></div>`;
        }
      } catch (error) {
        resultDiv.innerHTML = `<div class="signal-card"><p style="color: #ff5252;">Lỗi kết nối: ${error.message}</p></div>`;
      }

      btn.disabled = false;
      btn.textContent = 'Quét tất cả';
    }

    // Render multiple signals
    function renderMultiSignals(signals) {
      // Sort by signal strength
      signals.sort((a, b) => {
        if (a.signal && b.signal) {
          return Math.abs(b.signal.totalScore) - Math.abs(a.signal.totalScore);
        }
        return 0;
      });

      const html = signals.map(s => {
        if (s.error) {
          return `<div class="mini-signal"><span class="symbol">${s.symbol}</span><span style="color: #ff5252;">Error</span></div>`;
        }

        const signalClass = s.signal.action === 'LONG' ? 'signal-long' :
                           s.signal.action === 'SHORT' ? 'signal-short' : 'signal-wait';

        const confidence = parseFloat(s.signal.confidence) || 0;

        return `
          <div class="mini-signal" onclick="selectSymbol('${s.symbol}')">
            <div>
              <div class="symbol">${s.symbol}</div>
              <div class="price-info">$${s.currentPrice.toLocaleString()}</div>
            </div>
            <div>
              <div style="color: #888; font-size: 0.85em;">Score: ${s.signal.totalScore} | ${s.signal.strength}</div>
              <div class="confidence-bar">
                <div class="confidence-fill" style="width: ${confidence}%; background: ${s.signal.action === 'LONG' ? '#00ff88' : s.signal.action === 'SHORT' ? '#ff5252' : '#888'};"></div>
              </div>
            </div>
            <div class="mini-badge ${signalClass}">${s.signal.action}</div>
          </div>
        `;
      }).join('');

      document.getElementById('multi-result').innerHTML = html;
    }

    // Select symbol from multi scan
    function selectSymbol(symbol) {
      document.getElementById('symbol').value = symbol;
      switchTab('single');
      document.querySelector('.tab').click();
      analyzeSignal();
    }

    // Position calculator
    async function calculatePosition() {
      const balance = parseFloat(document.getElementById('balance').value);
      const risk = parseFloat(document.getElementById('risk').value);
      const entry = parseFloat(document.getElementById('entry').value);
      const sl = parseFloat(document.getElementById('sl').value);
      const leverage = parseInt(document.getElementById('leverage').value);

      if (!balance || !entry || !sl) {
        alert('Vui lòng điền đầy đủ thông tin!');
        return;
      }

      try {
        const response = await fetch(`${API_BASE}/api/calculate-position`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            accountBalance: balance,
            riskPercent: risk,
            entryPrice: entry,
            stopLoss: sl,
            leverage: leverage
          })
        });

        const data = await response.json();

        if (data.success) {
          const r = data.data;
          document.getElementById('calc-result').style.display = 'grid';
          document.getElementById('calc-result').innerHTML = `
            <div class="trade-item">
              <label>Số tiền rủi ro</label>
              <div class="value stop-loss">$${r.riskAmount}</div>
            </div>
            <div class="trade-item">
              <label>% Stop Loss</label>
              <div class="value stop-loss">${r.stopLossPercent}</div>
            </div>
            <div class="trade-item">
              <label>Position Size</label>
              <div class="value entry">$${r.positionSize}</div>
            </div>
            <div class="trade-item">
              <label>Số lượng coin</label>
              <div class="value neutral">${r.quantity}</div>
            </div>
            <div class="trade-item">
              <label>Margin cần (${r.leverage})</label>
              <div class="value take-profit">$${r.marginRequired}</div>
            </div>
          `;
        }
      } catch (error) {
        alert('Lỗi tính toán: ' + error.message);
      }
    }

    // ===================== POSITION TRACKING =====================

    // Load positions from localStorage
    let openPositions = JSON.parse(localStorage.getItem('openPositions') || '[]');
    let closedPositions = JSON.parse(localStorage.getItem('closedPositions') || '[]');
    let currentSignalData = null;

    // Save positions to localStorage
    function savePositions() {
      localStorage.setItem('openPositions', JSON.stringify(openPositions));
      localStorage.setItem('closedPositions', JSON.stringify(closedPositions));
      updateOpenCount();
    }

    // Update open count in tab
    function updateOpenCount() {
      document.getElementById('open-count').textContent = openPositions.length;
    }

    // Open a new position
    function openPosition(type) {
      if (!currentSignalData) {
        showToast({
          type: 'error',
          title: 'Lỗi',
          message: 'Vui lòng phân tích coin trước!'
        });
        return;
      }

      const margin = parseFloat(document.getElementById('order-margin').value);
      const entryPrice = parseFloat(document.getElementById('order-entry').value);
      const leverage = parseInt(document.getElementById('order-leverage').value);
      const sl = parseFloat(document.getElementById('order-sl').value);
      const tp = parseFloat(document.getElementById('order-tp').value);

      if (!margin || margin <= 0) {
        showToast({
          type: 'error',
          title: 'Lỗi',
          message: 'Vui lòng nhập số USDT margin!'
        });
        return;
      }

      const position = {
        id: Date.now(),
        symbol: currentSignalData.symbol,
        type: type, // 'LONG' or 'SHORT'
        margin: margin,
        leverage: leverage,
        entryPrice: entryPrice,
        stopLoss: sl,
        takeProfit: tp,
        quantity: (margin * leverage) / entryPrice,
        positionSize: margin * leverage,
        openTime: new Date().toISOString(),
        status: 'OPEN'
      };

      openPositions.push(position);
      savePositions();
      renderOpenPositions();

      // Calculate potential loss/profit for display
      let slLoss = 0, tpProfit = 0;
      if (sl && entryPrice && position.quantity) {
        if (type === 'LONG') {
          slLoss = (sl - entryPrice) * position.quantity;
          tpProfit = tp ? (tp - entryPrice) * position.quantity : 0;
        } else {
          slLoss = (entryPrice - sl) * position.quantity;
          tpProfit = tp ? (entryPrice - tp) * position.quantity : 0;
        }
      }

      showToast({
        type: 'success',
        title: `${type === 'LONG' ? '&#128994;' : '&#128308;'} Mở lệnh ${type} thành công!`,
        details: [
          { label: 'Symbol', value: currentSignalData.symbol, class: type.toLowerCase() },
          { label: 'Entry', value: '$' + entryPrice.toLocaleString() },
          { label: 'Margin', value: margin + ' USDT' },
          { label: 'Leverage', value: leverage + 'x' },
          { label: 'Size', value: '$' + position.positionSize.toLocaleString() },
          { label: 'Stop Loss', value: sl ? '$' + sl.toLocaleString() + ` (${slLoss.toFixed(2)}$)` : 'N/A' },
          { label: 'Take Profit', value: tp ? '$' + tp.toLocaleString() + ` (+${tpProfit.toFixed(2)}$)` : 'N/A' }
        ],
        duration: 5000
      });
    }

    // Close a position
    async function closePosition(id, closePrice = null) {
      const index = openPositions.findIndex(p => p.id === id);
      if (index === -1) return;

      const position = openPositions[index];

      if (!closePrice) {
        const result = await showPrompt(
          'Đóng lệnh ' + position.symbol,
          `Loại: <strong style="color: ${position.type === 'LONG' ? '#00ff88' : '#ff5252'}">${position.type}</strong><br>Entry: <strong>$${position.entryPrice.toLocaleString()}</strong>`,
          'Nhập giá đóng lệnh:',
          position.entryPrice
        );

        if (!result.confirmed || !result.value) return;
        closePrice = result.value;
      }

      // Calculate P/L
      let pnl;
      if (position.type === 'LONG') {
        pnl = (closePrice - position.entryPrice) * position.quantity;
      } else {
        pnl = (position.entryPrice - closePrice) * position.quantity;
      }

      const pnlPercent = (pnl / position.margin) * 100;

      // Move to closed positions
      const closedPosition = {
        ...position,
        closePrice: closePrice,
        closeTime: new Date().toISOString(),
        pnl: pnl,
        pnlPercent: pnlPercent,
        status: pnl >= 0 ? 'WIN' : 'LOSS'
      };

      closedPositions.unshift(closedPosition);
      openPositions.splice(index, 1);
      savePositions();
      renderOpenPositions();
      renderClosedPositions();
      updateStats();

      // Show result toast
      showToast({
        type: pnl >= 0 ? 'success' : 'error',
        title: pnl >= 0 ? '&#127881; Đóng lệnh thắng!' : '&#128532; Đóng lệnh thua',
        details: [
          { label: 'Symbol', value: position.symbol },
          { label: 'Loại', value: position.type, class: position.type.toLowerCase() },
          { label: 'Entry', value: '$' + position.entryPrice.toLocaleString() },
          { label: 'Đóng tại', value: '$' + closePrice.toLocaleString() },
          { label: 'P/L', value: (pnl >= 0 ? '+' : '') + pnl.toFixed(2) + '$ (' + (pnlPercent >= 0 ? '+' : '') + pnlPercent.toFixed(2) + '%)', class: pnl >= 0 ? 'long' : 'short' }
        ],
        duration: 5000
      });
    }

    // Delete a position (without closing)
    async function deletePosition(id) {
      const index = openPositions.findIndex(p => p.id === id);
      if (index === -1) return;

      const position = openPositions[index];

      const result = await showConfirm(
        'Xóa lệnh',
        `Bạn có chắc muốn xóa lệnh <strong>${position.symbol}</strong> khỏi danh sách?<br><br><small style="color: #888;">Lệnh sẽ bị xóa và không được lưu vào lịch sử.</small>`,
        true
      );

      if (!result.confirmed) return;

      openPositions.splice(index, 1);
      savePositions();
      renderOpenPositions();

      showToast({
        type: 'info',
        title: 'Đã xóa lệnh',
        message: `Lệnh ${position.type} ${position.symbol} đã được xóa khỏi danh sách.`,
        duration: 3000
      });
    }

    // Delete closed position from history
    async function deleteClosedPosition(id) {
      const index = closedPositions.findIndex(p => p.id === id);
      if (index === -1) return;

      const position = closedPositions[index];

      const result = await showConfirm(
        'Xóa khỏi lịch sử',
        `Xóa lệnh <strong>${position.symbol}</strong> khỏi lịch sử giao dịch?`,
        true
      );

      if (!result.confirmed) return;

      closedPositions.splice(index, 1);
      savePositions();
      renderClosedPositions();
      updateStats();

      showToast({
        type: 'info',
        title: 'Đã xóa',
        message: `Đã xóa lệnh ${position.symbol} khỏi lịch sử.`,
        duration: 3000
      });
    }

    // Copy position info to clipboard
    function copyPosition(id) {
      const position = openPositions.find(p => p.id === id);
      if (!position) return;

      // Calculate SL loss and TP profit
      let slLoss = 0, tpProfit = 0;
      if (position.stopLoss && position.entryPrice && position.quantity) {
        if (position.type === 'LONG') {
          slLoss = (position.stopLoss - position.entryPrice) * position.quantity;
          tpProfit = position.takeProfit ? (position.takeProfit - position.entryPrice) * position.quantity : 0;
        } else {
          slLoss = (position.entryPrice - position.stopLoss) * position.quantity;
          tpProfit = position.takeProfit ? (position.entryPrice - position.takeProfit) * position.quantity : 0;
        }
      }

      const text = `📊 ${position.symbol} - ${position.type}
━━━━━━━━━━━━━━━━━━
💰 Margin: ${position.margin.toFixed(2)} USDT
⚡ Leverage: ${position.leverage}x
📈 Size: $${position.positionSize.toLocaleString()}
━━━━━━━━━━━━━━━━━━
🛑 Stop Loss: $${position.stopLoss ? position.stopLoss.toLocaleString() : 'N/A'}
✅ Take Profit: $${position.takeProfit ? position.takeProfit.toLocaleString() : 'N/A'}`;

      navigator.clipboard.writeText(text).then(() => {
        showToast({
          type: 'success',
          title: 'Đã copy!',
          message: `Thông tin lệnh ${position.symbol} đã được copy vào clipboard.`,
          duration: 2000
        });
      }).catch(err => {
        showToast({
          type: 'error',
          title: 'Lỗi',
          message: 'Không thể copy. Vui lòng thử lại.',
          duration: 3000
        });
      });
    }

    // Render open positions
    function renderOpenPositions() {
      const container = document.getElementById('open-positions');

      if (openPositions.length === 0) {
        container.innerHTML = '<div class="no-positions">Chưa có lệnh nào đang mở</div>';
        document.getElementById('total-open').textContent = '0';
        document.getElementById('total-unrealized-pnl').textContent = '$0.00';
        document.getElementById('total-margin').textContent = '$0.00';
        return;
      }

      container.innerHTML = openPositions.map(p => {
        // Calculate estimated SL loss and TP profit
        let slLoss = 0, tpProfit = 0;
        if (p.stopLoss && p.entryPrice && p.quantity) {
          if (p.type === 'LONG') {
            slLoss = (p.stopLoss - p.entryPrice) * p.quantity;
            tpProfit = p.takeProfit ? (p.takeProfit - p.entryPrice) * p.quantity : 0;
          } else {
            slLoss = (p.entryPrice - p.stopLoss) * p.quantity;
            tpProfit = p.takeProfit ? (p.entryPrice - p.takeProfit) * p.quantity : 0;
          }
        }

        return `
        <div class="position-card ${p.type.toLowerCase()}" data-symbol="${p.symbol}" data-id="${p.id}">
          <div class="position-header">
            <div>
              <span class="position-symbol">${p.symbol}</span>
              <span class="signal-badge signal-${p.type.toLowerCase()}" style="font-size: 0.8em; padding: 3px 10px;">${p.type}</span>
            </div>
            <div class="position-pnl" id="pnl-${p.id}">Đang tải...</div>
          </div>
          <div class="position-details">
            <div>
              <span class="label">Margin</span>
              <span class="value">${p.margin.toFixed(2)} USDT</span>
            </div>
            <div>
              <span class="label">Leverage</span>
              <span class="value">${p.leverage}x</span>
            </div>
            <div>
              <span class="label">Entry</span>
              <span class="value">$${p.entryPrice.toLocaleString()}</span>
            </div>
            <div>
              <span class="label">Giá hiện tại</span>
              <span class="value" id="current-price-${p.id}">...</span>
            </div>
            <div>
              <span class="label">Stop Loss</span>
              <span class="value stop-loss">$${p.stopLoss ? p.stopLoss.toLocaleString() : 'N/A'} ${slLoss ? `<span style="font-size:0.85em">(${slLoss.toFixed(2)}$)</span>` : ''}</span>
            </div>
            <div>
              <span class="label">Take Profit</span>
              <span class="value take-profit">$${p.takeProfit ? p.takeProfit.toLocaleString() : 'N/A'} ${tpProfit ? `<span style="font-size:0.85em">(+${tpProfit.toFixed(2)}$)</span>` : ''}</span>
            </div>
          </div>
          <div class="position-actions">
            <button class="btn-copy" onclick="copyPosition(${p.id})">📋 Copy</button>
            <button class="btn-close-profit" onclick="closePosition(${p.id})">Đóng lệnh</button>
            <button class="btn-delete" onclick="deletePosition(${p.id})">Xóa</button>
          </div>
        </div>
      `}).join('');

      // Update P/L for all positions
      updateAllPositionsPnL();
    }

    // Render closed positions
    function renderClosedPositions() {
      const container = document.getElementById('closed-positions');

      if (closedPositions.length === 0) {
        container.innerHTML = '<div class="no-positions">Chưa có lịch sử giao dịch</div>';
        return;
      }

      container.innerHTML = closedPositions.map(p => {
        // Calculate estimated SL loss and TP profit (from original position)
        let slLoss = 0, tpProfit = 0;
        if (p.stopLoss && p.entryPrice && p.quantity) {
          if (p.type === 'LONG') {
            slLoss = (p.stopLoss - p.entryPrice) * p.quantity;
            tpProfit = p.takeProfit ? (p.takeProfit - p.entryPrice) * p.quantity : 0;
          } else {
            slLoss = (p.entryPrice - p.stopLoss) * p.quantity;
            tpProfit = p.takeProfit ? (p.entryPrice - p.takeProfit) * p.quantity : 0;
          }
        }

        return `
        <div class="position-card ${p.type.toLowerCase()} ${p.pnl >= 0 ? 'profit' : 'loss'}">
          <div class="position-header">
            <div>
              <span class="position-symbol">${p.symbol}</span>
              <span class="signal-badge signal-${p.type.toLowerCase()}" style="font-size: 0.8em; padding: 3px 10px;">${p.type}</span>
              <span style="color: ${p.pnl >= 0 ? '#00ff88' : '#ff5252'}; font-size: 0.85em; margin-left: 10px;">${p.status}</span>
            </div>
            <div class="position-pnl ${p.pnl >= 0 ? 'profit' : 'loss'}">
              ${p.pnl >= 0 ? '+' : ''}$${p.pnl.toFixed(2)} (${p.pnlPercent >= 0 ? '+' : ''}${p.pnlPercent.toFixed(1)}%)
            </div>
          </div>
          <div class="position-details">
            <div>
              <span class="label">Margin</span>
              <span class="value">${p.margin.toFixed(2)} USDT</span>
            </div>
            <div>
              <span class="label">Leverage</span>
              <span class="value">${p.leverage}x</span>
            </div>
            <div>
              <span class="label">Entry</span>
              <span class="value">$${p.entryPrice.toLocaleString()}</span>
            </div>
            <div>
              <span class="label">Đóng tại</span>
              <span class="value">$${p.closePrice.toLocaleString()}</span>
            </div>
            <div>
              <span class="label">Stop Loss</span>
              <span class="value stop-loss">$${p.stopLoss ? p.stopLoss.toLocaleString() : 'N/A'} ${slLoss ? `<span style="font-size:0.85em">(${slLoss.toFixed(2)}$)</span>` : ''}</span>
            </div>
            <div>
              <span class="label">Take Profit</span>
              <span class="value take-profit">$${p.takeProfit ? p.takeProfit.toLocaleString() : 'N/A'} ${tpProfit ? `<span style="font-size:0.85em">(+${tpProfit.toFixed(2)}$)</span>` : ''}</span>
            </div>
          </div>
          <div class="position-actions">
            <button class="btn-delete" onclick="deleteClosedPosition(${p.id})">Xóa khỏi lịch sử</button>
          </div>
        </div>
      `}).join('');
    }

    // Update stats
    function updateStats() {
      const totalClosed = closedPositions.length;
      const totalPnL = closedPositions.reduce((sum, p) => sum + p.pnl, 0);
      const wins = closedPositions.filter(p => p.pnl >= 0).length;
      const losses = closedPositions.filter(p => p.pnl < 0).length;
      const winRate = totalClosed > 0 ? (wins / totalClosed * 100).toFixed(1) : 0;

      document.getElementById('total-closed').textContent = totalClosed;
      document.getElementById('total-pnl').textContent = `${totalPnL >= 0 ? '+' : ''}$${totalPnL.toFixed(2)}`;
      document.getElementById('total-pnl').style.color = totalPnL >= 0 ? '#00ff88' : '#ff5252';
      document.getElementById('win-rate').textContent = `${winRate}%`;
      document.getElementById('win-rate').style.color = winRate >= 50 ? '#00ff88' : '#ff5252';
      document.getElementById('win-loss').textContent = `${wins} / ${losses}`;
    }

    // Update P/L for all open positions
    async function updateAllPositionsPnL() {
      let totalUnrealizedPnL = 0;
      let totalMargin = 0;

      for (const position of openPositions) {
        try {
          let currentPrice;

          if (IS_CLOUDFLARE) {
            // Fetch price directly from Binance for Cloudflare
            const priceData = await fetchBinancePrice(position.symbol);
            currentPrice = priceData.price;
          } else {
            const response = await fetch(`${API_BASE}/api/price/${position.symbol}?market=futures`);
            const data = await response.json();
            if (!data.success) continue;
            currentPrice = data.data.price;
          }

          if (currentPrice) {
            let pnl;

            if (position.type === 'LONG') {
              pnl = (currentPrice - position.entryPrice) * position.quantity;
            } else {
              pnl = (position.entryPrice - currentPrice) * position.quantity;
            }

            const pnlPercent = (pnl / position.margin) * 100;
            totalUnrealizedPnL += pnl;
            totalMargin += position.margin;

            // Update UI
            const pnlEl = document.getElementById(`pnl-${position.id}`);
            const priceEl = document.getElementById(`current-price-${position.id}`);

            if (pnlEl) {
              pnlEl.textContent = `${pnl >= 0 ? '+' : ''}$${pnl.toFixed(2)} (${pnlPercent >= 0 ? '+' : ''}${pnlPercent.toFixed(1)}%)`;
              pnlEl.className = `position-pnl ${pnl >= 0 ? 'profit' : 'loss'}`;
            }

            if (priceEl) {
              priceEl.textContent = `$${currentPrice.toLocaleString()}`;
            }
          }
        } catch (e) {
          console.error(`Error fetching price for ${position.symbol}:`, e);
        }
      }

      // Update totals
      document.getElementById('total-open').textContent = openPositions.length;
      document.getElementById('total-unrealized-pnl').textContent = `${totalUnrealizedPnL >= 0 ? '+' : ''}$${totalUnrealizedPnL.toFixed(2)}`;
      document.getElementById('total-unrealized-pnl').style.color = totalUnrealizedPnL >= 0 ? '#00ff88' : '#ff5252';
      document.getElementById('total-margin').textContent = `$${totalMargin.toFixed(2)}`;
    }

    // Auto-refresh price and P/L
    setInterval(async () => {
      const symbol = document.getElementById('symbol').value;
      try {
        let price;

        if (IS_CLOUDFLARE) {
          const priceData = await fetchBinancePrice(symbol);
          price = priceData.price;
        } else {
          const response = await fetch(`${API_BASE}/api/price/${symbol}`);
          const data = await response.json();
          if (data.success) price = data.data.price;
        }

        if (price) {
          const priceEl = document.querySelector('.price');
          if (priceEl) {
            priceEl.textContent = '$' + price.toLocaleString();
          }
        }
      } catch (e) {}

      // Update open positions P/L
      if (openPositions.length > 0) {
        updateAllPositionsPnL();
      }
    }, 5000); // Update every 5 seconds

    // Initialize
    function initPositions() {
      updateOpenCount();
      renderOpenPositions();
      renderClosedPositions();
      updateStats();
    }

    // Initial analysis
    analyzeSignal();
    initPositions();
  </script>
</body>
</html>
