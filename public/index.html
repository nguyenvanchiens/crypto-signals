<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Trading Signal Bot - Futures Long/Short</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #fff;
      min-height: 100vh;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    header {
      text-align: center;
      padding: 30px 0;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      margin-bottom: 30px;
    }

    header h1 {
      font-size: 2.5em;
      background: linear-gradient(45deg, #00d9ff, #00ff88);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 10px;
    }

    header p {
      color: #888;
      font-size: 1.1em;
    }

    .controls {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      margin-bottom: 30px;
      padding: 20px;
      background: rgba(255,255,255,0.05);
      border-radius: 15px;
    }

    .control-group {
      flex: 1;
      min-width: 200px;
    }

    .control-group label {
      display: block;
      margin-bottom: 8px;
      color: #00d9ff;
      font-weight: 500;
    }

    select, input {
      width: 100%;
      padding: 12px 15px;
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 8px;
      background: #1a1a2e;
      color: #fff;
      font-size: 1em;
      cursor: pointer;
    }

    select option {
      background: #1a1a2e;
      color: #fff;
      padding: 10px;
    }

    select:focus, input:focus {
      outline: none;
      border-color: #00d9ff;
    }

    button {
      padding: 12px 30px;
      background: linear-gradient(45deg, #00d9ff, #00ff88);
      border: none;
      border-radius: 8px;
      color: #1a1a2e;
      font-size: 1em;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(0, 217, 255, 0.4);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .signal-card {
      background: rgba(255,255,255,0.05);
      border-radius: 15px;
      padding: 25px;
      margin-bottom: 20px;
      border: 1px solid rgba(255,255,255,0.1);
    }

    .signal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      flex-wrap: wrap;
      gap: 10px;
    }

    .symbol-info {
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .symbol-name {
      font-size: 1.8em;
      font-weight: bold;
    }

    .price {
      font-size: 1.5em;
      color: #00ff88;
    }

    .signal-badge {
      padding: 10px 25px;
      border-radius: 25px;
      font-weight: bold;
      font-size: 1.2em;
      text-transform: uppercase;
    }

    .signal-long {
      background: linear-gradient(135deg, #1a1a2e 0%, #1a2e1f 100%);
      border: 1px solid #00ff8840;
      color: #fff;
    }

    .signal-short {
      background: linear-gradient(135deg, #1a1a2e 0%, #2d1f3d 100%);
      border: 1px solid #e040fb40;
      color: #fff;
    }

    .signal-wait {
      background: rgba(255,255,255,0.2);
      color: #fff;
    }

    .indicators-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }

    .indicator-box {
      background: rgba(0,0,0,0.3);
      padding: 15px;
      border-radius: 10px;
    }

    .indicator-box h4 {
      color: #888;
      font-size: 0.85em;
      text-transform: uppercase;
      margin-bottom: 8px;
    }

    .indicator-box .value {
      font-size: 1.3em;
      font-weight: bold;
    }

    .indicator-box .status {
      font-size: 0.9em;
      margin-top: 5px;
    }

    .bullish { color: #00ff88; }
    .bearish { color: #e040fb; }
    .neutral { color: #ffd700; }

    .trade-setup {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
      padding: 20px;
      background: rgba(0,0,0,0.3);
      border-radius: 10px;
      margin-bottom: 20px;
    }

    .trade-item {
      text-align: center;
    }

    .trade-item label {
      display: block;
      color: #888;
      font-size: 0.85em;
      margin-bottom: 5px;
    }

    .trade-item .value {
      font-size: 1.2em;
      font-weight: bold;
    }

    .entry { color: #00d9ff; }
    .stop-loss { color: #ff5252; }
    .take-profit { color: #00ff88; }

    .reasons {
      background: rgba(0,0,0,0.3);
      padding: 15px;
      border-radius: 10px;
    }

    .reasons h4 {
      color: #00d9ff;
      margin-bottom: 10px;
    }

    .reasons ul {
      list-style: none;
      padding-left: 0;
    }

    .reasons li {
      padding: 8px 0;
      border-bottom: 1px solid rgba(255,255,255,0.05);
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .reasons li:before {
      content: "→";
      color: #00d9ff;
    }

    .reasons li:last-child {
      border-bottom: none;
    }

    .position-calculator {
      background: rgba(255,255,255,0.05);
      border-radius: 15px;
      padding: 25px;
      margin-top: 30px;
    }

    .position-calculator h3 {
      color: #00d9ff;
      margin-bottom: 20px;
    }

    .calc-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }

    .calc-result {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
      padding: 20px;
      background: rgba(0,0,0,0.3);
      border-radius: 10px;
    }

    .loading {
      text-align: center;
      padding: 50px;
      color: #888;
    }

    .loading::after {
      content: "";
      display: inline-block;
      width: 30px;
      height: 30px;
      border: 3px solid rgba(0, 217, 255, 0.3);
      border-top-color: #00d9ff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-left: 10px;
      vertical-align: middle;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .multi-signals {
      display: grid;
      gap: 15px;
    }

    .mini-signal {
      display: grid;
      grid-template-columns: 1fr 1fr auto;
      gap: 20px;
      align-items: center;
      background: rgba(255,255,255,0.05);
      padding: 15px 20px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.1);
    }

    .mini-signal:hover {
      border-color: #00d9ff;
      cursor: pointer;
    }

    .mini-signal .symbol {
      font-weight: bold;
      font-size: 1.1em;
    }

    .mini-signal .price-info {
      color: #888;
    }

    .mini-signal .mini-badge {
      padding: 5px 15px;
      border-radius: 15px;
      font-size: 0.9em;
      font-weight: bold;
    }

    .confidence-bar {
      height: 6px;
      background: rgba(255,255,255,0.1);
      border-radius: 3px;
      overflow: hidden;
    }

    /* Order Entry Form */
    .order-entry {
      background: rgba(0,217,255,0.1);
      border: 1px solid #00d9ff;
      border-radius: 10px;
      padding: 20px;
      margin-top: 15px;
    }

    .order-entry h4 {
      color: #00d9ff;
      margin-bottom: 15px;
    }

    .order-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 10px;
      margin-bottom: 15px;
    }

    .order-grid input {
      padding: 10px;
      font-size: 0.95em;
    }

    .order-buttons {
      display: flex;
      gap: 10px;
    }

    .order-buttons button {
      flex: 1;
      padding: 12px;
    }

    .btn-long {
      background: linear-gradient(45deg, #0d7a3e, #10a050) !important;
      color: #fff !important;
    }

    .btn-short {
      background: linear-gradient(45deg, #7b1fa2, #ab47bc) !important;
      color: #fff !important;
    }

    /* Position History */
    .position-card {
      background: rgba(255,255,255,0.05);
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 10px;
      border-left: 4px solid #888;
    }

    .position-card.long {
      border-left-color: #00ff88;
    }

    .position-card.short {
      border-left-color: #e040fb;
    }

    .position-card.profit {
      background: rgba(0,255,136,0.1);
    }

    .position-card.loss {
      background: rgba(255,82,82,0.1);
    }

    .position-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .position-symbol {
      font-weight: bold;
      font-size: 1.1em;
    }

    .position-pnl {
      font-weight: bold;
      font-size: 1.2em;
    }

    .position-pnl.profit {
      color: #00ff88;
    }

    .position-pnl.loss {
      color: #ff5252;
    }

    .position-details {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      gap: 10px;
      font-size: 0.9em;
      color: #888;
    }

    .position-details span {
      display: block;
    }

    .position-details .label {
      color: #666;
      font-size: 0.85em;
    }

    .position-details .value {
      color: #fff;
    }

    .position-actions {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }

    .position-actions button {
      padding: 8px 15px;
      font-size: 0.85em;
    }

    .btn-close-profit {
      background: linear-gradient(45deg, #00c853, #00e676) !important;
    }

    .btn-close-loss {
      background: linear-gradient(45deg, #ff1744, #ff5252) !important;
      color: #fff !important;
    }

    .btn-delete {
      background: rgba(255,255,255,0.1) !important;
      color: #888 !important;
    }

    .btn-copy {
      background: linear-gradient(45deg, #00d9ff, #0099cc) !important;
      color: #fff !important;
    }

    .btn-copy:hover {
      box-shadow: 0 3px 15px rgba(0, 217, 255, 0.4);
    }

    .no-positions {
      text-align: center;
      padding: 40px;
      color: #666;
    }

    .history-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
      padding: 20px;
      background: rgba(0,0,0,0.3);
      border-radius: 10px;
    }

    .stat-item {
      text-align: center;
    }

    .stat-item .label {
      color: #888;
      font-size: 0.85em;
      margin-bottom: 5px;
    }

    .stat-item .value {
      font-size: 1.3em;
      font-weight: bold;
      margin-top: 5px;
    }

    .confidence-fill {
      height: 100%;
      border-radius: 3px;
      transition: width 0.3s;
    }

    .tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    }

    .tab {
      padding: 10px 20px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .tab:hover, .tab.active {
      background: rgba(0, 217, 255, 0.2);
      border-color: #00d9ff;
    }

    .symbol-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: #1a1a2e;
      border: 1px solid #00d9ff;
      border-radius: 8px;
      max-height: 300px;
      overflow-y: auto;
      z-index: 1000;
      margin-top: 5px;
    }

    .symbol-dropdown-item {
      padding: 12px 15px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }

    .symbol-dropdown-item:hover {
      background: rgba(0, 217, 255, 0.2);
    }

    .symbol-dropdown-item .coin-name {
      font-weight: bold;
      color: #fff;
    }

    .symbol-dropdown-item .coin-pair {
      color: #888;
      font-size: 0.9em;
    }

    /* Toast Notification */
    .toast-container {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 9999;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .toast {
      min-width: 320px;
      max-width: 420px;
      padding: 16px 20px;
      border-radius: 12px;
      background: rgba(26, 26, 46, 0.98);
      border: 1px solid rgba(255,255,255,0.1);
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
      animation: slideIn 0.3s ease-out;
      backdrop-filter: blur(10px);
    }

    .toast.success {
      border-left: 4px solid #00ff88;
    }

    .toast.error {
      border-left: 4px solid #ff5252;
    }

    .toast.info {
      border-left: 4px solid #00d9ff;
    }

    .toast-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
    }

    .toast-icon {
      font-size: 1.5em;
    }

    .toast-title {
      font-weight: bold;
      font-size: 1.1em;
      color: #fff;
    }

    .toast-body {
      color: #ccc;
      font-size: 0.95em;
      line-height: 1.5;
    }

    .toast-body .detail {
      display: flex;
      justify-content: space-between;
      padding: 4px 0;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }

    .toast-body .detail:last-child {
      border-bottom: none;
    }

    .toast-body .detail .label {
      color: #888;
    }

    .toast-body .detail .value {
      font-weight: 500;
    }

    .toast-body .value.long {
      color: #00ff88;
    }

    .toast-body .value.short {
      color: #ff5252;
    }

    .toast-close {
      position: absolute;
      top: 10px;
      right: 10px;
      background: none;
      border: none;
      color: #888;
      font-size: 1.2em;
      cursor: pointer;
      padding: 5px;
    }

    .toast-close:hover {
      color: #fff;
    }

    .toast-progress {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 3px;
      background: linear-gradient(90deg, #00d9ff, #00ff88);
      border-radius: 0 0 0 12px;
      animation: progress 4s linear forwards;
    }

    /* Modal Dialog */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      animation: fadeIn 0.2s ease-out;
    }

    .modal {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      border-radius: 16px;
      padding: 25px;
      min-width: 350px;
      max-width: 450px;
      border: 1px solid rgba(255,255,255,0.1);
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
      animation: scaleIn 0.2s ease-out;
    }

    .modal-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 20px;
    }

    .modal-icon {
      font-size: 2em;
    }

    .modal-icon.warning { color: #ffc107; }
    .modal-icon.danger { color: #ff5252; }
    .modal-icon.success { color: #00ff88; }
    .modal-icon.info { color: #00d9ff; }

    .modal-title {
      font-size: 1.3em;
      font-weight: bold;
      color: #fff;
    }

    .modal-body {
      color: #ccc;
      margin-bottom: 20px;
      line-height: 1.6;
    }

    .modal-input {
      width: 100%;
      padding: 12px 15px;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      background: rgba(0,0,0,0.3);
      color: #fff;
      font-size: 1.1em;
      margin-top: 10px;
    }

    .modal-input:focus {
      outline: none;
      border-color: #00d9ff;
    }

    .modal-footer {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }

    .modal-btn {
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 1em;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .modal-btn.cancel {
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      color: #ccc;
    }

    .modal-btn.cancel:hover {
      background: rgba(255,255,255,0.2);
    }

    .modal-btn.confirm {
      background: linear-gradient(45deg, #00d9ff, #00ff88);
      border: none;
      color: #1a1a2e;
    }

    .modal-btn.confirm:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(0, 217, 255, 0.4);
    }

    .modal-btn.danger {
      background: linear-gradient(45deg, #ff5252, #ff1744);
      border: none;
      color: #fff;
    }

    .modal-btn.danger:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(255, 82, 82, 0.4);
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes scaleIn {
      from { transform: scale(0.9); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes slideOut {
      from {
        transform: translateX(0);
        opacity: 1;
      }
      to {
        transform: translateX(100%);
        opacity: 0;
      }
    }

    @keyframes progress {
      from { width: 100%; }
      to { width: 0%; }
    }

    @keyframes pulse {
      0%, 100% { box-shadow: 0 0 0 0 rgba(0, 217, 255, 0.4); }
      50% { box-shadow: 0 0 20px 10px rgba(0, 217, 255, 0.6); }
    }

    /* ===================== CHART MODAL ===================== */
    .chart-modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.9);
      z-index: 10000;
      display: none;
      justify-content: center;
      align-items: center;
      animation: fadeIn 0.2s ease;
    }

    .chart-modal-overlay.active {
      display: flex;
    }

    .chart-modal {
      width: 95%;
      max-width: 1400px;
      height: 85vh;
      background: #1a1a2e;
      border-radius: 15px;
      overflow: hidden;
      animation: scaleIn 0.3s ease;
      display: flex;
      flex-direction: column;
    }

    .chart-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 20px;
      background: rgba(0, 217, 255, 0.1);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .chart-modal-title {
      font-size: 1.3em;
      color: #00d9ff;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .chart-modal-close {
      background: none;
      border: none;
      color: #fff;
      font-size: 2em;
      cursor: pointer;
      padding: 0 10px;
      transition: color 0.2s;
    }

    .chart-modal-close:hover {
      color: #ff5252;
    }

    .chart-modal-body {
      flex: 1;
      overflow: hidden;
    }

    .chart-modal-body iframe {
      width: 100%;
      height: 100%;
      border: none;
    }

    .btn-chart {
      background: rgba(0, 217, 255, 0.2);
      border: 1px solid #00d9ff;
      color: #00d9ff;
      padding: 8px 15px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 0.9em;
      transition: all 0.2s;
      margin-top: 10px;
    }

    .btn-chart:hover {
      background: #00d9ff;
      color: #1a1a2e;
    }

    /* ===================== BINANCE API CONFIG ===================== */
    .api-config-btn {
      position: fixed;
      bottom: 90px;
      right: 20px;
      z-index: 1000;
      background: linear-gradient(135deg, #f0b90b, #d4a00a);
      border: none;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.3em;
      box-shadow: 0 4px 15px rgba(240, 185, 11, 0.4);
      transition: all 0.3s ease;
    }

    .api-config-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 25px rgba(240, 185, 11, 0.6);
    }

    .api-config-btn.connected {
      background: linear-gradient(135deg, #00c853, #00e676);
      box-shadow: 0 4px 15px rgba(0, 200, 83, 0.4);
    }

    .api-config-btn.connected:hover {
      box-shadow: 0 6px 25px rgba(0, 200, 83, 0.6);
    }

    .api-modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10002;
      animation: fadeIn 0.2s ease;
    }

    .api-modal-overlay.active {
      display: flex;
    }

    .api-modal {
      background: linear-gradient(145deg, #1e1e2e, #252540);
      border-radius: 20px;
      padding: 30px;
      max-width: 450px;
      width: 90%;
      position: relative;
      border: 1px solid rgba(240, 185, 11, 0.3);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    .api-modal h3 {
      color: #f0b90b;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .api-modal .subtitle {
      color: #888;
      font-size: 0.85em;
      margin-bottom: 20px;
    }

    .api-input-group {
      margin-bottom: 15px;
    }

    .api-input-group label {
      display: block;
      color: #aaa;
      font-size: 0.9em;
      margin-bottom: 5px;
    }

    .api-input-group input {
      width: 100%;
      padding: 12px 15px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 8px;
      color: #fff;
      font-size: 0.95em;
    }

    .api-input-group input:focus {
      border-color: #f0b90b;
      outline: none;
    }

    .api-warning {
      background: rgba(255, 193, 7, 0.1);
      border: 1px solid rgba(255, 193, 7, 0.3);
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 15px;
      font-size: 0.85em;
      color: #ffc107;
    }

    .api-warning strong {
      display: block;
      margin-bottom: 5px;
    }

    .api-status {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px;
      border-radius: 8px;
      margin-bottom: 15px;
      font-size: 0.9em;
    }

    .api-status.connected {
      background: rgba(0, 200, 83, 0.1);
      border: 1px solid rgba(0, 200, 83, 0.3);
      color: #00c853;
    }

    .api-status.disconnected {
      background: rgba(255, 82, 82, 0.1);
      border: 1px solid rgba(255, 82, 82, 0.3);
      color: #ff5252;
    }

    .api-balance {
      background: rgba(0, 217, 255, 0.1);
      border: 1px solid rgba(0, 217, 255, 0.3);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
    }

    .api-balance-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
    }

    .api-balance-row:last-child {
      margin-bottom: 0;
    }

    .api-balance-label {
      color: #888;
    }

    .api-balance-value {
      font-weight: bold;
      color: #00d9ff;
    }

    .api-modal-close {
      position: absolute;
      top: 15px;
      right: 15px;
      background: none;
      border: none;
      color: #888;
      font-size: 1.5em;
      cursor: pointer;
    }

    .api-modal-close:hover {
      color: #fff;
    }

    .api-buttons {
      display: flex;
      gap: 10px;
    }

    .api-buttons button {
      flex: 1;
      padding: 12px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-api-save {
      background: linear-gradient(135deg, #f0b90b, #d4a00a);
      border: none;
      color: #1a1a2e;
    }

    .btn-api-save:hover {
      box-shadow: 0 5px 20px rgba(240, 185, 11, 0.4);
    }

    .btn-api-clear {
      background: transparent;
      border: 1px solid #ff5252;
      color: #ff5252;
    }

    .btn-api-clear:hover {
      background: rgba(255, 82, 82, 0.1);
    }

    .btn-api-test {
      background: linear-gradient(135deg, #00d9ff, #0099cc);
      border: none;
      color: #1a1a2e;
    }

    .btn-api-test:hover {
      box-shadow: 0 5px 20px rgba(0, 217, 255, 0.4);
    }

    /* Trading Button in Signal */
    .btn-trade-binance {
      background: linear-gradient(135deg, #f0b90b, #d4a00a) !important;
      color: #1a1a2e !important;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .btn-trade-binance:hover {
      box-shadow: 0 5px 20px rgba(240, 185, 11, 0.5) !important;
    }

    .btn-trade-binance:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .testnet-badge {
      background: #ff9800;
      color: #1a1a2e;
      font-size: 0.7em;
      padding: 2px 8px;
      border-radius: 10px;
      margin-left: 5px;
    }

    /* ===================== DONATE BUTTON & MODAL ===================== */
    .donate-container {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 1000;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .donate-label {
      background: linear-gradient(135deg, #ff6b6b, #feca57);
      color: #1a1a2e;
      padding: 8px 15px;
      border-radius: 20px;
      font-size: 0.85em;
      font-weight: bold;
      white-space: nowrap;
      box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
      animation: slideIn 0.5s ease, shake 3s ease-in-out infinite 2s;
      cursor: pointer;
    }

    @keyframes slideIn {
      from { opacity: 0; transform: translateX(20px); }
      to { opacity: 1; transform: translateX(0); }
    }

    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      10%, 30%, 50%, 70%, 90% { transform: translateX(-2px); }
      20%, 40%, 60%, 80% { transform: translateX(2px); }
    }

    .donate-float-btn {
      width: 55px;
      height: 55px;
      background: linear-gradient(135deg, #ff6b6b, #feca57);
      border: none;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.6em;
      box-shadow: 0 4px 20px rgba(255, 107, 107, 0.5);
      transition: all 0.3s ease;
      animation: pulse-donate 2s infinite, bounce 1s ease-in-out infinite 3s;
      position: relative;
    }

    .donate-float-btn::after {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      border: 2px solid rgba(255, 107, 107, 0.6);
      animation: ripple 1.5s infinite;
    }

    @keyframes ripple {
      0% { transform: scale(1); opacity: 1; }
      100% { transform: scale(1.5); opacity: 0; }
    }

    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-8px); }
    }

    .donate-float-btn:hover {
      transform: scale(1.15) rotate(10deg);
      box-shadow: 0 8px 30px rgba(255, 107, 107, 0.7);
    }

    .donate-float-btn:hover::after {
      animation: none;
    }

    @keyframes pulse-donate {
      0%, 100% { box-shadow: 0 4px 20px rgba(255, 107, 107, 0.5); }
      50% { box-shadow: 0 4px 35px rgba(255, 107, 107, 0.8); }
    }

    .donate-badge {
      position: absolute;
      top: -5px;
      right: -5px;
      background: #00ff88;
      color: #1a1a2e;
      font-size: 0.5em;
      padding: 2px 6px;
      border-radius: 10px;
      font-weight: bold;
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    .donate-modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10001;
      animation: fadeIn 0.2s ease;
    }

    .donate-modal-overlay.active {
      display: flex;
    }

    .donate-modal {
      background: linear-gradient(145deg, #1e1e2e, #252540);
      border-radius: 20px;
      padding: 30px;
      max-width: 380px;
      width: 90%;
      text-align: center;
      position: relative;
      border: 1px solid rgba(255, 107, 107, 0.3);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    .donate-modal-close {
      position: absolute;
      top: 15px;
      right: 15px;
      background: none;
      border: none;
      color: #888;
      font-size: 1.5em;
      cursor: pointer;
      transition: color 0.2s;
    }

    .donate-modal-close:hover {
      color: #fff;
    }

    .donate-title {
      font-size: 1.3em;
      margin-bottom: 8px;
      background: linear-gradient(135deg, #ff6b6b, #feca57);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .donate-subtitle {
      color: #888;
      font-size: 0.9em;
      margin-bottom: 20px;
    }

    .donate-qr-container {
      background: #fff;
      padding: 10px;
      border-radius: 15px;
      display: inline-block;
      margin-bottom: 15px;
    }

    .donate-qr-container img {
      width: 220px;
      height: auto;
      border-radius: 10px;
    }

    .donate-info {
      color: #aaa;
      font-size: 0.85em;
      line-height: 1.6;
    }

    .donate-info strong {
      color: #feca57;
    }

    .donate-thanks {
      margin-top: 15px;
      padding: 10px;
      background: rgba(0, 255, 136, 0.1);
      border-radius: 10px;
      color: #00ff88;
      font-size: 0.85em;
    }

    /* ===================== MOBILE RESPONSIVE ===================== */
    @media (max-width: 768px) {
      .container {
        padding: 10px;
      }

      header {
        padding: 15px 0;
        margin-bottom: 15px;
      }

      header h1 {
        font-size: 1.5em;
      }

      header p {
        font-size: 0.9em;
      }

      .tabs {
        flex-wrap: nowrap;
        overflow-x: auto;
        gap: 5px;
        padding-bottom: 5px;
      }

      .tab {
        padding: 10px 15px;
        font-size: 0.85em;
        white-space: nowrap;
        flex-shrink: 0;
      }

      .controls {
        flex-direction: column;
        padding: 15px;
        gap: 10px;
      }

      .control-group {
        min-width: 100%;
      }

      select, input {
        padding: 10px 12px;
        font-size: 16px; /* Prevent zoom on iOS */
      }

      button {
        padding: 12px 20px;
        font-size: 0.95em;
        width: 100%;
      }

      .signal-card {
        padding: 15px;
        border-radius: 12px;
      }

      .signal-header {
        flex-direction: column;
        text-align: center;
        gap: 10px;
      }

      .symbol-info {
        flex-direction: column;
        gap: 8px;
      }

      .symbol-name {
        font-size: 1.4em;
      }

      .price {
        font-size: 1.2em;
      }

      .signal-badge {
        padding: 8px 20px;
        font-size: 1em;
      }

      .indicators-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
      }

      .indicator-box {
        padding: 12px;
      }

      .indicator-box h4 {
        font-size: 0.75em;
      }

      .indicator-box .value {
        font-size: 1.1em;
      }

      .trade-setup {
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
        padding: 15px;
      }

      .trade-item .value {
        font-size: 1em;
      }

      .trade-item label {
        font-size: 0.75em;
      }

      .reasons {
        padding: 12px;
      }

      .reasons li {
        font-size: 0.9em;
        padding: 6px 0;
      }

      /* Order Entry Mobile */
      .order-entry {
        padding: 15px !important;
      }

      .order-grid {
        grid-template-columns: repeat(2, 1fr) !important;
        gap: 10px !important;
      }

      .order-buttons {
        flex-direction: column;
        gap: 10px;
      }

      .order-buttons button {
        width: 100%;
      }

      /* Position Cards Mobile */
      .position-card {
        padding: 12px;
      }

      .position-header {
        flex-direction: column;
        gap: 8px;
        text-align: center;
      }

      .position-symbol {
        font-size: 1.1em;
      }

      .position-pnl {
        font-size: 1em;
      }

      .position-details {
        grid-template-columns: repeat(2, 1fr) !important;
        gap: 8px;
      }

      .position-details .label {
        font-size: 0.7em;
      }

      .position-details .value {
        font-size: 0.85em;
      }

      .position-actions {
        flex-wrap: wrap;
        gap: 8px;
        justify-content: center;
      }

      .position-actions button {
        padding: 8px 12px;
        font-size: 0.8em;
        flex: 1;
        min-width: 70px;
      }

      /* Stats Mobile */
      .history-stats {
        grid-template-columns: repeat(2, 1fr) !important;
        gap: 10px;
        padding: 15px;
      }

      .stat-item {
        padding: 8px;
      }

      .stat-item .label {
        font-size: 0.7em;
      }

      .stat-item .value {
        font-size: 1em;
      }

      /* Calculator Mobile */
      .position-calculator {
        padding: 15px;
      }

      .calc-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
      }

      .calc-result {
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
        padding: 15px;
      }

      /* Multi Signal Scan Mobile */
      .mini-signal {
        grid-template-columns: 1fr;
        text-align: center;
        padding: 12px;
        gap: 8px;
      }

      .mini-signal .symbol {
        font-size: 1em;
      }

      .mini-badge {
        margin-top: 5px;
      }

      /* Toast Mobile */
      .toast-container {
        left: 10px;
        right: 10px;
        bottom: 10px;
        top: auto;
      }

      .toast {
        max-width: 100%;
        font-size: 0.9em;
      }

      /* Modal Mobile */
      .modal-overlay {
        padding: 15px;
        align-items: flex-end;
      }

      .modal {
        max-width: 100% !important;
        max-height: 85vh;
        overflow-y: auto;
        border-radius: 16px 16px 0 0;
        margin-bottom: 0;
      }

      .modal-header h3 {
        font-size: 1.1em;
      }

      .modal-body {
        font-size: 0.95em;
      }

      .modal-body input {
        font-size: 16px;
      }

      .modal-actions {
        flex-direction: column;
        gap: 10px;
      }

      .modal-btn {
        width: 100%;
        padding: 14px;
      }

      /* Tabs Content */
      .tab-content {
        padding: 0;
      }

      /* Section Headers */
      .section-header {
        font-size: 1.1em;
        padding: 12px;
      }
    }

    /* Extra small devices (phones in portrait) */
    @media (max-width: 400px) {
      header h1 {
        font-size: 1.3em;
      }

      .indicators-grid {
        grid-template-columns: 1fr;
      }

      .trade-setup {
        grid-template-columns: 1fr;
      }

      .position-details {
        grid-template-columns: 1fr !important;
      }

      .history-stats {
        grid-template-columns: 1fr !important;
      }

      .order-grid {
        grid-template-columns: 1fr !important;
      }

      .calc-grid {
        grid-template-columns: 1fr;
      }

      .calc-result {
        grid-template-columns: 1fr;
      }

      .position-actions button {
        min-width: 100%;
      }
    }

    /* Landscape mode on mobile */
    @media (max-width: 768px) and (orientation: landscape) {
      .modal {
        max-height: 90vh;
        border-radius: 16px;
      }

      .modal-overlay {
        align-items: center;
      }
    }

    /* Touch-friendly improvements */
    @media (hover: none) and (pointer: coarse) {
      button, .tab, .mini-signal, select, input {
        min-height: 44px; /* Apple's recommended touch target */
      }

      .position-actions button {
        min-height: 40px;
      }

      button:hover {
        transform: none;
        box-shadow: none;
      }

      .tab:hover {
        background: transparent;
      }

      .tab.active:hover {
        background: linear-gradient(45deg, #00d9ff, #00ff88);
      }
    }

    /* ===================== BOT CONTROL PANEL ===================== */
    .bot-panel {
      background: rgba(255,255,255,0.05);
      border-radius: 15px;
      padding: 25px;
      border: 1px solid rgba(255,255,255,0.1);
    }

    .bot-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 25px;
      flex-wrap: wrap;
      gap: 15px;
    }

    .bot-status-badge {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 12px 20px;
      border-radius: 25px;
      font-weight: bold;
      font-size: 1.1em;
    }

    .bot-status-badge.running {
      background: rgba(0, 255, 136, 0.2);
      border: 1px solid #00ff88;
      color: #00ff88;
    }

    .bot-status-badge.stopped {
      background: rgba(255, 82, 82, 0.2);
      border: 1px solid #ff5252;
      color: #ff5252;
    }

    .bot-status-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      animation: pulse-dot 1.5s infinite;
    }

    .bot-status-badge.running .bot-status-dot {
      background: #00ff88;
    }

    .bot-status-badge.stopped .bot-status-dot {
      background: #ff5252;
      animation: none;
    }

    @keyframes pulse-dot {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.5; transform: scale(1.2); }
    }

    .bot-controls {
      display: flex;
      gap: 10px;
    }

    .btn-bot-start {
      background: linear-gradient(135deg, #00c853, #00e676) !important;
      color: #fff !important;
    }

    .btn-bot-stop {
      background: linear-gradient(135deg, #ff5252, #d32f2f) !important;
      color: #fff !important;
    }

    .btn-bot-scan {
      background: linear-gradient(135deg, #00d9ff, #0099cc) !important;
      color: #1a1a2e !important;
    }

    .bot-stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
      margin-bottom: 25px;
    }

    .bot-stat-card {
      background: rgba(0,0,0,0.3);
      padding: 20px;
      border-radius: 10px;
      text-align: center;
    }

    .bot-stat-card .label {
      color: #888;
      font-size: 0.85em;
      margin-bottom: 8px;
    }

    .bot-stat-card .value {
      font-size: 1.5em;
      font-weight: bold;
      color: #fff;
    }

    .bot-stat-card .value.profit { color: #00ff88; }
    .bot-stat-card .value.loss { color: #ff5252; }

    .bot-config-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 25px;
      padding: 20px;
      background: rgba(0,0,0,0.2);
      border-radius: 10px;
    }

    .bot-config-item label {
      display: block;
      color: #888;
      font-size: 0.85em;
      margin-bottom: 5px;
    }

    .bot-config-item input,
    .bot-config-item select {
      width: 100%;
      padding: 10px 12px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 8px;
      color: #fff;
      font-size: 0.95em;
    }

    .bot-config-item input:focus,
    .bot-config-item select:focus {
      border-color: #00d9ff;
      outline: none;
    }

    .bot-trades-section {
      margin-top: 25px;
    }

    .bot-trades-section h4 {
      color: #00d9ff;
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .bot-trade-card {
      background: rgba(255,255,255,0.05);
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 10px;
      border-left: 4px solid #888;
      display: grid;
      grid-template-columns: 1fr 1fr 1fr auto;
      gap: 15px;
      align-items: center;
    }

    .bot-trade-card.long { border-left-color: #00ff88; }
    .bot-trade-card.short { border-left-color: #e040fb; }

    .bot-trade-info .symbol {
      font-weight: bold;
      font-size: 1.1em;
      margin-bottom: 5px;
    }

    .bot-trade-info .side {
      font-size: 0.85em;
      padding: 3px 10px;
      border-radius: 10px;
      display: inline-block;
    }

    .bot-trade-info .side.long {
      background: rgba(0, 255, 136, 0.2);
      color: #00ff88;
    }

    .bot-trade-info .side.short {
      background: rgba(224, 64, 251, 0.2);
      color: #e040fb;
    }

    .bot-trade-prices {
      font-size: 0.9em;
      color: #ccc;
    }

    .bot-trade-prices .entry { color: #00d9ff; }
    .bot-trade-prices .sl { color: #ff5252; }
    .bot-trade-prices .tp { color: #00ff88; }

    .bot-trade-pnl {
      text-align: right;
    }

    .bot-trade-pnl .pnl {
      font-size: 1.2em;
      font-weight: bold;
    }

    .bot-trade-pnl .pnl.profit { color: #00ff88; }
    .bot-trade-pnl .pnl.loss { color: #ff5252; }

    .bot-logs {
      background: rgba(0,0,0,0.4);
      border-radius: 10px;
      padding: 15px;
      max-height: 200px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 0.85em;
      margin-top: 20px;
    }

    .bot-log-entry {
      padding: 5px 0;
      border-bottom: 1px solid rgba(255,255,255,0.05);
      color: #aaa;
    }

    .bot-log-entry:last-child { border-bottom: none; }
    .bot-log-entry .time { color: #666; }
    .bot-log-entry.info { color: #00d9ff; }
    .bot-log-entry.warn { color: #ffc107; }
    .bot-log-entry.error { color: #ff5252; }
    .bot-log-entry.success { color: #00ff88; }

    .test-mode-badge {
      background: #ff9800;
      color: #1a1a2e;
      font-size: 0.75em;
      padding: 4px 10px;
      border-radius: 10px;
      font-weight: bold;
      margin-left: 10px;
    }

    .live-mode-badge {
      background: #ff5252;
      color: #fff;
      font-size: 0.75em;
      padding: 4px 10px;
      border-radius: 10px;
      font-weight: bold;
      margin-left: 10px;
      animation: pulse-live 1s infinite;
    }

    @keyframes pulse-live {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    .no-trades {
      text-align: center;
      padding: 40px;
      color: #666;
    }
  </style>
</head>
<body>
  <!-- Toast Container -->
  <div class="toast-container" id="toast-container"></div>

  <div class="container">
    <header>
      <h1>Trading Signal Bot</h1>
      <p>Phân tích tín hiệu Futures Long/Short với Stop Loss tự động</p>
    </header>

    <div class="tabs">
      <div class="tab active" onclick="switchTab('single')">Phân tích 1 Symbol</div>
      <div class="tab" onclick="switchTab('multi')">Quét nhiều Symbol</div>
      <div class="tab" onclick="switchTab('bot')">Bot Trader</div>
      <div class="tab" onclick="switchTab('positions')">Lệnh đang mở (<span id="open-count">0</span>)</div>
      <div class="tab" onclick="switchTab('history')">Lịch sử</div>
    </div>

    <!-- Single Analysis -->
    <div id="single-tab">
      <div class="controls" style="align-items: flex-start;">
        <div class="control-group">
          <label>Tìm Symbol</label>
          <div style="position: relative;">
            <input type="text" id="symbolSearch" placeholder="Nhập tên coin (VD: BTC, ETH, SOL...)" autocomplete="off" oninput="filterSymbols()" onfocus="showSymbolList()">
            <div id="symbolList" class="symbol-dropdown" style="display: none;"></div>
          </div>
          <input type="hidden" id="symbol" value="BTCUSDT">
        </div>
        <div class="control-group">
          <label>Khung thời gian</label>
          <select id="interval">
            <option value="5m">5 Phút</option>
            <option value="15m">15 Phút</option>
            <option value="30m">30 Phút</option>
            <option value="1h" selected>1 Giờ</option>
            <option value="4h">4 Giờ</option>
            <option value="1d">1 Ngày</option>
          </select>
        </div>
        <div class="control-group">
          <label>Thị trường</label>
          <select id="market">
            <option value="futures" selected>Futures</option>
            <option value="spot">Spot</option>
          </select>
        </div>
        <div class="control-group">
          <label>&nbsp;</label>
          <button onclick="analyzeSignal()" id="analyzeBtn">Phân tích</button>
        </div>
      </div>

      <div id="signal-result"></div>
    </div>

    <!-- Multi Analysis -->
    <div id="multi-tab" style="display: none;">
      <div class="controls">
        <div class="control-group">
          <label>Khung thời gian</label>
          <select id="multi-interval">
            <option value="15m">15 Phút</option>
            <option value="1h" selected>1 Giờ</option>
            <option value="4h">4 Giờ</option>
          </select>
        </div>
        <div class="control-group" style="display: flex; align-items: flex-end;">
          <button onclick="scanSignals()" id="scanBtn">Quét tất cả</button>
        </div>
      </div>

      <div id="multi-result" class="multi-signals"></div>
    </div>

    <!-- Bot Trader Tab -->
    <div id="bot-tab" style="display: none;">
      <div class="bot-panel">
        <!-- Bot Header -->
        <div class="bot-header">
          <div style="display: flex; align-items: center;">
            <div class="bot-status-badge stopped" id="bot-status-badge">
              <div class="bot-status-dot"></div>
              <span id="bot-status-text">Bot Stopped</span>
            </div>
            <span class="test-mode-badge" id="bot-mode-badge">TEST MODE</span>
          </div>
          <div class="bot-controls">
            <button class="btn-bot-start" onclick="startBot()" id="btn-start-bot">Start Bot</button>
            <button class="btn-bot-stop" onclick="stopBot()" id="btn-stop-bot" disabled>Stop Bot</button>
            <button class="btn-bot-scan" onclick="manualScanBot()">Scan Now</button>
            <button class="btn-bot-clear" onclick="clearBotData()" style="background: linear-gradient(45deg, #ff5252, #ff9800);">Clear Data</button>
          </div>
        </div>

        <!-- Bot Stats -->
        <div class="bot-stats-grid">
          <div class="bot-stat-card">
            <div class="label">Total Scans</div>
            <div class="value" id="bot-total-scans">0</div>
          </div>
          <div class="bot-stat-card">
            <div class="label">Signals Found</div>
            <div class="value" id="bot-signals-found">0</div>
          </div>
          <div class="bot-stat-card">
            <div class="label">Trades Opened</div>
            <div class="value" id="bot-trades-opened">0</div>
          </div>
          <div class="bot-stat-card">
            <div class="label">Trades Closed</div>
            <div class="value" id="bot-trades-closed">0</div>
          </div>
          <div class="bot-stat-card">
            <div class="label">Total P/L</div>
            <div class="value" id="bot-total-pnl">$0.00</div>
          </div>
          <div class="bot-stat-card">
            <div class="label">Last Scan</div>
            <div class="value" id="bot-last-scan" style="font-size: 1em;">-</div>
          </div>
        </div>

        <!-- Bot Config -->
        <div class="bot-config-grid">
          <div class="bot-config-item">
            <label>Margin/lệnh (USDT)</label>
            <input type="number" id="bot-margin" value="5" min="1" max="1000">
          </div>
          <div class="bot-config-item">
            <label>Max lệnh cùng lúc</label>
            <input type="number" id="bot-max-positions" value="3" min="1" max="10">
          </div>
          <div class="bot-config-item">
            <label>Khung thời gian</label>
            <select id="bot-interval">
              <option value="15m">15 Phút</option>
              <option value="1h" selected>1 Giờ</option>
              <option value="4h">4 Giờ</option>
            </select>
          </div>
          <div class="bot-config-item">
            <label>Quét mỗi (giây)</label>
            <input type="number" id="bot-scan-interval" value="60" min="30" max="600">
          </div>
          <div class="bot-config-item">
            <label>Min Score</label>
            <input type="number" id="bot-min-score" value="4" min="2" max="8">
          </div>
          <div class="bot-config-item">
            <label>Test Mode</label>
            <select id="bot-test-mode">
              <option value="true" selected>ON (Không đặt lệnh thật)</option>
              <option value="false">OFF (Đặt lệnh thật!)</option>
            </select>
          </div>
        </div>

        <button onclick="updateBotConfig()" style="width: 100%; margin-bottom: 20px;">Cập nhật Config</button>

        <!-- Open Trades -->
        <div class="bot-trades-section">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h4 style="margin: 0;">Lệnh đang mở (<span id="bot-open-count">0</span>)</h4>
            <button onclick="closeAllBotTrades()" id="btn-close-all" style="padding: 6px 12px; font-size: 0.85em; background: linear-gradient(45deg, #ff5252, #ff1744); color: #fff;">Đóng tất cả</button>
          </div>
          <div id="bot-open-trades">
            <div class="no-trades">Chưa có lệnh nào đang mở</div>
          </div>
        </div>

        <!-- Trade History -->
        <div class="bot-trades-section">
          <h4>Lịch sử giao dịch (20 lệnh gần nhất)</h4>
          <div id="bot-trade-history">
            <div class="no-trades">Chưa có lịch sử giao dịch</div>
          </div>
        </div>

        <!-- Logs -->
        <div class="bot-logs" id="bot-logs">
          <div class="bot-log-entry info">[System] Bot control panel ready</div>
        </div>
      </div>
    </div>


    <!-- Open Positions -->
    <div id="positions-tab" style="display: none;">
      <div class="history-stats">
        <div class="stat-item">
          <div class="label">Tổng lệnh đang mở</div>
          <div class="value" id="total-open">0</div>
        </div>
        <div class="stat-item">
          <div class="label">Tổng P/L chưa chốt</div>
          <div class="value" id="total-unrealized-pnl">$0.00</div>
        </div>
        <div class="stat-item">
          <div class="label">Tổng margin</div>
          <div class="value" id="total-margin">$0.00</div>
        </div>
      </div>
      <div id="open-positions"></div>
    </div>

    <!-- History -->
    <div id="history-tab" style="display: none;">
      <div class="history-stats">
        <div class="stat-item">
          <div class="label">Tổng lệnh đã đóng</div>
          <div class="value" id="total-closed">0</div>
        </div>
        <div class="stat-item">
          <div class="label">Tổng P/L</div>
          <div class="value" id="total-pnl">$0.00</div>
        </div>
        <div class="stat-item">
          <div class="label">Win Rate</div>
          <div class="value" id="win-rate">0%</div>
        </div>
        <div class="stat-item">
          <div class="label">Lệnh thắng / Thua</div>
          <div class="value" id="win-loss">0 / 0</div>
        </div>
        <div class="stat-item" style="display: flex; align-items: center;">
          <button onclick="clearAllHistory()" style="background: linear-gradient(135deg, #ff5252 0%, #d32f2f 100%); border: none; color: white; padding: 8px 16px; border-radius: 8px; cursor: pointer; font-size: 0.85em;">🗑️ Xóa tất cả</button>
        </div>
      </div>
      <div id="closed-positions"></div>
    </div>
  </div>

  <script>
    const API_BASE = '';

    // ===================== ADMIN MODE (Secret Password) =====================
    const ADMIN_SECRET_KEY = 'chiennv1';
    let isAdminMode = false;

    // Check admin mode immediately on script load
    (function initAdminMode() {
      const urlParams = new URLSearchParams(window.location.search);
      const urlKey = urlParams.get('key');
      const savedKey = localStorage.getItem('admin_key');

      if (urlKey === ADMIN_SECRET_KEY) {
        isAdminMode = true;
        localStorage.setItem('admin_key', ADMIN_SECRET_KEY);
        window.history.replaceState({}, document.title, window.location.pathname);
      } else if (savedKey === ADMIN_SECRET_KEY) {
        isAdminMode = true;
      }
    })();

    // Detect if running on Cloudflare Workers (not localhost)
    const IS_CLOUDFLARE = !window.location.hostname.includes('localhost') &&
                          !window.location.hostname.includes('127.0.0.1') &&
                          !window.location.hostname.match(/^192\.168\./);

    // ===================== FORMAT PRICE HELPER =====================
    // Format giá thông minh dựa trên độ lớn của giá
    function formatPrice(price) {
      if (price === null || price === undefined || isNaN(price)) return 'N/A';

      const absPrice = Math.abs(price);
      let decimals;

      if (absPrice >= 1000) {
        decimals = 2;      // BTC: $94000.12
      } else if (absPrice >= 100) {
        decimals = 2;      // ETH: $3400.25
      } else if (absPrice >= 10) {
        decimals = 3;      // SOL: $180.456
      } else if (absPrice >= 1) {
        decimals = 4;      // XRP: $2.1234
      } else if (absPrice >= 0.1) {
        decimals = 5;      // SEI: $0.11734
      } else if (absPrice >= 0.01) {
        decimals = 6;      // SHIB: $0.000025
      } else {
        decimals = 8;      // Very small prices
      }

      return price.toFixed(decimals);
    }

    // ===================== TOAST NOTIFICATION SYSTEM =====================

    function showToast(options) {
      const { type = 'info', title, message, details = [], duration = 4000 } = options;

      const container = document.getElementById('toast-container');
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.style.position = 'relative';

      // Icon based on type
      const icons = {
        success: '<span style="color: #00ff88;">&#10003;</span>',
        error: '<span style="color: #ff5252;">&#10007;</span>',
        info: '<span style="color: #00d9ff;">&#9432;</span>'
      };

      // Build details HTML
      let detailsHtml = '';
      if (details.length > 0) {
        detailsHtml = details.map(d => `
          <div class="detail">
            <span class="label">${d.label}</span>
            <span class="value ${d.class || ''}">${d.value}</span>
          </div>
        `).join('');
      }

      toast.innerHTML = `
        <button class="toast-close" onclick="this.parentElement.remove()">&times;</button>
        <div class="toast-header">
          <span class="toast-icon">${icons[type] || icons.info}</span>
          <span class="toast-title">${title}</span>
        </div>
        <div class="toast-body">
          ${message ? `<p style="margin-bottom: 10px;">${message}</p>` : ''}
          ${detailsHtml}
        </div>
        <div class="toast-progress"></div>
      `;

      container.appendChild(toast);

      // Auto remove after duration
      setTimeout(() => {
        toast.style.animation = 'slideOut 0.3s ease-in forwards';
        setTimeout(() => toast.remove(), 300);
      }, duration);
    }

    // ===================== MODAL DIALOG SYSTEM =====================

    function showModal(options) {
      return new Promise((resolve) => {
        const { type = 'info', title, message, inputLabel, inputValue, confirmText = 'Xác nhận', cancelText = 'Hủy', showCancel = true, dangerMode = false } = options;

        const icons = {
          warning: '&#9888;',
          danger: '&#128308;',
          success: '&#10003;',
          info: '&#9432;'
        };

        const overlay = document.createElement('div');
        overlay.className = 'modal-overlay';

        const inputHtml = inputLabel ? `
          <label style="color: #888; font-size: 0.9em;">${inputLabel}</label>
          <input type="number" class="modal-input" id="modal-input" value="${inputValue || ''}" step="any">
        ` : '';

        overlay.innerHTML = `
          <div class="modal">
            <div class="modal-header">
              <span class="modal-icon ${type}">${icons[type] || icons.info}</span>
              <span class="modal-title">${title}</span>
            </div>
            <div class="modal-body">
              <p>${message}</p>
              ${inputHtml}
            </div>
            <div class="modal-footer">
              ${showCancel ? `<button class="modal-btn cancel" id="modal-cancel">${cancelText}</button>` : ''}
              <button class="modal-btn ${dangerMode ? 'danger' : 'confirm'}" id="modal-confirm">${confirmText}</button>
            </div>
          </div>
        `;

        document.body.appendChild(overlay);

        const input = overlay.querySelector('#modal-input');
        if (input) {
          input.focus();
          input.select();
        }

        const closeModal = (result) => {
          overlay.style.animation = 'fadeIn 0.2s ease-out reverse';
          setTimeout(() => overlay.remove(), 200);
          resolve(result);
        };

        overlay.querySelector('#modal-confirm').onclick = () => {
          if (input) {
            const value = parseFloat(input.value);
            closeModal({ confirmed: true, value: isNaN(value) ? null : value });
          } else {
            closeModal({ confirmed: true });
          }
        };

        if (showCancel) {
          overlay.querySelector('#modal-cancel').onclick = () => closeModal({ confirmed: false });
        }

        overlay.onclick = (e) => {
          if (e.target === overlay) closeModal({ confirmed: false });
        };

        // Enter key to confirm
        if (input) {
          input.onkeydown = (e) => {
            if (e.key === 'Enter') {
              overlay.querySelector('#modal-confirm').click();
            }
          };
        }
      });
    }

    function showConfirm(title, message, dangerMode = false) {
      return showModal({
        type: dangerMode ? 'danger' : 'warning',
        title,
        message,
        confirmText: 'Xác nhận',
        cancelText: 'Hủy',
        dangerMode
      });
    }

    function showPrompt(title, message, inputLabel, inputValue) {
      return showModal({
        type: 'info',
        title,
        message,
        inputLabel,
        inputValue,
        confirmText: 'Xác nhận',
        cancelText: 'Hủy'
      });
    }

    // ===================== CLIENT-SIDE BINANCE API & SIGNAL ENGINE =====================
    // Used when running on Cloudflare (because Binance blocks Cloudflare IPs)

    const BINANCE_FUTURES_API = 'https://fapi.binance.com';

    // Fetch klines directly from Binance
    async function fetchBinanceKlines(symbol, interval, limit = 100) {
      const url = `${BINANCE_FUTURES_API}/fapi/v1/klines?symbol=${symbol.toUpperCase()}&interval=${interval}&limit=${limit}`;
      const response = await fetch(url);
      if (!response.ok) throw new Error(`Binance API error: ${response.status}`);
      const data = await response.json();
      return data.map(k => ({
        openTime: k[0],
        open: parseFloat(k[1]),
        high: parseFloat(k[2]),
        low: parseFloat(k[3]),
        close: parseFloat(k[4]),
        volume: parseFloat(k[5]),
        closeTime: k[6]
      }));
    }

    // Fetch current price from Binance
    async function fetchBinancePrice(symbol) {
      const url = `${BINANCE_FUTURES_API}/fapi/v1/ticker/price?symbol=${symbol.toUpperCase()}`;
      const response = await fetch(url);
      if (!response.ok) throw new Error(`Binance API error: ${response.status}`);
      const data = await response.json();
      return { symbol: data.symbol, price: parseFloat(data.price) };
    }

    // ===================== CLIENT-SIDE TECHNICAL INDICATORS =====================

    class ClientTechnicalIndicators {
      // Simple Moving Average
      static SMA(data, period) {
        const result = [];
        for (let i = 0; i < data.length; i++) {
          if (i < period - 1) {
            result.push(null);
          } else {
            const sum = data.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
            result.push(sum / period);
          }
        }
        return result;
      }

      // Exponential Moving Average
      static EMA(data, period) {
        const result = [];
        const multiplier = 2 / (period + 1);
        let ema = data.slice(0, period).reduce((a, b) => a + b, 0) / period;
        for (let i = 0; i < data.length; i++) {
          if (i < period - 1) {
            result.push(null);
          } else if (i === period - 1) {
            result.push(ema);
          } else {
            ema = (data[i] - ema) * multiplier + ema;
            result.push(ema);
          }
        }
        return result;
      }

      // RSI
      static RSI(closes, period = 14) {
        const changes = [];
        for (let i = 1; i < closes.length; i++) {
          changes.push(closes[i] - closes[i - 1]);
        }

        const gains = changes.map(c => c > 0 ? c : 0);
        const losses = changes.map(c => c < 0 ? Math.abs(c) : 0);

        const result = [];
        let avgGain = gains.slice(0, period).reduce((a, b) => a + b, 0) / period;
        let avgLoss = losses.slice(0, period).reduce((a, b) => a + b, 0) / period;

        for (let i = 0; i < closes.length; i++) {
          if (i < period) {
            result.push(null);
          } else if (i === period) {
            const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
            result.push(100 - (100 / (1 + rs)));
          } else {
            avgGain = (avgGain * (period - 1) + gains[i - 1]) / period;
            avgLoss = (avgLoss * (period - 1) + losses[i - 1]) / period;
            const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
            result.push(100 - (100 / (1 + rs)));
          }
        }
        return result;
      }

      // MACD
      static MACD(closes, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
        const emaFast = this.EMA(closes, fastPeriod);
        const emaSlow = this.EMA(closes, slowPeriod);

        const macdLine = emaFast.map((fast, i) => {
          if (fast === null || emaSlow[i] === null) return null;
          return fast - emaSlow[i];
        });

        const validMacd = macdLine.filter(v => v !== null);
        const signalLine = this.EMA(validMacd, signalPeriod);

        const result = { macd: [], signal: [], histogram: [] };
        let signalIndex = 0;

        for (let i = 0; i < macdLine.length; i++) {
          if (macdLine[i] === null) {
            result.macd.push(null);
            result.signal.push(null);
            result.histogram.push(null);
          } else {
            result.macd.push(macdLine[i]);
            const sig = signalLine[signalIndex] || null;
            result.signal.push(sig);
            result.histogram.push(sig !== null ? macdLine[i] - sig : null);
            signalIndex++;
          }
        }
        return result;
      }

      // Bollinger Bands
      static BollingerBands(closes, period = 20, stdDev = 2) {
        const sma = this.SMA(closes, period);
        const result = { upper: [], middle: [], lower: [] };

        for (let i = 0; i < closes.length; i++) {
          if (sma[i] === null) {
            result.upper.push(null);
            result.middle.push(null);
            result.lower.push(null);
          } else {
            const slice = closes.slice(i - period + 1, i + 1);
            const mean = sma[i];
            const variance = slice.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / period;
            const std = Math.sqrt(variance);

            result.upper.push(mean + stdDev * std);
            result.middle.push(mean);
            result.lower.push(mean - stdDev * std);
          }
        }
        return result;
      }

      // ATR
      static ATR(candles, period = 14) {
        const trueRanges = [];
        for (let i = 0; i < candles.length; i++) {
          if (i === 0) {
            trueRanges.push(candles[i].high - candles[i].low);
          } else {
            const tr = Math.max(
              candles[i].high - candles[i].low,
              Math.abs(candles[i].high - candles[i - 1].close),
              Math.abs(candles[i].low - candles[i - 1].close)
            );
            trueRanges.push(tr);
          }
        }
        return this.EMA(trueRanges, period);
      }
    }

    // ===================== CLIENT-SIDE SIGNAL ENGINE (SMART MONEY CONCEPTS) =====================

    // Multi-Timeframe mapping
    const MTF_MAP = {
      '1m':  ['5m', '15m'],
      '3m':  ['15m', '1h'],
      '5m':  ['15m', '1h'],
      '15m': ['1h', '4h'],
      '30m': ['1h', '4h'],
      '1h':  ['4h', '1d'],
      '2h':  ['4h', '1d'],
      '4h':  ['1d', '1w'],
      '1d':  ['1w', '1M']
    };

    class ClientSignalEngine {
      constructor() {
        this.config = {
          rsiPeriod: 14,
          rsiOversold: 30,
          rsiOverbought: 70,
          atrMultiplier: 2.0,         // SL = 2x ATR
          riskRewardRatio: 2.0,       // TP = 2x SL distance
          minScoreToTrade: 5,         // Điểm tối thiểu để vào lệnh (tăng từ 3 lên 5)
          volumeMultiplier: 1.2,      // Volume phải > 1.2x MA để xác nhận
          swingLookback: 10,          // Số nến để tìm swing high/low
          useMTF: true                // Enable Multi-Timeframe Confirmation
        };
      }

      analyze(candles) {
        const closes = candles.map(c => c.close);
        const highs = candles.map(c => c.high);
        const lows = candles.map(c => c.low);
        const volumes = candles.map(c => c.volume);
        const currentPrice = closes[closes.length - 1];

        // Calculate indicators
        const rsi = ClientTechnicalIndicators.RSI(closes, 14);
        const macd = ClientTechnicalIndicators.MACD(closes);
        const ema9 = ClientTechnicalIndicators.EMA(closes, 9);
        const ema21 = ClientTechnicalIndicators.EMA(closes, 21);
        const ema50 = ClientTechnicalIndicators.EMA(closes, 50);
        const ema200 = ClientTechnicalIndicators.EMA(closes, Math.min(200, closes.length - 1));
        const bb = ClientTechnicalIndicators.BollingerBands(closes);
        const atr = ClientTechnicalIndicators.ATR(candles, 14);
        const volumeMA = ClientTechnicalIndicators.SMA(volumes, 20);

        const latestIndicators = {
          rsi: rsi[rsi.length - 1],
          macd: macd.macd[macd.macd.length - 1],
          macdSignal: macd.signal[macd.signal.length - 1],
          macdHistogram: macd.histogram[macd.histogram.length - 1],
          ema9: ema9[ema9.length - 1],
          ema21: ema21[ema21.length - 1],
          ema50: ema50[ema50.length - 1],
          ema200: ema200[ema200.length - 1],
          bbUpper: bb.upper[bb.upper.length - 1],
          bbMiddle: bb.middle[bb.middle.length - 1],
          bbLower: bb.lower[bb.lower.length - 1],
          atr: atr[atr.length - 1],
          volume: volumes[volumes.length - 1],
          volumeMA: volumeMA[volumeMA.length - 1]
        };

        // ==================== SMART MONEY ANALYSIS ====================

        // 1. Market Structure Analysis (HH/HL/LH/LL)
        const marketStructure = this.analyzeMarketStructure(candles);

        // 2. Volume Analysis
        const volumeAnalysis = this.analyzeVolume(latestIndicators);

        // 3. Order Block / Demand-Supply Zone
        const orderBlocks = this.findOrderBlocks(candles);

        // 4. Pullback Detection
        const pullback = this.detectPullback(candles, latestIndicators);

        // Analyze each indicator
        const analysis = {
          marketStructure,
          volumeAnalysis,
          orderBlocks,
          pullback,
          rsi: this.analyzeRSI(latestIndicators.rsi),
          macd: this.analyzeMACD(latestIndicators),
          ema: this.analyzeEMA(latestIndicators, currentPrice),
          bb: this.analyzeBB(latestIndicators, currentPrice),
          trend: this.analyzeTrend(latestIndicators, currentPrice)
        };

        // Calculate total score với trọng số mới
        const totalScore = this.calculateSmartScore(analysis);

        let strength = 'YẾU';
        if (Math.abs(totalScore) >= 8) strength = 'RẤT MẠNH';
        else if (Math.abs(totalScore) >= 5) strength = 'MẠNH';
        else if (Math.abs(totalScore) >= 3) strength = 'TRUNG BÌNH';

        // Generate signal
        const signal = this.generateSignal({ totalScore, strength, analysis }, currentPrice, latestIndicators, candles);

        return {
          currentPrice,
          indicators: {
            rsi: { current: latestIndicators.rsi, period: 14 },
            macd: {
              macd: latestIndicators.macd,
              signal: latestIndicators.macdSignal,
              histogram: latestIndicators.macdHistogram
            },
            ema: { ema9: latestIndicators.ema9, ema21: latestIndicators.ema21, ema50: latestIndicators.ema50, ema200: latestIndicators.ema200 },
            bollingerBands: { upper: latestIndicators.bbUpper, middle: latestIndicators.bbMiddle, lower: latestIndicators.bbLower },
            atr: { current: latestIndicators.atr, period: 14 },
            volume: { current: latestIndicators.volume, ma: latestIndicators.volumeMA }
          },
          analysis,
          signal
        };
      }

      // ==================== SMART MONEY FUNCTIONS ====================

      // Phân tích cấu trúc thị trường - tìm HH, HL, LH, LL
      analyzeMarketStructure(candles) {
        const lookback = this.config.swingLookback;
        const highs = candles.map(c => c.high);
        const lows = candles.map(c => c.low);

        // Tìm các swing points
        const swingHighs = [];
        const swingLows = [];

        for (let i = lookback; i < candles.length - lookback; i++) {
          // Swing High: điểm cao nhất trong vùng lookback
          const leftHighs = highs.slice(i - lookback, i);
          const rightHighs = highs.slice(i + 1, i + lookback + 1);
          if (highs[i] >= Math.max(...leftHighs) && highs[i] >= Math.max(...rightHighs)) {
            swingHighs.push({ index: i, price: highs[i] });
          }

          // Swing Low: điểm thấp nhất trong vùng lookback
          const leftLows = lows.slice(i - lookback, i);
          const rightLows = lows.slice(i + 1, i + lookback + 1);
          if (lows[i] <= Math.min(...leftLows) && lows[i] <= Math.min(...rightLows)) {
            swingLows.push({ index: i, price: lows[i] });
          }
        }

        // Xác định trend structure
        let structure = 'SIDEWAY';
        let score = 0;
        let description = '';

        if (swingHighs.length >= 2 && swingLows.length >= 2) {
          const lastHighs = swingHighs.slice(-3);
          const lastLows = swingLows.slice(-3);

          // Check Higher Highs & Higher Lows (Uptrend)
          const isHH = lastHighs.length >= 2 && lastHighs[lastHighs.length - 1].price > lastHighs[lastHighs.length - 2].price;
          const isHL = lastLows.length >= 2 && lastLows[lastLows.length - 1].price > lastLows[lastLows.length - 2].price;

          // Check Lower Highs & Lower Lows (Downtrend)
          const isLH = lastHighs.length >= 2 && lastHighs[lastHighs.length - 1].price < lastHighs[lastHighs.length - 2].price;
          const isLL = lastLows.length >= 2 && lastLows[lastLows.length - 1].price < lastLows[lastLows.length - 2].price;

          if (isHH && isHL) {
            structure = 'UPTREND';
            score = 3;
            description = 'Higher Highs + Higher Lows = Uptrend mạnh';
          } else if (isLH && isLL) {
            structure = 'DOWNTREND';
            score = -3;
            description = 'Lower Highs + Lower Lows = Downtrend mạnh';
          } else if (isHH || isHL) {
            structure = 'WEAK_UPTREND';
            score = 1;
            description = 'Có dấu hiệu uptrend nhưng chưa rõ ràng';
          } else if (isLH || isLL) {
            structure = 'WEAK_DOWNTREND';
            score = -1;
            description = 'Có dấu hiệu downtrend nhưng chưa rõ ràng';
          }
        }

        return {
          structure,
          score,
          description,
          swingHighs: swingHighs.slice(-3),
          swingLows: swingLows.slice(-3),
          signal: structure
        };
      }

      // Phân tích Volume
      analyzeVolume(indicators) {
        const { volume, volumeMA } = indicators;
        if (!volume || !volumeMA) return { score: 0, signal: 'N/A', description: 'Không có dữ liệu volume' };

        const volumeRatio = volume / volumeMA;
        let score = 0;
        let signal = 'NEUTRAL';
        let description = '';

        if (volumeRatio >= 2.0) {
          score = 2;
          signal = 'VERY_HIGH';
          description = `Volume rất cao (${volumeRatio.toFixed(1)}x MA) - Xác nhận mạnh`;
        } else if (volumeRatio >= this.config.volumeMultiplier) {
          score = 1;
          signal = 'HIGH';
          description = `Volume cao (${volumeRatio.toFixed(1)}x MA) - Có xác nhận`;
        } else if (volumeRatio < 0.7) {
          score = -1;
          signal = 'LOW';
          description = `Volume thấp (${volumeRatio.toFixed(1)}x MA) - Không tin cậy`;
        } else {
          description = `Volume bình thường (${volumeRatio.toFixed(1)}x MA)`;
        }

        return { score, signal, volumeRatio: volumeRatio.toFixed(2), description };
      }

      // Tìm Order Blocks (vùng supply/demand)
      findOrderBlocks(candles) {
        const orderBlocks = [];
        const lookback = 20;
        const recentCandles = candles.slice(-lookback);

        for (let i = 1; i < recentCandles.length - 1; i++) {
          const prev = recentCandles[i - 1];
          const curr = recentCandles[i];
          const next = recentCandles[i + 1];

          // Bullish Order Block: nến giảm mạnh → nến tăng mạnh (vùng demand)
          if (prev.close < prev.open && // nến giảm
              next.close > next.open && // nến tăng
              next.close > prev.high && // break above
              (prev.open - prev.close) / prev.close > 0.005) { // nến giảm > 0.5%
            orderBlocks.push({
              type: 'DEMAND',
              high: prev.high,
              low: prev.low,
              index: candles.length - lookback + i - 1
            });
          }

          // Bearish Order Block: nến tăng mạnh → nến giảm mạnh (vùng supply)
          if (prev.close > prev.open && // nến tăng
              next.close < next.open && // nến giảm
              next.close < prev.low && // break below
              (prev.close - prev.open) / prev.open > 0.005) { // nến tăng > 0.5%
            orderBlocks.push({
              type: 'SUPPLY',
              high: prev.high,
              low: prev.low,
              index: candles.length - lookback + i - 1
            });
          }
        }

        // Kiểm tra giá hiện tại có gần order block không
        const currentPrice = candles[candles.length - 1].close;
        const atr = ClientTechnicalIndicators.ATR(candles, 14);
        const currentATR = atr[atr.length - 1];

        let nearestBlock = null;
        let score = 0;
        let description = 'Không có Order Block gần';

        for (const block of orderBlocks.slice(-5)) {
          const distanceToLow = Math.abs(currentPrice - block.low);
          const distanceToHigh = Math.abs(currentPrice - block.high);
          const minDistance = Math.min(distanceToLow, distanceToHigh);

          if (minDistance < currentATR * 1.5) {
            nearestBlock = block;
            if (block.type === 'DEMAND' && currentPrice <= block.high && currentPrice >= block.low * 0.99) {
              score = 2;
              description = 'Giá đang ở vùng DEMAND - Cơ hội LONG';
            } else if (block.type === 'SUPPLY' && currentPrice >= block.low && currentPrice <= block.high * 1.01) {
              score = -2;
              description = 'Giá đang ở vùng SUPPLY - Cơ hội SHORT';
            }
            break;
          }
        }

        return { blocks: orderBlocks.slice(-3), nearestBlock, score, signal: nearestBlock?.type || 'NONE', description };
      }

      // Phát hiện Pullback
      detectPullback(candles, indicators) {
        const { ema21, ema50 } = indicators;
        const currentPrice = candles[candles.length - 1].close;
        const recentCandles = candles.slice(-10);

        let score = 0;
        let signal = 'NONE';
        let description = '';

        // Uptrend pullback: giá trên EMA50, vừa chạm EMA21 và bật lên
        if (currentPrice > ema50 && currentPrice > ema21) {
          const touchedEMA21 = recentCandles.some(c => c.low <= ema21 * 1.005 && c.low >= ema21 * 0.995);
          const bouncedUp = recentCandles.slice(-3).every((c, i, arr) => i === 0 || c.close >= arr[i-1].close);

          if (touchedEMA21 && bouncedUp) {
            score = 2;
            signal = 'BULLISH_PULLBACK';
            description = 'Pullback về EMA21 và bật lên - Entry LONG tốt';
          }
        }

        // Downtrend pullback: giá dưới EMA50, vừa chạm EMA21 và giảm tiếp
        if (currentPrice < ema50 && currentPrice < ema21) {
          const touchedEMA21 = recentCandles.some(c => c.high >= ema21 * 0.995 && c.high <= ema21 * 1.005);
          const bouncedDown = recentCandles.slice(-3).every((c, i, arr) => i === 0 || c.close <= arr[i-1].close);

          if (touchedEMA21 && bouncedDown) {
            score = -2;
            signal = 'BEARISH_PULLBACK';
            description = 'Pullback về EMA21 và giảm tiếp - Entry SHORT tốt';
          }
        }

        return { score, signal, description };
      }

      // Phân tích Multi-Timeframe (chỉ cần trend direction từ EMA)
      analyzeHTFTrend(candles) {
        const closes = candles.map(c => c.close);
        const ema21 = ClientTechnicalIndicators.EMA(closes, 21);
        const ema50 = ClientTechnicalIndicators.EMA(closes, 50);
        const currentPrice = closes[closes.length - 1];

        const latestEma21 = ema21[ema21.length - 1];
        const latestEma50 = ema50[ema50.length - 1];

        // Trend direction từ EMA alignment
        if (currentPrice > latestEma21 && latestEma21 > latestEma50) {
          return { trend: 'BULLISH', score: 1, description: 'EMA aligned bullish' };
        } else if (currentPrice < latestEma21 && latestEma21 < latestEma50) {
          return { trend: 'BEARISH', score: -1, description: 'EMA aligned bearish' };
        }
        return { trend: 'NEUTRAL', score: 0, description: 'No clear trend' };
      }

      // Tính điểm Smart Money (với trọng số)
      calculateSmartScore(analysis) {
        let score = 0;

        // Market Structure (trọng số cao nhất: x2)
        score += analysis.marketStructure.score * 2;

        // Volume Confirmation (trọng số: x1.5)
        score += analysis.volumeAnalysis.score * 1.5;

        // Order Blocks (trọng số: x1.5)
        score += analysis.orderBlocks.score * 1.5;

        // Pullback (trọng số: x1.5)
        score += analysis.pullback.score * 1.5;

        // Traditional indicators (trọng số: x1)
        score += analysis.rsi.score;
        score += analysis.macd.score;
        score += analysis.ema.score;
        score += analysis.trend.score;

        // BB có trọng số thấp hơn
        score += analysis.bb.score * 0.5;

        return Math.round(score * 10) / 10;
      }

      analyzeRSI(rsi) {
        if (rsi === null) return { score: 0, signal: 'N/A', description: 'N/A' };
        if (rsi < 25) return { score: 2, signal: 'OVERSOLD', description: `RSI ${rsi.toFixed(1)} - Quá bán mạnh` };
        if (rsi < 35) return { score: 1, signal: 'BULLISH', description: `RSI ${rsi.toFixed(1)} - Vùng mua` };
        if (rsi > 75) return { score: -2, signal: 'OVERBOUGHT', description: `RSI ${rsi.toFixed(1)} - Quá mua mạnh` };
        if (rsi > 65) return { score: -1, signal: 'BEARISH', description: `RSI ${rsi.toFixed(1)} - Vùng bán` };
        return { score: 0, signal: 'NEUTRAL', description: `RSI ${rsi.toFixed(1)} - Trung tính` };
      }

      analyzeMACD(indicators) {
        const { macd, macdSignal, macdHistogram } = indicators;
        if (macd === null || macdSignal === null) return { score: 0, signal: 'N/A', description: 'N/A' };

        let score = 0;
        let description = '';

        // MACD cross
        if (macd > macdSignal) {
          score += 1;
          description = 'MACD trên Signal';
        } else {
          score -= 1;
          description = 'MACD dưới Signal';
        }

        // Histogram momentum
        if (macdHistogram > 0 && macdHistogram > 0.0001) {
          score += 1;
          description += ', Histogram dương';
        } else if (macdHistogram < 0 && macdHistogram < -0.0001) {
          score -= 1;
          description += ', Histogram âm';
        }

        let signal = 'NEUTRAL';
        if (score >= 2) signal = 'BULLISH';
        else if (score <= -2) signal = 'BEARISH';

        return { score, signal, description };
      }

      analyzeEMA(indicators, currentPrice) {
        const { ema9, ema21, ema50, ema200 } = indicators;
        if (!ema9 || !ema21 || !ema50) return { score: 0, signal: 'N/A', description: 'N/A' };

        let score = 0;
        let descriptions = [];

        // EMA alignment
        if (ema9 > ema21 && ema21 > ema50) {
          score += 2;
          descriptions.push('EMA sắp xếp tăng (9>21>50)');
        } else if (ema9 < ema21 && ema21 < ema50) {
          score -= 2;
          descriptions.push('EMA sắp xếp giảm (9<21<50)');
        }

        // Price vs EMA200 (trend filter)
        if (ema200 && currentPrice > ema200) {
          score += 1;
          descriptions.push('Trên EMA200 (macro uptrend)');
        } else if (ema200 && currentPrice < ema200) {
          score -= 1;
          descriptions.push('Dưới EMA200 (macro downtrend)');
        }

        let signal = 'NEUTRAL';
        if (score >= 2) signal = 'BULLISH';
        else if (score <= -2) signal = 'BEARISH';

        return { score, signal, description: descriptions.join(', ') || 'Trung tính' };
      }

      analyzeBB(indicators, currentPrice) {
        const { bbUpper, bbMiddle, bbLower } = indicators;
        if (!bbUpper || !bbMiddle || !bbLower) return { score: 0, signal: 'N/A', pricePosition: 50, description: 'N/A' };

        const range = bbUpper - bbLower;
        const position = ((currentPrice - bbLower) / range * 100).toFixed(1);

        let score = 0;
        let signal = 'NEUTRAL';
        let description = '';

        if (currentPrice <= bbLower) {
          score = 1; // Giảm từ 2 xuống 1 vì BB không phải indicator chính
          signal = 'OVERSOLD';
          description = 'Chạm BB dưới - Có thể bounce';
        } else if (currentPrice >= bbUpper) {
          score = -1;
          signal = 'OVERBOUGHT';
          description = 'Chạm BB trên - Có thể pullback';
        } else if (position < 30) {
          score = 0.5;
          signal = 'BULLISH';
          description = `Vị trí ${position}% - Gần BB dưới`;
        } else if (position > 70) {
          score = -0.5;
          signal = 'BEARISH';
          description = `Vị trí ${position}% - Gần BB trên`;
        } else {
          description = `Vị trí ${position}% - Giữa BB`;
        }

        return { score, signal, pricePosition: position, description };
      }

      analyzeTrend(indicators, currentPrice) {
        const { ema21, ema50, ema200 } = indicators;
        if (!ema21 || !ema50) return { score: 0, signal: 'N/A', description: 'N/A' };

        if (currentPrice > ema21 && ema21 > ema50 && (!ema200 || ema50 > ema200)) {
          return { score: 2, signal: 'STRONG_UPTREND', description: 'Uptrend mạnh - Tất cả EMA aligned' };
        } else if (currentPrice > ema50) {
          return { score: 1, signal: 'UPTREND', description: 'Uptrend - Giá trên EMA50' };
        } else if (currentPrice < ema21 && ema21 < ema50 && (!ema200 || ema50 < ema200)) {
          return { score: -2, signal: 'STRONG_DOWNTREND', description: 'Downtrend mạnh - Tất cả EMA aligned' };
        } else if (currentPrice < ema50) {
          return { score: -1, signal: 'DOWNTREND', description: 'Downtrend - Giá dưới EMA50' };
        }
        return { score: 0, signal: 'SIDEWAY', description: 'Sideway - Không có trend rõ ràng' };
      }

      generateSignal(analysisData, currentPrice, latestIndicators, candles) {
        const { totalScore, strength, analysis } = analysisData;
        const atr = latestIndicators.atr;
        const reasons = [];

        let action = 'WAIT';
        let confidence = 0;

        // Điều kiện vào lệnh chặt hơn
        const minScore = this.config.minScoreToTrade;
        const hasVolumeConfirm = analysis.volumeAnalysis.score >= 1;
        const hasStructure = Math.abs(analysis.marketStructure.score) >= 2;

        // LONG: cần score >= minScore + volume confirm hoặc structure confirm
        if (totalScore >= minScore && (hasVolumeConfirm || hasStructure)) {
          action = 'LONG';
          confidence = Math.min(95, 40 + totalScore * 5 + (hasVolumeConfirm ? 10 : 0) + (hasStructure ? 15 : 0));
          reasons.push(`Smart Score: ${totalScore} - Đủ điều kiện LONG`);

          if (analysis.marketStructure.structure === 'UPTREND') {
            reasons.push('Market Structure: Uptrend (HH+HL)');
          }
          if (analysis.pullback.signal === 'BULLISH_PULLBACK') {
            reasons.push('Pullback: Entry tại EMA21');
          }
          if (analysis.orderBlocks.score > 0) {
            reasons.push('Order Block: Đang ở vùng Demand');
          }
        }
        // SHORT: cần score <= -minScore + volume confirm hoặc structure confirm
        else if (totalScore <= -minScore && (hasVolumeConfirm || hasStructure)) {
          action = 'SHORT';
          confidence = Math.min(95, 40 + Math.abs(totalScore) * 5 + (hasVolumeConfirm ? 10 : 0) + (hasStructure ? 15 : 0));
          reasons.push(`Smart Score: ${totalScore} - Đủ điều kiện SHORT`);

          if (analysis.marketStructure.structure === 'DOWNTREND') {
            reasons.push('Market Structure: Downtrend (LH+LL)');
          }
          if (analysis.pullback.signal === 'BEARISH_PULLBACK') {
            reasons.push('Pullback: Entry tại EMA21');
          }
          if (analysis.orderBlocks.score < 0) {
            reasons.push('Order Block: Đang ở vùng Supply');
          }
        }
        // Điểm cao nhưng thiếu confirm
        else if (Math.abs(totalScore) >= 3) {
          reasons.push(`Score ${totalScore} - Chờ xác nhận thêm`);
          if (!hasVolumeConfirm) reasons.push('Thiếu: Volume confirmation');
          if (!hasStructure) reasons.push('Thiếu: Market structure rõ ràng');
        }
        else {
          reasons.push('Thị trường sideway - Không có setup rõ ràng');
        }

        // Add analysis details
        reasons.push(`Market: ${analysis.marketStructure.description}`);
        reasons.push(`Volume: ${analysis.volumeAnalysis.description}`);
        if (analysis.orderBlocks.nearestBlock) {
          reasons.push(`Order Block: ${analysis.orderBlocks.description}`);
        }

        // Calculate SL/TP với logic mới
        const atrMultiplier = this.config.atrMultiplier;
        const rrRatio = this.config.riskRewardRatio;

        let stopLoss, takeProfit, leverage, leverageRisk;
        let slPrice, tpPrice;

        if (action === 'LONG') {
          // SL dưới swing low gần nhất hoặc 2x ATR
          const recentLow = Math.min(...candles.slice(-10).map(c => c.low));
          slPrice = Math.min(currentPrice - atr * atrMultiplier, recentLow * 0.995);
          tpPrice = currentPrice + Math.abs(currentPrice - slPrice) * rrRatio;

          stopLoss = formatPrice(slPrice);
          takeProfit = formatPrice(tpPrice);
        } else if (action === 'SHORT') {
          // SL trên swing high gần nhất hoặc 2x ATR
          const recentHigh = Math.max(...candles.slice(-10).map(c => c.high));
          slPrice = Math.max(currentPrice + atr * atrMultiplier, recentHigh * 1.005);
          tpPrice = currentPrice - Math.abs(slPrice - currentPrice) * rrRatio;

          stopLoss = formatPrice(slPrice);
          takeProfit = formatPrice(tpPrice);
        } else {
          // WAIT - vẫn tính SL/TP để hiển thị
          slPrice = currentPrice - atr * atrMultiplier;
          tpPrice = currentPrice + atr * atrMultiplier * rrRatio;
          stopLoss = formatPrice(slPrice);
          takeProfit = formatPrice(tpPrice);
        }

        // Calculate leverage based on signal strength và risk
        const slPercent = Math.abs((currentPrice - parseFloat(stopLoss)) / currentPrice * 100);

        // Leverage logic mới: bảo thủ hơn
        if (confidence >= 80 && slPercent <= 2) {
          leverage = 15;
          leverageRisk = 'MEDIUM-HIGH';
        } else if (confidence >= 70 && slPercent <= 3) {
          leverage = 10;
          leverageRisk = 'MEDIUM';
        } else if (confidence >= 60 && slPercent <= 4) {
          leverage = 7;
          leverageRisk = 'LOW-MEDIUM';
        } else {
          leverage = 5;
          leverageRisk = 'LOW';
        }

        const atrPercent = ((atr / currentPrice) * 100).toFixed(2);

        return {
          action,
          confidence: confidence + '%',
          totalScore,
          averageScore: (totalScore / 10).toFixed(2),
          strength,
          entry: currentPrice,
          stopLoss,
          takeProfit,
          riskPercent: `-${slPercent.toFixed(2)}%`,
          rewardPercent: `+${(slPercent * rrRatio).toFixed(2)}%`,
          riskReward: rrRatio,
          leverage,
          leverageRisk,
          atr: atr ? atr.toFixed(currentPrice > 100 ? 2 : 6) : 'N/A',
          atrPercent: atrPercent + '%',
          reasons,
          // Smart Money data
          marketStructure: analysis.marketStructure.structure,
          volumeConfirm: analysis.volumeAnalysis.signal,
          orderBlock: analysis.orderBlocks.nearestBlock?.type || 'NONE'
        };
      }
    }

    const clientSignalEngine = new ClientSignalEngine();

    // Danh sách tất cả coin trên Binance Futures (150+ coins)
    const ALL_SYMBOLS = [
      // Top coins
      'BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'XRPUSDT', 'SOLUSDT', 'ADAUSDT',
      'DOGEUSDT', 'TRXUSDT', 'DOTUSDT', 'LINKUSDT', 'AVAXUSDT', 'MATICUSDT',
      'LTCUSDT', 'BCHUSDT', 'XLMUSDT', 'ATOMUSDT', 'UNIUSDT', 'ETCUSDT',

      // Layer 1 & Layer 2
      'APTUSDT', 'ARBUSDT', 'OPUSDT', 'SUIUSDT', 'SEIUSDT', 'NEARUSDT',
      'FTMUSDT', 'ALGOUSDT', 'ICPUSDT', 'VETUSDT', 'HBARUSDT', 'QNTUSDT',
      'INJUSDT', 'TIAUSDT', 'STXUSDT', 'MANTAUSDT', 'BLURUSDT', 'STRKUSDT',
      'ZKUSDT', 'SCROLLUSDT', 'EIGENUSDT',

      // DeFi
      'AAVEUSDT', 'MKRUSDT', 'COMPUSDT', 'SNXUSDT', 'CRVUSDT', 'LDOUSDT',
      'GMXUSDT', 'DYDXUSDT', 'PENDLEUSDT', 'JUPUSDT', 'RAYDIUMUSDT',
      '1INCHUSDT', 'SUSHIUSDT', 'YFIUSDT', 'BALUSDT', 'ZABORUSDT',

      // Gaming & Metaverse
      'SANDUSDT', 'MANAUSDT', 'AXSUSDT', 'GALAUSDT', 'ENJUSDT', 'IMXUSDT',
      'ILVUSDT', 'MAGICUSDT', 'GMTUSDT', 'LOOKSUSDT', 'HIGHUSDT', 'ACEUSDT',
      'PIXELUSDT', 'PORTALUSDT', 'XABORUSDT', 'RONUSDT',

      // AI & Data
      'RNDRUSDT', 'FETUSDT', 'AGIXUSDT', 'OCEANUSDT', 'ARKMUSDT', 'WLDUSDT',
      'TAOUSDT', 'AIUSDT', 'NFPUSDT', 'ALTUSDT',

      // Meme coins
      'PEPEUSDT', 'SHIBUSDT', 'FLOKIUSDT', 'BONKUSDT', 'WIFUSDT', 'MEMEUSDT',
      'BOMEUSDT', 'PEOPLEUSDT', 'LUNCUSDT', 'NEIROUSDT', 'TURBOFLOKIUSDT',
      '1000PEPEUSDT', '1000SHIBUSDT', '1000FLOKIUSDT', '1000BONKUSDT',
      '1000LUNCUSDT', 'DOGEUSDT', 'BABYDOGEUSDT',

      // Storage & Infrastructure
      'FILUSDT', 'ARUSDT', 'STORJUSDT', 'SCUSDT', 'ABORUSDT',

      // Oracle & Cross-chain
      'BANDUSDT', 'APIUSDT', 'CELRUSDT', 'RENUSDT', 'COTIUSDT',

      // Exchange tokens
      'BNBUSDT', 'FTMUSDT', 'CAKEUSDT', 'OOKIUSDT',

      // Privacy coins
      'XMRUSDT', 'ZECUSDT', 'DASHUSDT',

      // New & Trending
      'ORDIUSDT', 'KASUSDT', 'RUNEUSDT', 'ENAUSDT', 'WUSDT', 'TONUSDT',
      'NOTUSDT', 'DOGSUSDT', 'CATIUSDT', 'HMSTRUSDT', 'SCRUSDT',
      'MOVEUSDT', 'MEUSDT', 'VANAUSDT', 'PENGUUSDT', 'USUALUSDT',

      // Others
      'GRTUSDT', 'CHZUSDT', 'APEUSDT', 'LRCUSDT', 'RSRUSDT', 'KAVAUSDT',
      'IOSTUSDT', 'ZILUSDT', 'ONTUSDT', 'IOTAUSDT', 'NEOUSDT', 'WAVESUSDT',
      'EOSUSDT', 'XTZUSDT', 'THETAUSDT', 'EGLDUSDT', 'FLOWUSDT', 'MINAUSDT',
      'CFXUSDT', 'ACHUSDT', 'ANKRUSDT', 'SKLUSDT', 'WOOUSDT', 'AGLDUSDT',
      'MASKUSDT', 'ENSUSDT', 'SSUSDT', 'BICOUSDT', 'TUSDT', 'EDUUSDT',
      'IDUSDT', 'RDNTUSDT', 'MAVUSDT', 'XVSUSDT', 'UMAUSDT', 'LEVERUSDT',
      'KEYUSDT', 'COMBOUSDT', 'NMRUSDT', 'MDTUSDT', 'XEMUSDT', 'BELUSDT',
      'LITUSDT', 'CKBUSDT', 'PERPUSDT', 'TRUUSDT', 'LQTYUSDT', 'UXLINKUSDT'
    ];

    // Symbol search functions
    function showSymbolList() {
      // Xóa nội dung khi focus để hiển thị tất cả coin
      const searchEl = document.getElementById('symbolSearch');
      const listEl = document.getElementById('symbolList');
      if (searchEl) searchEl.value = '';
      filterSymbols();
      if (listEl) listEl.style.display = 'block';
    }

    function hideSymbolList() {
      setTimeout(() => {
        const listEl = document.getElementById('symbolList');
        if (listEl) listEl.style.display = 'none';
      }, 200);
    }

    function filterSymbols() {
      const searchEl = document.getElementById('symbolSearch');
      const list = document.getElementById('symbolList');
      if (!searchEl || !list) return;

      const search = searchEl.value.toUpperCase();

      // Nếu chưa gõ gì, hiển thị tất cả (có scroll), nếu có search thì filter
      const filtered = search
        ? ALL_SYMBOLS.filter(s => s.includes(search))
        : ALL_SYMBOLS;

      if (filtered.length === 0) {
        list.innerHTML = '<div class="symbol-dropdown-item"><span>Không tìm thấy</span></div>';
      } else {
        list.innerHTML = filtered.map(s => {
          const coin = s.replace('USDT', '');
          return `
            <div class="symbol-dropdown-item" onclick="selectCoin('${s}')">
              <span class="coin-name">${coin}</span>
              <span class="coin-pair">${s}</span>
            </div>
          `;
        }).join('');
      }

      list.style.display = 'block';
    }

    function selectCoin(symbol) {
      const symbolEl = document.getElementById('symbol');
      const searchEl = document.getElementById('symbolSearch');
      const listEl = document.getElementById('symbolList');
      if (symbolEl) symbolEl.value = symbol;
      if (searchEl) searchEl.value = symbol.replace('USDT', '/USDT');
      if (listEl) listEl.style.display = 'none';
      analyzeSignal();
    }

    // Click outside to close dropdown
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.control-group')) {
        document.getElementById('symbolList').style.display = 'none';
      }
    });

    // Tab switching
    function switchTab(tab) {
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('[id$="-tab"]').forEach(t => t.style.display = 'none');

      event.target.classList.add('active');
      document.getElementById(tab + '-tab').style.display = 'block';
    }

    // Single symbol analysis
    async function analyzeSignal() {
      const symbol = document.getElementById('symbol').value;
      const interval = document.getElementById('interval').value;
      const market = document.getElementById('market').value;
      const btn = document.getElementById('analyzeBtn');
      const resultDiv = document.getElementById('signal-result');

      btn.disabled = true;
      btn.textContent = 'Đang phân tích...';
      resultDiv.innerHTML = '<div class="loading">Đang phân tích</div>';

      try {
        let data;

        if (IS_CLOUDFLARE) {
          // Client-side analysis for Cloudflare (bypass Binance IP block)
          console.log('[Cloudflare Mode] Fetching directly from Binance...');

          // Fetch main timeframe
          const candles = await fetchBinanceKlines(symbol, interval, 100);
          const result = clientSignalEngine.analyze(candles);
          result.symbol = symbol.toUpperCase();
          result.interval = interval;
          result.market = market;

          // Multi-Timeframe Analysis
          const htfIntervals = MTF_MAP[interval] || ['1h', '4h'];
          const mtfResults = [];

          resultDiv.innerHTML = '<div class="loading">Đang phân tích Multi-Timeframe...</div>';

          for (const htfInterval of htfIntervals) {
            try {
              const htfCandles = await fetchBinanceKlines(symbol, htfInterval, 60);
              const htfTrend = clientSignalEngine.analyzeHTFTrend(htfCandles);
              mtfResults.push({
                interval: htfInterval,
                ...htfTrend
              });
              await new Promise(resolve => setTimeout(resolve, 50)); // Rate limit
            } catch (err) {
              console.error(`Error fetching ${htfInterval}:`, err);
              mtfResults.push({
                interval: htfInterval,
                trend: 'UNKNOWN',
                score: 0,
                description: 'Không lấy được dữ liệu'
              });
            }
          }

          // Tính MTF Confirmation
          const mtfBullish = mtfResults.filter(r => r.trend === 'BULLISH').length;
          const mtfBearish = mtfResults.filter(r => r.trend === 'BEARISH').length;
          const totalMTF = mtfResults.length;

          let mtfConfirmation = {
            results: mtfResults,
            bullishCount: mtfBullish,
            bearishCount: mtfBearish,
            totalCount: totalMTF,
            signal: 'NEUTRAL',
            confirmed: false,
            description: ''
          };

          if (mtfBullish >= totalMTF * 0.5) {
            mtfConfirmation.signal = 'BULLISH';
            mtfConfirmation.confirmed = result.signal.action === 'LONG';
            mtfConfirmation.description = `${mtfBullish}/${totalMTF} HTF bullish - ${mtfConfirmation.confirmed ? 'XÁC NHẬN LONG' : 'Cảnh báo: Ngược trend HTF'}`;
          } else if (mtfBearish >= totalMTF * 0.5) {
            mtfConfirmation.signal = 'BEARISH';
            mtfConfirmation.confirmed = result.signal.action === 'SHORT';
            mtfConfirmation.description = `${mtfBearish}/${totalMTF} HTF bearish - ${mtfConfirmation.confirmed ? 'XÁC NHẬN SHORT' : 'Cảnh báo: Ngược trend HTF'}`;
          } else {
            mtfConfirmation.description = 'HTF không rõ ràng - Cẩn thận';
          }

          // Điều chỉnh signal dựa trên MTF
          if (result.signal.action !== 'WAIT' && !mtfConfirmation.confirmed) {
            // Giảm confidence nếu ngược trend HTF
            const currentConf = parseFloat(result.signal.confidence);
            result.signal.confidence = Math.max(40, currentConf - 20) + '%';
            result.signal.reasons.push(`⚠️ MTF: ${mtfConfirmation.description}`);
          } else if (mtfConfirmation.confirmed) {
            // Tăng confidence nếu cùng trend HTF
            const currentConf = parseFloat(result.signal.confidence);
            result.signal.confidence = Math.min(95, currentConf + 10) + '%';
            result.signal.reasons.push(`✅ MTF: ${mtfConfirmation.description}`);
          }

          // Thêm MTF data vào result
          result.analysis.mtf = mtfConfirmation;
          result.signal.mtfConfirmed = mtfConfirmation.confirmed;

          data = { success: true, data: result };
        } else {
          // Server-side analysis for local/VPS
          const response = await fetch(`${API_BASE}/api/signal/${symbol}?interval=${interval}&market=${market}`);
          data = await response.json();
        }

        if (data.success) {
          renderSignal(data.data);
        } else {
          resultDiv.innerHTML = `<div class="signal-card"><p style="color: #ff5252;">Lỗi: ${data.error}</p></div>`;
        }
      } catch (error) {
        resultDiv.innerHTML = `<div class="signal-card"><p style="color: #ff5252;">Lỗi kết nối: ${error.message}</p></div>`;
      }

      btn.disabled = false;
      btn.textContent = 'Phân tích';
    }

    // Render signal result
    function renderSignal(data) {
      const { signal, indicators, analysis, currentPrice, symbol, interval } = data;

      const signalClass = signal.action === 'LONG' ? 'signal-long' :
                         signal.action === 'SHORT' ? 'signal-short' : 'signal-wait';

      const html = `
        <div class="signal-card">
          <div class="signal-header">
            <div class="symbol-info">
              <span class="symbol-name">${symbol}</span>
              <span class="price">$${currentPrice.toLocaleString()}</span>
              <span style="color: #888; font-size: 0.9em;">${interval}</span>
              <button class="btn-chart" onclick="openChart('${symbol}')">📈 Xem Chart</button>
            </div>
            <div class="signal-badge ${signalClass}">
              ${signal.action} ${signal.action !== 'WAIT' ? `(${signal.confidence})` : ''}
            </div>
          </div>

          <div class="indicators-grid">
            <div class="indicator-box">
              <h4>RSI (14)</h4>
              <div class="value ${analysis.rsi.score > 0 ? 'bullish' : analysis.rsi.score < 0 ? 'bearish' : 'neutral'}">
                ${indicators.rsi.current ? indicators.rsi.current.toFixed(2) : 'N/A'}
              </div>
              <div class="status">${analysis.rsi.signal}</div>
            </div>

            <div class="indicator-box">
              <h4>MACD</h4>
              <div class="value ${analysis.macd.score > 0 ? 'bullish' : analysis.macd.score < 0 ? 'bearish' : 'neutral'}">
                ${indicators.macd.histogram ? indicators.macd.histogram.toFixed(4) : 'N/A'}
              </div>
              <div class="status">${analysis.macd.signal}</div>
            </div>

            <div class="indicator-box">
              <h4>EMA (9/21/50)</h4>
              <div class="value ${analysis.ema.score > 0 ? 'bullish' : analysis.ema.score < 0 ? 'bearish' : 'neutral'}">
                ${analysis.ema.signal}
              </div>
              <div class="status">${analysis.trend.signal}</div>
            </div>

            <div class="indicator-box">
              <h4>Bollinger Bands</h4>
              <div class="value ${analysis.bb.score > 0 ? 'bullish' : analysis.bb.score < 0 ? 'bearish' : 'neutral'}">
                ${analysis.bb.pricePosition}%
              </div>
              <div class="status">${analysis.bb.signal}</div>
            </div>

            <div class="indicator-box">
              <h4>ATR (14)</h4>
              <div class="value neutral">
                ${signal.atr || 'N/A'}
              </div>
              <div class="status">Volatility</div>
            </div>

            <div class="indicator-box">
              <h4>Tổng điểm</h4>
              <div class="value ${signal.totalScore > 0 ? 'bullish' : signal.totalScore < 0 ? 'bearish' : 'neutral'}">
                ${signal.totalScore} (${signal.averageScore})
              </div>
              <div class="status">${signal.strength}</div>
            </div>
          </div>

          ${signal.action !== 'WAIT' ? `
          <div class="trade-setup">
            <div class="trade-item">
              <label>Entry Price</label>
              <div class="value entry">$${signal.entry.toLocaleString()}</div>
            </div>
            <div class="trade-item">
              <label>Stop Loss</label>
              <div class="value stop-loss">$${parseFloat(signal.stopLoss).toLocaleString()}</div>
              <div style="color: #ff5252; font-size: 0.85em;">${signal.riskPercent}</div>
            </div>
            <div class="trade-item">
              <label>Take Profit</label>
              <div class="value take-profit">$${parseFloat(signal.takeProfit).toLocaleString()}</div>
              <div style="color: #00ff88; font-size: 0.85em;">${signal.rewardPercent}</div>
            </div>
            <div class="trade-item">
              <label>Risk/Reward</label>
              <div class="value neutral">1:${signal.riskReward}</div>
            </div>
            <div class="trade-item">
              <label>Đòn bẩy gợi ý</label>
              <div class="value" style="color: ${signal.leverageRisk === 'SAFE' ? '#00ff88' : signal.leverageRisk === 'LOW' ? '#00d9ff' : '#ffd700'}; font-size: 1.5em;">
                ${signal.leverage}x
              </div>
              <div style="font-size: 0.85em; color: ${signal.leverageRisk === 'SAFE' ? '#00ff88' : signal.leverageRisk === 'LOW' ? '#00d9ff' : '#ffd700'};">
                ${signal.leverageRisk === 'SAFE' ? 'An toàn' : signal.leverageRisk === 'LOW' ? 'Rủi ro thấp' : 'Rủi ro TB'}
              </div>
            </div>
            <div class="trade-item">
              <label>ATR %</label>
              <div class="value neutral">${signal.atrPercent || 'N/A'}</div>
              <div style="font-size: 0.85em; color: #888;">Volatility</div>
            </div>
          </div>
          ` : ''}

          <div class="reasons">
            <h4>Lý do ${signal.action === 'WAIT' ? 'chờ đợi' : signal.action}</h4>
            <ul>
              ${signal.reasons.map(r => `<li>${r}</li>`).join('')}
            </ul>
          </div>

          ${signal.action !== 'WAIT' ? `
          <div class="order-entry">
            <h4>Mở lệnh ${signal.action}</h4>
            <div class="order-grid">
              <div>
                <label style="display: block; margin-bottom: 5px; color: #888; font-size: 0.85em;">Margin (USDT)</label>
                <input type="number" id="order-margin" placeholder="VD: 5, 10, 50..." value="10" min="1" step="1">
              </div>
              <div>
                <label style="display: block; margin-bottom: 5px; color: #888; font-size: 0.85em;">Giá vào</label>
                <input type="number" id="order-entry" value="${signal.entry}" step="0.01">
              </div>
              <div>
                <label style="display: block; margin-bottom: 5px; color: #888; font-size: 0.85em;">Leverage</label>
                <input type="number" id="order-leverage" value="${signal.leverage}" min="1" max="125">
              </div>
              <div>
                <label style="display: block; margin-bottom: 5px; color: #888; font-size: 0.85em;">Stop Loss</label>
                <input type="number" id="order-sl" value="${signal.stopLoss}" step="0.01">
              </div>
              <div>
                <label style="display: block; margin-bottom: 5px; color: #888; font-size: 0.85em;">Take Profit</label>
                <input type="number" id="order-tp" value="${signal.takeProfit}" step="0.01">
              </div>
            </div>
            <div class="order-buttons">
              <button class="btn-long" onclick="openPosition('LONG')">Luu LONG (Local)</button>
              <button class="btn-short" onclick="openPosition('SHORT')">Luu SHORT (Local)</button>
            </div>
            <div class="order-buttons admin-only" style="margin-top: 10px; display: ${isAdminMode ? 'flex' : 'none'};">
              <button class="btn-trade-binance" onclick="openBinancePosition('${signal.action}')">
                <span style="font-size: 1.2em;">&#9889;</span> VAO LENH ${signal.action} TREN BINANCE
              </button>
            </div>
            <div class="admin-only" style="text-align: center; margin-top: 10px; font-size: 0.8em; color: #888; display: ${isAdminMode ? 'block' : 'none'};">
              Luu local: chi theo doi, khong giao dich that<br>
              Vao lenh Binance: dat lenh THAT tren Binance (can cau hinh API)
            </div>
          </div>
          ` : ''}
        </div>
      `;

      document.getElementById('signal-result').innerHTML = html;

      // Store current signal data for opening positions
      currentSignalData = data;

      // Auto-fill calculator
      if (signal.action !== 'WAIT') {
        const entryEl = document.getElementById('entry');
        const slEl = document.getElementById('sl');
        if (entryEl) entryEl.value = signal.entry;
        if (slEl) slEl.value = signal.stopLoss;
      }
    }

    // Scan multiple symbols - QUÉT TOÀN BỘ THỊ TRƯỜNG
    async function scanSignals() {
      const interval = document.getElementById('multi-interval').value;
      const btn = document.getElementById('scanBtn');
      const resultDiv = document.getElementById('multi-result');

      btn.disabled = true;
      btn.textContent = 'Đang quét...';
      resultDiv.innerHTML = '<div class="loading">🔍 Đang quét TOÀN BỘ thị trường Futures (~100+ đồng)...</div>';

      try {
        let data;

        if (IS_CLOUDFLARE) {
          // Client-side scan for Cloudflare - quét từ Binance trực tiếp
          console.log('[Cloudflare Mode] Scanning ALL futures symbols from browser...');

          // Lấy tất cả futures symbols
          resultDiv.innerHTML = '<div class="loading">🔍 Đang lấy danh sách symbols từ Binance...</div>';
          const exchangeInfo = await fetch('https://fapi.binance.com/fapi/v1/exchangeInfo').then(r => r.json());
          const ticker24h = await fetch('https://fapi.binance.com/fapi/v1/ticker/24hr').then(r => r.json());

          // Tạo map volume
          const volumeMap = {};
          ticker24h.forEach(t => {
            volumeMap[t.symbol] = {
              volume: parseFloat(t.quoteVolume),
              priceChange: parseFloat(t.priceChangePercent),
              lastPrice: parseFloat(t.lastPrice)
            };
          });

          // Lọc symbols có volume > 10M USDT
          const validSymbols = exchangeInfo.symbols
            .filter(s => {
              if (!s.symbol.endsWith('USDT')) return false;
              if (s.contractType !== 'PERPETUAL') return false;
              if (s.status !== 'TRADING') return false;
              if (s.symbol.includes('_')) return false;
              const vol = volumeMap[s.symbol];
              return vol && vol.volume > 10000000;
            })
            .map(s => ({ symbol: s.symbol, ...volumeMap[s.symbol] }))
            .sort((a, b) => b.volume - a.volume);

          console.log(`Found ${validSymbols.length} symbols with volume > 10M`);

          const results = [];
          let scanned = 0;

          for (const symInfo of validSymbols) {
            try {
              resultDiv.innerHTML = `<div class="loading">🔍 Đang quét ${symInfo.symbol}... (${scanned}/${validSymbols.length})</div>`;
              const candles = await fetchBinanceKlines(symInfo.symbol, interval, 100);
              const result = clientSignalEngine.analyze(candles);

              if (result.signal && result.signal.action !== 'WAIT') {
                results.push({
                  symbol: symInfo.symbol,
                  volume24h: symInfo.volume,
                  priceChange24h: symInfo.priceChange,
                  lastPrice: symInfo.lastPrice,
                  action: result.signal.action,
                  confidence: parseFloat(result.signal.confidence),
                  totalScore: result.signal.totalScore,
                  strength: result.signal.strength,
                  entry: result.signal.entry,
                  stopLoss: result.signal.stopLoss,
                  takeProfit: result.signal.takeProfit,
                  riskPercent: result.signal.riskPercent,
                  rewardPercent: result.signal.rewardPercent,
                  riskReward: result.signal.riskReward,
                  leverage: result.signal.leverage,
                  reason: result.signal.reason,
                  interval: interval
                });
              }
              scanned++;
              await new Promise(resolve => setTimeout(resolve, 30));
            } catch (err) {
              scanned++;
            }
          }

          // Sắp xếp và lấy top 3
          results.sort((a, b) => {
            const scoreA = Math.abs(a.totalScore) * 10 + a.confidence + Math.log10(a.volume24h);
            const scoreB = Math.abs(b.totalScore) * 10 + b.confidence + Math.log10(b.volume24h);
            return scoreB - scoreA;
          });

          data = {
            success: true,
            totalScanned: validSymbols.length,
            totalSignals: results.length,
            top3: results.slice(0, 3),
            allSignals: results
          };
        } else {
          // Server-side scan - QUÉT TOÀN BỘ
          const response = await fetch(`${API_BASE}/api/scan-all?interval=${interval}`);
          data = await response.json();
        }

        if (data.success) {
          renderTop3Signals(data);
        } else {
          resultDiv.innerHTML = `<div class="signal-card"><p style="color: #ff5252;">Lỗi: ${data.error}</p></div>`;
        }
      } catch (error) {
        resultDiv.innerHTML = `<div class="signal-card"><p style="color: #ff5252;">Lỗi kết nối: ${error.message}</p></div>`;
      }

      btn.disabled = false;
      btn.textContent = 'Quét tất cả';
    }

    // Render TOP 3 signals
    function renderTop3Signals(data) {
      const resultDiv = document.getElementById('multi-result');

      let html = `
        <div style="padding: 15px; background: linear-gradient(135deg, rgba(0,217,255,0.1), rgba(0,255,136,0.1)); border-radius: 12px; margin-bottom: 20px; text-align: center;">
          <h3 style="color: #00d9ff; margin-bottom: 10px;">🏆 TOP 3 TÍN HIỆU TỐT NHẤT</h3>
          <p style="color: #888; font-size: 0.9em;">
            Đã quét <strong style="color: #00ff88;">${data.totalScanned}</strong> đồng |
            Tìm thấy <strong style="color: #ffd700;">${data.totalSignals}</strong> tín hiệu
          </p>
        </div>
      `;

      if (data.top3.length === 0) {
        html += `<div class="signal-card" style="text-align: center; padding: 30px;">
          <p style="color: #ffd700;">⚠️ Không tìm thấy tín hiệu nào đủ mạnh</p>
          <p style="color: #888; margin-top: 10px;">Thị trường đang sideway hoặc chưa có điểm vào tốt</p>
        </div>`;
      } else {
        // Lưu data để dùng khi click
        window.scannedSignals = data.top3;

        // Render top 3
        data.top3.forEach((s, index) => {
          const rankEmoji = ['🥇', '🥈', '🥉'][index];
          const signalClass = s.action === 'LONG' ? 'signal-long' : 'signal-short';
          const actionColor = s.action === 'LONG' ? '#10a050' : '#ab47bc';
          const volumeFormatted = (s.volume24h / 1000000).toFixed(1) + 'M';

          html += `
            <div class="signal-card ${signalClass}" style="margin-bottom: 15px; border: 1px solid ${actionColor}60; cursor: pointer;" onclick="openTradeFromSignal(${index})">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <div>
                  <span style="font-size: 1.5em;">${rankEmoji}</span>
                  <span style="font-size: 1.3em; font-weight: bold; margin-left: 10px;">${s.symbol}</span>
                  <span style="background: ${actionColor}; color: #fff; padding: 3px 10px; border-radius: 4px; font-weight: bold; margin-left: 10px;">${s.action}</span>
                </div>
                <div style="text-align: right;">
                  <div style="color: #00d9ff; font-size: 0.85em;">Score: ${s.totalScore}</div>
                  <div style="color: #888; font-size: 0.8em;">Vol: $${volumeFormatted}</div>
                </div>
              </div>

              <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-bottom: 15px;">
                <div style="background: rgba(255,255,255,0.05); padding: 10px; border-radius: 8px; text-align: center;">
                  <div style="color: #888; font-size: 0.75em;">Entry</div>
                  <div style="color: #fff; font-weight: bold;">$${parseFloat(s.entry).toFixed(4)}</div>
                </div>
                <div style="background: rgba(255,82,82,0.1); padding: 10px; border-radius: 8px; text-align: center;">
                  <div style="color: #888; font-size: 0.75em;">Stop Loss</div>
                  <div style="color: #ff5252; font-weight: bold;">$${s.stopLoss}</div>
                  <div style="color: #ff5252; font-size: 0.75em;">${s.riskPercent}</div>
                </div>
                <div style="background: rgba(0,255,136,0.1); padding: 10px; border-radius: 8px; text-align: center;">
                  <div style="color: #888; font-size: 0.75em;">Take Profit</div>
                  <div style="color: #00ff88; font-weight: bold;">$${s.takeProfit}</div>
                  <div style="color: #00ff88; font-size: 0.75em;">${s.rewardPercent}</div>
                </div>
                <div style="background: rgba(0,217,255,0.1); padding: 10px; border-radius: 8px; text-align: center;">
                  <div style="color: #888; font-size: 0.75em;">Leverage</div>
                  <div style="color: #00d9ff; font-weight: bold;">${s.leverage}x</div>
                  <div style="color: #ffd700; font-size: 0.75em;">R:R ${s.riskReward}</div>
                </div>
              </div>

              <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                <button onclick="event.stopPropagation(); openTradeFromSignal(${index})" class="btn-${s.action.toLowerCase()}" style="flex: 1; padding: 12px; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; font-size: 1em;">
                  🚀 VÀO LỆNH ${s.action}
                </button>
                <button onclick="event.stopPropagation(); openChart('${s.symbol}')" style="padding: 12px 20px; background: rgba(0,217,255,0.2); border: 1px solid #00d9ff; color: #00d9ff; border-radius: 8px; cursor: pointer;">
                  📈
                </button>
              </div>

              <div style="background: rgba(255,255,255,0.03); padding: 10px; border-radius: 8px; font-size: 0.85em;">
                ${s.reason ? s.reason.slice(0, 3).map(r => `<div style="color: #aaa; margin: 3px 0;">${r}</div>`).join('') : ''}
              </div>
            </div>
          `;
        });
      }

      // Thêm section hiển thị tất cả signals khác
      if (data.allSignals && data.allSignals.length > 3) {
        html += `
          <div style="margin-top: 20px;">
            <details>
              <summary style="cursor: pointer; color: #00d9ff; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                📋 Xem thêm ${data.allSignals.length - 3} tín hiệu khác
              </summary>
              <div style="margin-top: 10px;">
        `;

        data.allSignals.slice(3).forEach((s, index) => {
          const actionColor = s.action === 'LONG' ? '#00ff88' : '#e040fb';
          html += `
            <div style="display: flex; justify-content: space-between; padding: 8px; background: rgba(255,255,255,0.02); margin: 5px 0; border-radius: 5px; border-left: 3px solid ${actionColor};">
              <span><strong>${s.symbol}</strong> <span style="color: ${actionColor};">${s.action}</span></span>
              <span style="color: #888;">Score: ${s.totalScore} | Entry: $${parseFloat(s.entry).toFixed(4)}</span>
            </div>
          `;
        });

        html += `</div></details></div>`;
      }

      resultDiv.innerHTML = html;
    }

    // Render multiple signals
    function renderMultiSignals(signals) {
      // Lọc bỏ lỗi và chỉ lấy những đồng có signal
      const validSignals = signals.filter(s => !s.error && s.signal);

      // Sort by signal strength (điểm cao nhất trước)
      validSignals.sort((a, b) => {
        return Math.abs(b.signal.totalScore) - Math.abs(a.signal.totalScore);
      });

      // Chỉ lấy top 15 đồng có điểm cao nhất
      const top15 = validSignals.slice(0, 15);

      // Thêm header hiển thị thông tin
      let headerHtml = `
        <div style="padding: 10px; background: rgba(255,215,0,0.1); border-radius: 8px; margin-bottom: 10px; text-align: center;">
          <span style="color: #ffd700;">📊 Top 15 đồng có tín hiệu mạnh nhất</span>
          <span style="color: #888; font-size: 0.85em;"> (từ ${signals.length} đồng)</span>
        </div>
      `;

      const html = top15.map((s, index) => {
        const signalClass = s.signal.action === 'LONG' ? 'signal-long' :
                           s.signal.action === 'SHORT' ? 'signal-short' : 'signal-wait';

        const confidence = parseFloat(s.signal.confidence) || 0;
        const rankBadge = index < 3 ? ['🥇', '🥈', '🥉'][index] : `#${index + 1}`;

        return `
          <div class="mini-signal" style="${index < 3 ? 'border: 1px solid #ffd700;' : ''}">
            <div onclick="selectSymbol('${s.symbol}')" style="cursor: pointer;">
              <div class="symbol">
                <span style="margin-right: 5px;">${rankBadge}</span>
                ${s.symbol.replace('USDT', '')}
              </div>
              <div class="price-info">$${s.currentPrice.toLocaleString()}</div>
            </div>
            <div onclick="selectSymbol('${s.symbol}')" style="cursor: pointer;">
              <div style="color: #888; font-size: 0.85em;">Score: ${s.signal.totalScore} | ${s.signal.strength}</div>
              <div class="confidence-bar">
                <div class="confidence-fill" style="width: ${confidence}%; background: ${s.signal.action === 'LONG' ? '#00ff88' : s.signal.action === 'SHORT' ? '#e040fb' : '#888'};"></div>
              </div>
            </div>
            <div style="display: flex; align-items: center; gap: 8px;">
              <button onclick="event.stopPropagation(); openChart('${s.symbol}')" style="background: none; border: 1px solid #00d9ff; color: #00d9ff; padding: 4px 10px; border-radius: 4px; cursor: pointer; font-size: 0.85em;">📈</button>
              <div class="mini-badge ${signalClass}">${s.signal.action}</div>
            </div>
          </div>
        `;
      }).join('');

      document.getElementById('multi-result').innerHTML = headerHtml + html;
    }

    // Select symbol from multi scan
    function selectSymbol(symbol) {
      const symbolEl = document.getElementById('symbol');
      if (symbolEl) symbolEl.value = symbol;
      switchTab('single');
      const tabEl = document.querySelector('.tab');
      if (tabEl) tabEl.click();
      analyzeSignal();
    }

    // Mở form vào lệnh từ tín hiệu đã quét
    async function openTradeFromSignal(index) {
      const signal = window.scannedSignals[index];
      if (!signal) {
        showToast({ type: 'error', title: 'Lỗi', message: 'Không tìm thấy tín hiệu!' });
        return;
      }

      // Lưu thông tin signal để điền sau khi phân tích
      window.pendingSignal = signal;

      // Chọn symbol và chuyển sang tab single
      const symbolEl = document.getElementById('symbol');
      if (symbolEl) symbolEl.value = signal.symbol;
      switchTab('single');

      // Phân tích symbol
      await analyzeSignal();

      // Sau khi phân tích xong, điền thông số từ signal đã quét
      setTimeout(() => {
        const orderEntry = document.getElementById('order-entry');
        const orderSl = document.getElementById('order-sl');
        const orderTp = document.getElementById('order-tp');
        const orderLeverage = document.getElementById('order-leverage');

        if (orderEntry) orderEntry.value = parseFloat(signal.entry).toFixed(6);
        if (orderSl) orderSl.value = parseFloat(signal.stopLoss);
        if (orderTp) orderTp.value = parseFloat(signal.takeProfit);
        if (orderLeverage) orderLeverage.value = signal.leverage;

        // Scroll đến form vào lệnh
        const orderForm = document.querySelector('.order-entry');
        if (orderForm) {
          orderForm.scrollIntoView({ behavior: 'smooth', block: 'center' });
          orderForm.style.animation = 'pulse 0.5s ease-in-out 2';
        }

        showToast({ type: 'success', title: 'Đã điền thông tin', message: `${signal.action} ${signal.symbol}` });
      }, 500);
    }

    // ===================== POSITION TRACKING =====================

    // Load positions from localStorage
    let openPositions = JSON.parse(localStorage.getItem('openPositions') || '[]');
    let closedPositions = JSON.parse(localStorage.getItem('closedPositions') || '[]');
    let currentSignalData = null;

    // Save positions to localStorage
    function savePositions() {
      localStorage.setItem('openPositions', JSON.stringify(openPositions));
      localStorage.setItem('closedPositions', JSON.stringify(closedPositions));
      updateOpenCount();
    }

    // Update open count in tab
    function updateOpenCount() {
      document.getElementById('open-count').textContent = openPositions.length;
    }

    // Open a new position
    function openPosition(type) {
      if (!currentSignalData) {
        showToast({
          type: 'error',
          title: 'Lỗi',
          message: 'Vui lòng phân tích coin trước!'
        });
        return;
      }

      // Get elements with null checks
      const marginEl = document.getElementById('order-margin');
      const entryEl = document.getElementById('order-entry');
      const leverageEl = document.getElementById('order-leverage');
      const slEl = document.getElementById('order-sl');
      const tpEl = document.getElementById('order-tp');

      // Check if required elements exist
      if (!marginEl || !entryEl || !leverageEl) {
        showToast({
          type: 'error',
          title: 'Lỗi',
          message: 'Vui lòng phân tích symbol trước khi vào lệnh.'
        });
        return;
      }

      const margin = parseFloat(marginEl.value);
      const entryPrice = parseFloat(entryEl.value);
      const leverage = parseInt(leverageEl.value);
      const sl = slEl ? parseFloat(slEl.value) : 0;
      const tp = tpEl ? parseFloat(tpEl.value) : 0;

      if (!margin || margin <= 0) {
        showToast({
          type: 'error',
          title: 'Lỗi',
          message: 'Vui lòng nhập số USDT margin!'
        });
        return;
      }

      const position = {
        id: Date.now(),
        symbol: currentSignalData.symbol,
        type: type, // 'LONG' or 'SHORT'
        margin: margin,
        leverage: leverage,
        entryPrice: entryPrice,
        stopLoss: sl,
        takeProfit: tp,
        quantity: (margin * leverage) / entryPrice,
        positionSize: margin * leverage,
        openTime: new Date().toISOString(),
        status: 'OPEN'
      };

      openPositions.push(position);
      savePositions();
      renderOpenPositions();

      // Calculate potential loss/profit for display
      let slLoss = 0, tpProfit = 0;
      if (sl && entryPrice && position.quantity) {
        if (type === 'LONG') {
          slLoss = (sl - entryPrice) * position.quantity;
          tpProfit = tp ? (tp - entryPrice) * position.quantity : 0;
        } else {
          slLoss = (entryPrice - sl) * position.quantity;
          tpProfit = tp ? (entryPrice - tp) * position.quantity : 0;
        }
      }

      showToast({
        type: 'success',
        title: `${type === 'LONG' ? '&#128994;' : '&#128308;'} Mở lệnh ${type} thành công!`,
        details: [
          { label: 'Symbol', value: currentSignalData.symbol, class: type.toLowerCase() },
          { label: 'Entry', value: '$' + entryPrice.toLocaleString() },
          { label: 'Margin', value: margin + ' USDT' },
          { label: 'Leverage', value: leverage + 'x' },
          { label: 'Size', value: '$' + position.positionSize.toLocaleString() },
          { label: 'Stop Loss', value: sl ? '$' + sl.toLocaleString() + ` (${slLoss.toFixed(2)}$)` : 'N/A' },
          { label: 'Take Profit', value: tp ? '$' + tp.toLocaleString() + ` (+${tpProfit.toFixed(2)}$)` : 'N/A' }
        ],
        duration: 5000
      });
    }

    // Close a position
    async function closePosition(id, closePrice = null) {
      const index = openPositions.findIndex(p => p.id === id);
      if (index === -1) return;

      const position = openPositions[index];

      // Fetch current price automatically
      if (!closePrice) {
        try {
          let currentPrice;
          if (IS_CLOUDFLARE) {
            const priceData = await fetchBinancePrice(position.symbol);
            currentPrice = priceData.price;
          } else {
            const response = await fetch(`${API_BASE}/api/price/${position.symbol}?market=futures`);
            const data = await response.json();
            if (data.success) currentPrice = data.data.price;
          }

          if (!currentPrice) {
            showToast({
              type: 'error',
              title: 'Lỗi',
              message: 'Không thể lấy giá hiện tại. Vui lòng thử lại.',
              duration: 3000
            });
            return;
          }

          // Confirm close with current price
          const result = await showConfirm(
            'Đóng lệnh ' + position.symbol,
            `Loại: <strong style="color: ${position.type === 'LONG' ? '#00ff88' : '#e040fb'}">${position.type}</strong><br>
            Entry: <strong>$${position.entryPrice.toLocaleString()}</strong><br>
            Giá hiện tại: <strong style="color: #ffc107;">$${currentPrice.toLocaleString()}</strong><br><br>
            <small style="color: #888;">Lệnh sẽ được đóng ngay với giá thị trường hiện tại.</small>`,
            true
          );

          if (!result.confirmed) return;
          closePrice = currentPrice;
        } catch (e) {
          showToast({
            type: 'error',
            title: 'Lỗi',
            message: 'Không thể lấy giá. Vui lòng thử lại.',
            duration: 3000
          });
          return;
        }
      }

      // Calculate P/L
      let pnl;
      if (position.type === 'LONG') {
        pnl = (closePrice - position.entryPrice) * position.quantity;
      } else {
        pnl = (position.entryPrice - closePrice) * position.quantity;
      }

      const pnlPercent = (pnl / position.margin) * 100;

      // Move to closed positions
      const closedPosition = {
        ...position,
        closePrice: closePrice,
        closeTime: new Date().toISOString(),
        pnl: pnl,
        pnlPercent: pnlPercent,
        status: pnl >= 0 ? 'WIN' : 'LOSS',
        closeReason: 'Manual'
      };

      closedPositions.unshift(closedPosition);
      openPositions.splice(index, 1);
      savePositions();
      renderOpenPositions();
      renderClosedPositions();
      updateStats();

      // Show result toast
      showToast({
        type: pnl >= 0 ? 'success' : 'error',
        title: pnl >= 0 ? '&#127881; Đóng lệnh thắng!' : '&#128532; Đóng lệnh thua',
        details: [
          { label: 'Symbol', value: position.symbol },
          { label: 'Loại', value: position.type, class: position.type.toLowerCase() },
          { label: 'Entry', value: '$' + position.entryPrice.toLocaleString() },
          { label: 'Đóng tại', value: '$' + closePrice.toLocaleString() },
          { label: 'P/L', value: (pnl >= 0 ? '+' : '') + pnl.toFixed(2) + '$ (' + (pnlPercent >= 0 ? '+' : '') + pnlPercent.toFixed(2) + '%)', class: pnl >= 0 ? 'long' : 'short' }
        ],
        duration: 5000
      });
    }

    // Delete a position (without closing)
    async function deletePosition(id) {
      const index = openPositions.findIndex(p => p.id === id);
      if (index === -1) return;

      const position = openPositions[index];

      const result = await showConfirm(
        'Xóa lệnh',
        `Bạn có chắc muốn xóa lệnh <strong>${position.symbol}</strong> khỏi danh sách?<br><br><small style="color: #888;">Lệnh sẽ bị xóa và không được lưu vào lịch sử.</small>`,
        true
      );

      if (!result.confirmed) return;

      openPositions.splice(index, 1);
      savePositions();
      renderOpenPositions();

      showToast({
        type: 'info',
        title: 'Đã xóa lệnh',
        message: `Lệnh ${position.type} ${position.symbol} đã được xóa khỏi danh sách.`,
        duration: 3000
      });
    }

    // Delete closed position from history
    async function deleteClosedPosition(id) {
      const index = closedPositions.findIndex(p => p.id === id);
      if (index === -1) return;

      const position = closedPositions[index];

      const result = await showConfirm(
        'Xóa khỏi lịch sử',
        `Xóa lệnh <strong>${position.symbol}</strong> khỏi lịch sử giao dịch?`,
        true
      );

      if (!result.confirmed) return;

      closedPositions.splice(index, 1);
      savePositions();
      renderClosedPositions();
      updateStats();

      showToast({
        type: 'info',
        title: 'Đã xóa',
        message: `Đã xóa lệnh ${position.symbol} khỏi lịch sử.`,
        duration: 3000
      });
    }

    // Clear all history
    async function clearAllHistory() {
      if (closedPositions.length === 0) {
        showToast({
          type: 'info',
          title: 'Thông báo',
          message: 'Không có lịch sử để xóa.',
          duration: 2000
        });
        return;
      }

      const result = await showConfirm(
        '🗑️ Xóa toàn bộ lịch sử',
        `Bạn có chắc muốn xóa <strong style="color: #ff5252;">${closedPositions.length}</strong> lệnh trong lịch sử?<br><br><small style="color: #888;">Hành động này không thể hoàn tác!</small>`,
        true
      );

      if (!result.confirmed) return;

      const count = closedPositions.length;
      closedPositions = [];
      savePositions();
      renderClosedPositions();
      updateStats();

      showToast({
        type: 'success',
        title: '🗑️ Đã xóa!',
        message: `Đã xóa ${count} lệnh khỏi lịch sử.`,
        duration: 3000
      });
    }

    // Copy position info to clipboard
    function copyPosition(id) {
      const position = openPositions.find(p => p.id === id);
      if (!position) return;

      // Calculate SL loss and TP profit
      let slLoss = 0, tpProfit = 0;
      if (position.stopLoss && position.entryPrice && position.quantity) {
        if (position.type === 'LONG') {
          slLoss = (position.stopLoss - position.entryPrice) * position.quantity;
          tpProfit = position.takeProfit ? (position.takeProfit - position.entryPrice) * position.quantity : 0;
        } else {
          slLoss = (position.entryPrice - position.stopLoss) * position.quantity;
          tpProfit = position.takeProfit ? (position.entryPrice - position.takeProfit) * position.quantity : 0;
        }
      }

      const text = `📊 ${position.symbol} - ${position.type}
━━━━━━━━━━━━━━━━━━
💰 Margin: ${position.margin.toFixed(2)} USDT
⚡ Leverage: ${position.leverage}x
📈 Size: $${position.positionSize.toLocaleString()}
🎯 Entry: $${position.entryPrice.toLocaleString()}
━━━━━━━━━━━━━━━━━━
🛑 Stop Loss: $${position.stopLoss ? position.stopLoss.toLocaleString() : 'N/A'}
✅ Take Profit: $${position.takeProfit ? position.takeProfit.toLocaleString() : 'N/A'}`;

      navigator.clipboard.writeText(text).then(() => {
        showToast({
          type: 'success',
          title: 'Đã copy!',
          message: `Thông tin lệnh ${position.symbol} đã được copy vào clipboard.`,
          duration: 2000
        });
      }).catch(err => {
        showToast({
          type: 'error',
          title: 'Lỗi',
          message: 'Không thể copy. Vui lòng thử lại.',
          duration: 3000
        });
      });
    }

    // Edit SL/TP for open position
    async function editPositionSLTP(id) {
      const position = openPositions.find(p => p.id === id);
      if (!position) return;

      // Create custom modal for editing SL/TP
      return new Promise((resolve) => {
        const overlay = document.createElement('div');
        overlay.className = 'modal-overlay';
        overlay.innerHTML = `
          <div class="modal" style="max-width: 400px;">
            <div class="modal-header">
              <span class="modal-icon">⚙️</span>
              <h3>Chỉnh sửa SL/TP</h3>
            </div>
            <div class="modal-body">
              <p style="margin-bottom: 15px;">
                <strong>${position.symbol}</strong> -
                <span style="color: ${position.type === 'LONG' ? '#00ff88' : '#e040fb'}">${position.type}</span>
                <br><small style="color: #888;">Entry: $${position.entryPrice.toLocaleString()}</small>
              </p>
              <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em;">🛑 Stop Loss</label>
                <input type="number" id="edit-sl" value="${position.stopLoss || ''}" step="0.0001"
                  style="width: 100%; padding: 12px; background: rgba(255,82,82,0.1); border: 1px solid rgba(255,82,82,0.3); border-radius: 8px; color: #ff5252; font-size: 1em;"
                  placeholder="Nhập giá Stop Loss">
              </div>
              <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em;">✅ Take Profit</label>
                <input type="number" id="edit-tp" value="${position.takeProfit || ''}" step="0.0001"
                  style="width: 100%; padding: 12px; background: rgba(0,255,136,0.1); border: 1px solid rgba(0,255,136,0.3); border-radius: 8px; color: #00ff88; font-size: 1em;"
                  placeholder="Nhập giá Take Profit">
              </div>
              <div id="edit-sltp-preview" style="background: rgba(255,255,255,0.05); padding: 10px; border-radius: 8px; font-size: 0.9em; color: #888;"></div>
            </div>
            <div class="modal-actions">
              <button class="modal-btn modal-btn-cancel" id="edit-cancel">Hủy</button>
              <button class="modal-btn modal-btn-confirm" id="edit-save">💾 Lưu thay đổi</button>
            </div>
          </div>
        `;

        document.body.appendChild(overlay);

        const slInput = overlay.querySelector('#edit-sl');
        const tpInput = overlay.querySelector('#edit-tp');
        const previewDiv = overlay.querySelector('#edit-sltp-preview');

        // Update preview when inputs change
        const updatePreview = () => {
          const sl = parseFloat(slInput.value);
          const tp = parseFloat(tpInput.value);
          let slLoss = 0, tpProfit = 0;

          if (sl && position.quantity) {
            if (position.type === 'LONG') {
              slLoss = (sl - position.entryPrice) * position.quantity;
            } else {
              slLoss = (position.entryPrice - sl) * position.quantity;
            }
          }

          if (tp && position.quantity) {
            if (position.type === 'LONG') {
              tpProfit = (tp - position.entryPrice) * position.quantity;
            } else {
              tpProfit = (position.entryPrice - tp) * position.quantity;
            }
          }

          previewDiv.innerHTML = `
            <div style="display: flex; justify-content: space-between;">
              <span>Lỗ nếu SL:</span>
              <span style="color: #ff5252;">${slLoss ? slLoss.toFixed(2) + '$' : 'N/A'}</span>
            </div>
            <div style="display: flex; justify-content: space-between; margin-top: 5px;">
              <span>Lãi nếu TP:</span>
              <span style="color: #00ff88;">${tpProfit ? '+' + tpProfit.toFixed(2) + '$' : 'N/A'}</span>
            </div>
          `;
        };

        slInput.addEventListener('input', updatePreview);
        tpInput.addEventListener('input', updatePreview);
        updatePreview();

        // Focus SL input
        setTimeout(() => slInput.focus(), 100);

        const closeModal = (saved) => {
          overlay.style.animation = 'fadeOut 0.2s ease-out forwards';
          setTimeout(() => {
            overlay.remove();
            resolve(saved);
          }, 200);
        };

        overlay.querySelector('#edit-cancel').onclick = () => closeModal(false);
        overlay.querySelector('#edit-save').onclick = () => {
          const newSL = parseFloat(slInput.value) || null;
          const newTP = parseFloat(tpInput.value) || null;

          // Update position
          position.stopLoss = newSL;
          position.takeProfit = newTP;
          savePositions();
          renderOpenPositions();

          showToast({
            type: 'success',
            title: '✅ Đã cập nhật!',
            details: [
              { label: 'Symbol', value: position.symbol },
              { label: 'Stop Loss', value: newSL ? '$' + newSL.toLocaleString() : 'Không đặt', class: 'short' },
              { label: 'Take Profit', value: newTP ? '$' + newTP.toLocaleString() : 'Không đặt', class: 'long' }
            ],
            duration: 3000
          });

          closeModal(true);
        };

        // Close on overlay click
        overlay.onclick = (e) => {
          if (e.target === overlay) closeModal(false);
        };

        // Close on Escape
        const handleEscape = (e) => {
          if (e.key === 'Escape') {
            document.removeEventListener('keydown', handleEscape);
            closeModal(false);
          }
        };
        document.addEventListener('keydown', handleEscape);
      });
    }

    // Render open positions
    function renderOpenPositions() {
      const container = document.getElementById('open-positions');

      if (openPositions.length === 0) {
        container.innerHTML = '<div class="no-positions">Chưa có lệnh nào đang mở</div>';
        document.getElementById('total-open').textContent = '0';
        document.getElementById('total-unrealized-pnl').textContent = '$0.00';
        document.getElementById('total-margin').textContent = '$0.00';
        return;
      }

      container.innerHTML = openPositions.map(p => {
        // Calculate estimated SL loss and TP profit
        let slLoss = 0, tpProfit = 0;
        if (p.stopLoss && p.entryPrice && p.quantity) {
          if (p.type === 'LONG') {
            slLoss = (p.stopLoss - p.entryPrice) * p.quantity;
            tpProfit = p.takeProfit ? (p.takeProfit - p.entryPrice) * p.quantity : 0;
          } else {
            slLoss = (p.entryPrice - p.stopLoss) * p.quantity;
            tpProfit = p.takeProfit ? (p.entryPrice - p.takeProfit) * p.quantity : 0;
          }
        }

        return `
        <div class="position-card ${p.type.toLowerCase()}" data-symbol="${p.symbol}" data-id="${p.id}">
          <div class="position-header">
            <div>
              <span class="position-symbol">${p.symbol}</span>
              <span class="signal-badge signal-${p.type.toLowerCase()}" style="font-size: 0.8em; padding: 3px 10px;">${p.type}</span>
            </div>
            <div class="position-pnl" id="pnl-${p.id}">Đang tải...</div>
          </div>
          <div class="position-details">
            <div>
              <span class="label">Margin</span>
              <span class="value">${p.margin.toFixed(2)} USDT</span>
            </div>
            <div>
              <span class="label">Leverage</span>
              <span class="value">${p.leverage}x</span>
            </div>
            <div>
              <span class="label">Entry</span>
              <span class="value">$${p.entryPrice.toLocaleString()}</span>
            </div>
            <div>
              <span class="label">Giá hiện tại</span>
              <span class="value" id="current-price-${p.id}">...</span>
            </div>
            <div>
              <span class="label">Stop Loss</span>
              <span class="value stop-loss">$${p.stopLoss ? p.stopLoss.toLocaleString() : 'N/A'} ${slLoss ? `<span style="font-size:0.85em">(${slLoss.toFixed(2)}$)</span>` : ''}</span>
            </div>
            <div>
              <span class="label">Take Profit</span>
              <span class="value take-profit">$${p.takeProfit ? p.takeProfit.toLocaleString() : 'N/A'} ${tpProfit ? `<span style="font-size:0.85em">(+${tpProfit.toFixed(2)}$)</span>` : ''}</span>
            </div>
          </div>
          <div class="position-actions">
            <button class="btn-copy" onclick="copyPosition(${p.id})">📋 Copy</button>
            <button class="btn-edit" onclick="editPositionSLTP(${p.id})" style="background: linear-gradient(135deg, #ffc107 0%, #ff9800 100%);">⚙️ SL/TP</button>
            <button class="btn-close-profit" onclick="closePosition(${p.id})">Đóng lệnh</button>
            <button class="btn-delete" onclick="deletePosition(${p.id})">Xóa</button>
          </div>
          ${isAdminMode ? `<div class="position-actions" style="margin-top: 5px;">
            <button onclick="closePositionOnBinance(${p.id})" style="flex: 1; background: linear-gradient(135deg, #f0b90b 0%, #d4a40a 100%); border: none; color: #000; padding: 10px 15px; border-radius: 8px; cursor: pointer; font-weight: bold;">⚡ Dong lenh tren Binance</button>
          </div>` : ''}
        </div>
      `}).join('');

      // Update P/L for all positions
      updateAllPositionsPnL();
    }

    // Render closed positions
    function renderClosedPositions() {
      const container = document.getElementById('closed-positions');

      if (closedPositions.length === 0) {
        container.innerHTML = '<div class="no-positions">Chưa có lịch sử giao dịch</div>';
        return;
      }

      container.innerHTML = closedPositions.map(p => {
        // Calculate estimated SL loss and TP profit (from original position)
        let slLoss = 0, tpProfit = 0;
        if (p.stopLoss && p.entryPrice && p.quantity) {
          if (p.type === 'LONG') {
            slLoss = (p.stopLoss - p.entryPrice) * p.quantity;
            tpProfit = p.takeProfit ? (p.takeProfit - p.entryPrice) * p.quantity : 0;
          } else {
            slLoss = (p.entryPrice - p.stopLoss) * p.quantity;
            tpProfit = p.takeProfit ? (p.entryPrice - p.takeProfit) * p.quantity : 0;
          }
        }

        return `
        <div class="position-card ${p.type.toLowerCase()} ${p.pnl >= 0 ? 'profit' : 'loss'}">
          <div class="position-header">
            <div>
              <span class="position-symbol">${p.symbol}</span>
              <span class="signal-badge signal-${p.type.toLowerCase()}" style="font-size: 0.8em; padding: 3px 10px;">${p.type}</span>
              <span style="color: ${p.pnl >= 0 ? '#00ff88' : '#ff5252'}; font-size: 0.85em; margin-left: 10px;">${p.status}</span>
              ${p.closeReason ? `<span style="background: ${p.closeReason === 'TP' ? 'rgba(0,255,136,0.2)' : p.closeReason === 'SL' ? 'rgba(255,82,82,0.2)' : 'rgba(255,193,7,0.2)'}; color: ${p.closeReason === 'TP' ? '#00ff88' : p.closeReason === 'SL' ? '#ff5252' : '#ffc107'}; padding: 2px 8px; border-radius: 4px; font-size: 0.75em; margin-left: 8px;">${p.closeReason === 'TP' ? '🎯 Auto TP' : p.closeReason === 'SL' ? '🛑 Auto SL' : '✋ Manual'}</span>` : ''}
            </div>
            <div class="position-pnl ${p.pnl >= 0 ? 'profit' : 'loss'}">
              ${p.pnl >= 0 ? '+' : ''}$${p.pnl.toFixed(2)} (${p.pnlPercent >= 0 ? '+' : ''}${p.pnlPercent.toFixed(1)}%)
            </div>
          </div>
          <div class="position-details">
            <div>
              <span class="label">Margin</span>
              <span class="value">${p.margin.toFixed(2)} USDT</span>
            </div>
            <div>
              <span class="label">Leverage</span>
              <span class="value">${p.leverage}x</span>
            </div>
            <div>
              <span class="label">Entry</span>
              <span class="value">$${p.entryPrice.toLocaleString()}</span>
            </div>
            <div>
              <span class="label">Đóng tại</span>
              <span class="value">$${p.closePrice.toLocaleString()}</span>
            </div>
            <div>
              <span class="label">Stop Loss</span>
              <span class="value stop-loss">$${p.stopLoss ? p.stopLoss.toLocaleString() : 'N/A'} ${slLoss ? `<span style="font-size:0.85em">(${slLoss.toFixed(2)}$)</span>` : ''}</span>
            </div>
            <div>
              <span class="label">Take Profit</span>
              <span class="value take-profit">$${p.takeProfit ? p.takeProfit.toLocaleString() : 'N/A'} ${tpProfit ? `<span style="font-size:0.85em">(+${tpProfit.toFixed(2)}$)</span>` : ''}</span>
            </div>
          </div>
          <div class="position-actions">
            <button class="btn-delete" onclick="deleteClosedPosition(${p.id})">Xóa khỏi lịch sử</button>
          </div>
        </div>
      `}).join('');
    }

    // Update stats
    function updateStats() {
      const totalClosed = closedPositions.length;
      const totalPnL = closedPositions.reduce((sum, p) => sum + p.pnl, 0);
      const wins = closedPositions.filter(p => p.pnl >= 0).length;
      const losses = closedPositions.filter(p => p.pnl < 0).length;
      const winRate = totalClosed > 0 ? (wins / totalClosed * 100).toFixed(1) : 0;

      document.getElementById('total-closed').textContent = totalClosed;
      document.getElementById('total-pnl').textContent = `${totalPnL >= 0 ? '+' : ''}$${totalPnL.toFixed(2)}`;
      document.getElementById('total-pnl').style.color = totalPnL >= 0 ? '#00ff88' : '#ff5252';
      document.getElementById('win-rate').textContent = `${winRate}%`;
      document.getElementById('win-rate').style.color = winRate >= 50 ? '#00ff88' : '#ff5252';
      document.getElementById('win-loss').textContent = `${wins} / ${losses}`;
    }

    // Update P/L for all open positions
    // Auto close position when hit SL/TP
    async function autoClosePosition(position, closePrice, reason) {
      const index = openPositions.findIndex(p => p.id === position.id);
      if (index === -1) return;

      // Calculate P/L
      let pnl;
      if (position.type === 'LONG') {
        pnl = (closePrice - position.entryPrice) * position.quantity;
      } else {
        pnl = (position.entryPrice - closePrice) * position.quantity;
      }

      const pnlPercent = (pnl / position.margin) * 100;

      // Move to closed positions
      const closedPosition = {
        ...position,
        closePrice: closePrice,
        closeTime: new Date().toISOString(),
        pnl: pnl,
        pnlPercent: pnlPercent,
        status: pnl >= 0 ? 'WIN' : 'LOSS',
        closeReason: reason // 'SL' or 'TP'
      };

      closedPositions.unshift(closedPosition);
      openPositions.splice(index, 1);
      savePositions();
      renderOpenPositions();
      renderClosedPositions();
      updateStats();

      // Show auto-close toast
      const isTP = reason === 'TP';
      showToast({
        type: isTP ? 'success' : 'error',
        title: isTP ? '🎯 Take Profit đã chạm!' : '🛑 Stop Loss đã chạm!',
        details: [
          { label: 'Symbol', value: position.symbol },
          { label: 'Loại', value: position.type, class: position.type.toLowerCase() },
          { label: 'Entry', value: '$' + position.entryPrice.toLocaleString() },
          { label: isTP ? 'TP' : 'SL', value: '$' + closePrice.toLocaleString() },
          { label: 'P/L', value: (pnl >= 0 ? '+' : '') + pnl.toFixed(2) + '$ (' + (pnlPercent >= 0 ? '+' : '') + pnlPercent.toFixed(2) + '%)', class: pnl >= 0 ? 'long' : 'short' }
        ],
        duration: 8000
      });

      // Play sound notification
      try {
        const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1jZWlrd3x/g4aGhYOBgX99e3p5eXl5eXl6e3x+gIKEhoeIiIiHhYOBf3x6eHZ1dHR0dHV2eHl8f4GDhoeIiYmJiIeGhIJ/fXp4dnRzc3NzdHV3eXx+gYOFh4iJiYmJiIeGhIJ/fXp4dnRzc3NzdHV3eXt+gYOFh4iJiYmJiIeGhIJ/fXp4dnRzc3Nz');
        audio.volume = 0.5;
        audio.play().catch(() => {});
      } catch (e) {}
    }

    async function updateAllPositionsPnL() {
      let totalUnrealizedPnL = 0;
      let totalMargin = 0;
      const positionsToAutoClose = []; // Collect positions to auto close

      for (const position of openPositions) {
        try {
          let currentPrice;

          if (IS_CLOUDFLARE) {
            // Fetch price directly from Binance for Cloudflare
            const priceData = await fetchBinancePrice(position.symbol);
            currentPrice = priceData.price;
          } else {
            const response = await fetch(`${API_BASE}/api/price/${position.symbol}?market=futures`);
            const data = await response.json();
            if (!data.success) continue;
            currentPrice = data.data.price;
          }

          if (currentPrice) {
            // Check SL/TP hit
            const sl = position.stopLoss ? parseFloat(position.stopLoss) : null;
            const tp = position.takeProfit ? parseFloat(position.takeProfit) : null;

            if (position.type === 'LONG') {
              // LONG: SL khi giá xuống dưới SL, TP khi giá lên trên TP
              if (sl && currentPrice <= sl) {
                positionsToAutoClose.push({ position, closePrice: sl, reason: 'SL' });
                continue;
              }
              if (tp && currentPrice >= tp) {
                positionsToAutoClose.push({ position, closePrice: tp, reason: 'TP' });
                continue;
              }
            } else {
              // SHORT: SL khi giá lên trên SL, TP khi giá xuống dưới TP
              if (sl && currentPrice >= sl) {
                positionsToAutoClose.push({ position, closePrice: sl, reason: 'SL' });
                continue;
              }
              if (tp && currentPrice <= tp) {
                positionsToAutoClose.push({ position, closePrice: tp, reason: 'TP' });
                continue;
              }
            }

            let pnl;

            if (position.type === 'LONG') {
              pnl = (currentPrice - position.entryPrice) * position.quantity;
            } else {
              pnl = (position.entryPrice - currentPrice) * position.quantity;
            }

            const pnlPercent = (pnl / position.margin) * 100;
            totalUnrealizedPnL += pnl;
            totalMargin += position.margin;

            // Update UI
            const pnlEl = document.getElementById(`pnl-${position.id}`);
            const priceEl = document.getElementById(`current-price-${position.id}`);

            if (pnlEl) {
              pnlEl.textContent = `${pnl >= 0 ? '+' : ''}$${pnl.toFixed(2)} (${pnlPercent >= 0 ? '+' : ''}${pnlPercent.toFixed(1)}%)`;
              pnlEl.className = `position-pnl ${pnl >= 0 ? 'profit' : 'loss'}`;
            }

            if (priceEl) {
              priceEl.textContent = `$${currentPrice.toLocaleString()}`;
            }
          }
        } catch (e) {
          console.error(`Error fetching price for ${position.symbol}:`, e);
        }
      }

      // Auto close positions that hit SL/TP (do this after the loop to avoid modifying array while iterating)
      for (const item of positionsToAutoClose) {
        await autoClosePosition(item.position, item.closePrice, item.reason);
      }

      // Update totals
      document.getElementById('total-open').textContent = openPositions.length;
      document.getElementById('total-unrealized-pnl').textContent = `${totalUnrealizedPnL >= 0 ? '+' : ''}$${totalUnrealizedPnL.toFixed(2)}`;
      document.getElementById('total-unrealized-pnl').style.color = totalUnrealizedPnL >= 0 ? '#00ff88' : '#ff5252';
      document.getElementById('total-margin').textContent = `$${totalMargin.toFixed(2)}`;
    }

    // Auto-refresh price and P/L
    setInterval(async () => {
      const symbol = document.getElementById('symbol').value;
      try {
        let price;

        if (IS_CLOUDFLARE) {
          const priceData = await fetchBinancePrice(symbol);
          price = priceData.price;
        } else {
          const response = await fetch(`${API_BASE}/api/price/${symbol}`);
          const data = await response.json();
          if (data.success) price = data.data.price;
        }

        if (price) {
          const priceEl = document.querySelector('.price');
          if (priceEl) {
            priceEl.textContent = '$' + price.toLocaleString();
          }
        }
      } catch (e) {}

      // Update open positions P/L
      if (openPositions.length > 0) {
        updateAllPositionsPnL();
      }
    }, 5000); // Update every 5 seconds

    // Initialize
    function initPositions() {
      updateOpenCount();
      renderOpenPositions();
      renderClosedPositions();
      updateStats();
    }

    // Initial analysis
    analyzeSignal();
    initPositions();

    // ===================== CHART MODAL FUNCTIONS =====================
    function openChart(symbol) {
      const cleanSymbol = symbol.replace('USDT', '');
      const chartSymbol = `BINANCE:${cleanSymbol}USDT.P`; // .P for Perpetual Futures

      document.getElementById('chart-modal-title').textContent = `${cleanSymbol}/USDT - Binance Futures`;

      // TradingView Widget URL
      const widgetUrl = `https://s.tradingview.com/widgetembed/?frameElementId=tradingview_chart&symbol=${chartSymbol}&interval=60&hidesidetoolbar=0&symboledit=1&saveimage=1&toolbarbg=1a1a2e&studies=%5B%5D&theme=dark&style=1&timezone=Asia%2FHo_Chi_Minh&studies_overrides=%7B%7D&overrides=%7B%7D&enabled_features=%5B%5D&disabled_features=%5B%5D&locale=vi_VN&utm_source=&utm_medium=widget&utm_campaign=chart&utm_term=${chartSymbol}`;

      document.getElementById('tradingview-chart').src = widgetUrl;
      document.getElementById('chart-modal-overlay').classList.add('active');
      document.body.style.overflow = 'hidden';
    }

    function closeChart() {
      document.getElementById('chart-modal-overlay').classList.remove('active');
      document.getElementById('tradingview-chart').src = '';
      document.body.style.overflow = '';
    }

    // Chart modal events - sẽ được khởi tạo trong DOMContentLoaded
    function initChartModal() {
      const chartOverlay = document.getElementById('chart-modal-overlay');
      if (chartOverlay) {
        chartOverlay.addEventListener('click', function(e) {
          if (e.target === this) {
            closeChart();
          }
        });
      }

      // Close chart modal on Escape key
      document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
          closeChart();
        }
      });
    }
  </script>

  <!-- Chart Modal -->
  <div id="chart-modal-overlay" class="chart-modal-overlay">
    <div class="chart-modal">
      <div class="chart-modal-header">
        <div class="chart-modal-title">
          <span id="chart-modal-title">BTC/USDT - Binance Futures</span>
        </div>
        <button class="chart-modal-close" onclick="closeChart()">&times;</button>
      </div>
      <div class="chart-modal-body">
        <iframe id="tradingview-chart" src="" allowfullscreen></iframe>
      </div>
    </div>
  </div>

  <!-- Binance API Config Button (Admin Only) -->
  <button class="api-config-btn admin-only" id="api-config-btn" onclick="openApiConfig()" title="Cau hinh Binance API" style="display: none;">
    <span id="api-icon">&#128274;</span>
  </button>

  <!-- Binance API Config Modal -->
  <div id="api-modal-overlay" class="api-modal-overlay" onclick="closeApiConfig(event)">
    <div class="api-modal" onclick="event.stopPropagation()">
      <button class="api-modal-close" onclick="closeApiConfig()">&times;</button>
      <h3><span>&#128274;</span> Binance API Config</h3>
      <div class="subtitle">Ket noi tai khoan Binance de giao dich truc tiep</div>

      <div class="api-warning">
        <strong>Luu y bao mat:</strong>
        API Key duoc luu LOCAL tren trinh duyet cua ban, KHONG gui len server. Chi cap quyen FUTURES, khong cap quyen rut tien.
      </div>

      <div id="api-status-display" class="api-status disconnected">
        <span>&#9679;</span> Chua ket noi
      </div>

      <div id="api-balance-display" class="api-balance" style="display: none;">
        <div class="api-balance-row">
          <span class="api-balance-label">Tong so du:</span>
          <span class="api-balance-value" id="api-total-balance">0.00 USDT</span>
        </div>
        <div class="api-balance-row">
          <span class="api-balance-label">Kha dung:</span>
          <span class="api-balance-value" id="api-available-balance">0.00 USDT</span>
        </div>
        <div class="api-balance-row">
          <span class="api-balance-label">PnL chua thuc hien:</span>
          <span class="api-balance-value" id="api-unrealized-pnl">0.00 USDT</span>
        </div>
      </div>

      <div class="api-input-group">
        <label>API Key</label>
        <input type="text" id="api-key-input" placeholder="Nhap Binance API Key">
      </div>

      <div class="api-input-group">
        <label>Secret Key</label>
        <input type="password" id="api-secret-input" placeholder="Nhap Binance Secret Key">
      </div>

      <div class="api-input-group">
        <label style="display: flex; align-items: center; gap: 10px;">
          <input type="checkbox" id="api-testnet-checkbox" style="width: auto;">
          Su dung Testnet <span class="testnet-badge">Demo</span>
        </label>
      </div>

      <div class="api-buttons">
        <button class="btn-api-test" onclick="testApiConnection()">Test ket noi</button>
        <button class="btn-api-save" onclick="saveApiConfig()">Luu API</button>
      </div>
      <div class="api-buttons" style="margin-top: 10px;">
        <button class="btn-api-clear" onclick="clearApiConfig()">Xoa API</button>
      </div>
    </div>
  </div>

  <!-- Donate Float Button -->
  <div class="donate-container" onclick="openDonate()">
    <div class="donate-label">Ung ho tac gia</div>
    <button class="donate-float-btn" title="Mua tac gia ly cafe">
      <span>&#9749;</span>
      <span class="donate-badge">NEW</span>
    </button>
  </div>

  <!-- Donate Modal -->
  <div id="donate-modal-overlay" class="donate-modal-overlay" onclick="closeDonate(event)">
    <div class="donate-modal" onclick="event.stopPropagation()">
      <button class="donate-modal-close" onclick="closeDonate()">&times;</button>
      <div class="donate-title">Mua tac gia ly cafe</div>
      <div class="donate-subtitle">Trade co loi? Ung ho de phat trien them tinh nang moi nhe!</div>
      <div class="donate-qr-container">
        <img src="donate-qr.jpg" alt="QR Donate Techcombank">
      </div>
      <div class="donate-info">
        <strong>Techcombank</strong><br>
        Quet ma QR bang app ngan hang bat ky
      </div>
      <div class="donate-thanks">
        Cam on ban da ung ho! Chuc ban trade thanh cong!
      </div>
    </div>
  </div>

  <script>
    // Donate modal functions
    function openDonate() {
      document.getElementById('donate-modal-overlay').classList.add('active');
    }

    function closeDonate(event) {
      if (!event || event.target.id === 'donate-modal-overlay' || event.target.classList.contains('donate-modal-close')) {
        document.getElementById('donate-modal-overlay').classList.remove('active');
      }
    }

    // Close donate modal on Escape key
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape') {
        closeDonate();
        closeApiConfig();
      }
    });
  </script>

  <script>
    // Show/Hide Binance features based on admin mode
    function showBinanceFeatures() {
      const elements = document.querySelectorAll('.admin-only');
      elements.forEach(el => {
        el.style.display = isAdminMode ? '' : 'none';
      });
    }

    // ===================== BINANCE TRADING SERVICE (Client-side) =====================

    const BINANCE_LIVE_URL = 'https://fapi.binance.com';
    const BINANCE_TESTNET_URL = 'https://testnet.binancefuture.com';

    // API Config state
    let binanceApiConfig = {
      apiKey: '',
      secretKey: '',
      testnet: false,
      connected: false,
      balance: null
    };

    // Load saved API config on page load
    function loadApiConfig() {
      const saved = localStorage.getItem('binance_api_config');
      if (saved) {
        try {
          const config = JSON.parse(saved);
          binanceApiConfig.apiKey = config.apiKey || '';
          binanceApiConfig.secretKey = config.secretKey || '';
          binanceApiConfig.testnet = config.testnet || false;

          // Fill form (with null checks)
          const apiKeyEl = document.getElementById('api-key-input');
          const apiSecretEl = document.getElementById('api-secret-input');
          const testnetEl = document.getElementById('api-testnet-checkbox');
          if (apiKeyEl) apiKeyEl.value = binanceApiConfig.apiKey;
          if (apiSecretEl) apiSecretEl.value = binanceApiConfig.secretKey;
          if (testnetEl) testnetEl.checked = binanceApiConfig.testnet;

          // Auto test connection if keys exist
          if (binanceApiConfig.apiKey && binanceApiConfig.secretKey) {
            testApiConnection();
          }
        } catch (e) {
          console.error('Error loading API config:', e);
        }
      }
    }

    // Open API config modal
    function openApiConfig() {
      document.getElementById('api-modal-overlay').classList.add('active');
      loadApiConfig();
    }

    // Close API config modal
    function closeApiConfig(event) {
      if (!event || event.target.id === 'api-modal-overlay' || event.target.classList.contains('api-modal-close')) {
        document.getElementById('api-modal-overlay').classList.remove('active');
      }
    }

    // Create HMAC SHA256 signature
    async function createSignature(queryString, secretKey) {
      const encoder = new TextEncoder();
      const keyData = encoder.encode(secretKey);
      const messageData = encoder.encode(queryString);

      const cryptoKey = await crypto.subtle.importKey(
        'raw',
        keyData,
        { name: 'HMAC', hash: 'SHA-256' },
        false,
        ['sign']
      );

      const signature = await crypto.subtle.sign('HMAC', cryptoKey, messageData);
      return Array.from(new Uint8Array(signature))
        .map(b => b.toString(16).padStart(2, '0'))
        .join('');
    }

    // Send signed request to Binance
    async function binanceSignedRequest(method, endpoint, params = {}) {
      const baseUrl = binanceApiConfig.testnet ? BINANCE_TESTNET_URL : BINANCE_LIVE_URL;
      const timestamp = Date.now();
      const queryParams = { ...params, timestamp };

      const queryString = Object.keys(queryParams)
        .map(key => `${key}=${queryParams[key]}`)
        .join('&');

      const signature = await createSignature(queryString, binanceApiConfig.secretKey);
      const url = `${baseUrl}${endpoint}?${queryString}&signature=${signature}`;

      const response = await fetch(url, {
        method,
        headers: {
          'X-MBX-APIKEY': binanceApiConfig.apiKey
        }
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.msg || `Binance API error: ${response.status}`);
      }

      return data;
    }

    // Test API connection
    async function testApiConnection() {
      const apiKey = document.getElementById('api-key-input').value.trim();
      const secretKey = document.getElementById('api-secret-input').value.trim();
      const testnet = document.getElementById('api-testnet-checkbox').checked;

      if (!apiKey || !secretKey) {
        showToast({ type: 'error', title: 'Loi', message: 'Vui long nhap API Key va Secret Key' });
        return;
      }

      // Temporarily set config for testing
      binanceApiConfig.apiKey = apiKey;
      binanceApiConfig.secretKey = secretKey;
      binanceApiConfig.testnet = testnet;

      const statusDisplay = document.getElementById('api-status-display');
      const balanceDisplay = document.getElementById('api-balance-display');

      statusDisplay.innerHTML = '<span>&#8987;</span> Dang ket noi...';
      statusDisplay.className = 'api-status disconnected';

      try {
        // Get account info
        const account = await binanceSignedRequest('GET', '/fapi/v2/account');

        // Find USDT balance
        const usdtAsset = account.assets.find(a => a.asset === 'USDT');
        const totalBalance = parseFloat(usdtAsset?.walletBalance || 0);
        const availableBalance = parseFloat(usdtAsset?.availableBalance || 0);
        const unrealizedPnl = parseFloat(usdtAsset?.unrealizedProfit || 0);

        binanceApiConfig.connected = true;
        binanceApiConfig.balance = { totalBalance, availableBalance, unrealizedPnl };

        // Update UI
        statusDisplay.innerHTML = '<span>&#9679;</span> Da ket noi' + (testnet ? ' <span class="testnet-badge">Testnet</span>' : '');
        statusDisplay.className = 'api-status connected';

        document.getElementById('api-total-balance').textContent = totalBalance.toFixed(2) + ' USDT';
        document.getElementById('api-available-balance').textContent = availableBalance.toFixed(2) + ' USDT';
        document.getElementById('api-unrealized-pnl').textContent = (unrealizedPnl >= 0 ? '+' : '') + unrealizedPnl.toFixed(2) + ' USDT';
        document.getElementById('api-unrealized-pnl').style.color = unrealizedPnl >= 0 ? '#00ff88' : '#ff5252';
        balanceDisplay.style.display = 'block';

        // Update button state
        document.getElementById('api-config-btn').classList.add('connected');
        document.getElementById('api-icon').innerHTML = '&#9989;';

        showToast({ type: 'success', title: 'Ket noi thanh cong!', message: `So du: ${totalBalance.toFixed(2)} USDT` });

      } catch (error) {
        binanceApiConfig.connected = false;
        binanceApiConfig.balance = null;

        statusDisplay.innerHTML = '<span>&#9679;</span> Ket noi that bai: ' + error.message;
        statusDisplay.className = 'api-status disconnected';
        balanceDisplay.style.display = 'none';

        document.getElementById('api-config-btn').classList.remove('connected');
        document.getElementById('api-icon').innerHTML = '&#128274;';

        showToast({ type: 'error', title: 'Ket noi that bai', message: error.message });
      }
    }

    // Save API config
    function saveApiConfig() {
      const apiKey = document.getElementById('api-key-input').value.trim();
      const secretKey = document.getElementById('api-secret-input').value.trim();
      const testnet = document.getElementById('api-testnet-checkbox').checked;

      if (!apiKey || !secretKey) {
        showToast({ type: 'error', title: 'Loi', message: 'Vui long nhap API Key va Secret Key' });
        return;
      }

      localStorage.setItem('binance_api_config', JSON.stringify({
        apiKey,
        secretKey,
        testnet
      }));

      binanceApiConfig.apiKey = apiKey;
      binanceApiConfig.secretKey = secretKey;
      binanceApiConfig.testnet = testnet;

      showToast({ type: 'success', title: 'Da luu!', message: 'API Key da duoc luu vao trinh duyet' });
      closeApiConfig();
    }

    // Clear API config
    function clearApiConfig() {
      localStorage.removeItem('binance_api_config');

      binanceApiConfig = {
        apiKey: '',
        secretKey: '',
        testnet: false,
        connected: false,
        balance: null
      };

      // Clear form with null checks
      const setVal = (id, val) => { const e = document.getElementById(id); if (e) e.value = val; };
      const setHtml = (id, html) => { const e = document.getElementById(id); if (e) e.innerHTML = html; };
      const setStyle = (id, prop, val) => { const e = document.getElementById(id); if (e) e.style[prop] = val; };

      setVal('api-key-input', '');
      setVal('api-secret-input', '');
      const testnetEl = document.getElementById('api-testnet-checkbox');
      if (testnetEl) testnetEl.checked = false;

      const statusEl = document.getElementById('api-status-display');
      if (statusEl) {
        statusEl.innerHTML = '<span>&#9679;</span> Chua ket noi';
        statusEl.className = 'api-status disconnected';
      }

      setStyle('api-balance-display', 'display', 'none');

      const configBtn = document.getElementById('api-config-btn');
      if (configBtn) configBtn.classList.remove('connected');

      setHtml('api-icon', '&#128274;');

      showToast({ type: 'info', title: 'Da xoa!', message: 'API Key da bi xoa khoi trinh duyet' });
    }

    // ===================== BINANCE POSITION SYNC =====================

    // Close position on Binance
    async function closeBinancePosition(localPosition) {
      if (!binanceApiConfig.connected) {
        showToast({ type: 'error', title: 'Loi', message: 'Chua ket noi Binance API' });
        return false;
      }

      try {
        const side = localPosition.type === 'LONG' ? 'SELL' : 'BUY';
        const symbolInfo = await getSymbolInfo(localPosition.symbol);
        const quantity = roundQuantity(localPosition.quantity, symbolInfo.stepSize);

        const result = await placeBinanceOrder(localPosition.symbol, side, quantity, 'MARKET');

        showToast({
          type: 'success',
          title: 'Da dong lenh tren Binance!',
          message: `${localPosition.symbol} ${localPosition.type} - Order ID: ${result.orderId}`
        });

        return true;
      } catch (error) {
        showToast({ type: 'error', title: 'Loi dong lenh', message: error.message });
        return false;
      }
    }

    // Wrapper function to close position on Binance by ID
    async function closePositionOnBinance(positionId) {
      const position = openPositions.find(p => p.id === positionId);
      if (!position) {
        showToast({ type: 'error', title: 'Loi', message: 'Khong tim thay lenh' });
        return;
      }

      if (!binanceApiConfig.connected) {
        showToast({ type: 'error', title: 'Loi', message: 'Chua ket noi Binance API. Click vao nut khoa de cau hinh.' });
        return;
      }

      // Confirm before closing
      const confirmed = await showConfirm(
        'Xac nhan dong lenh tren Binance',
        `Symbol: ${position.symbol}<br>` +
        `Loai: ${position.type}<br>` +
        `So luong: ${position.quantity.toFixed(6)}<br>` +
        `<br><strong style="color: #ff5252;">Lenh se duoc DONG THAT tren Binance!</strong>`,
        false
      );

      if (!confirmed.confirmed) return;

      showToast({ type: 'info', title: 'Dang dong lenh...', message: 'Vui long doi...' });

      const success = await closeBinancePosition(position);

      if (success) {
        // Also close local position
        closePosition(positionId);
        // Refresh balance
        testApiConnection();
      }
    }

    // Get symbol info for precision
    async function getSymbolInfo(symbol) {
      const baseUrl = binanceApiConfig.testnet ? BINANCE_TESTNET_URL : BINANCE_LIVE_URL;
      const response = await fetch(`${baseUrl}/fapi/v1/exchangeInfo`);
      const data = await response.json();
      const symbolInfo = data.symbols.find(s => s.symbol === symbol);

      if (!symbolInfo) {
        throw new Error(`Symbol ${symbol} khong ton tai`);
      }

      const lotSizeFilter = symbolInfo.filters.find(f => f.filterType === 'LOT_SIZE');
      const priceFilter = symbolInfo.filters.find(f => f.filterType === 'PRICE_FILTER');

      return {
        pricePrecision: symbolInfo.pricePrecision,
        quantityPrecision: symbolInfo.quantityPrecision,
        stepSize: parseFloat(lotSizeFilter?.stepSize || 0),
        tickSize: parseFloat(priceFilter?.tickSize || 0)
      };
    }

    // Round quantity to correct precision
    function roundQuantity(quantity, stepSize) {
      const precision = Math.round(-Math.log10(stepSize));
      return Math.floor(quantity * Math.pow(10, precision)) / Math.pow(10, precision);
    }

    // Round price to correct precision
    function roundPrice(price, tickSize) {
      const precision = Math.round(-Math.log10(tickSize));
      return Math.round(price * Math.pow(10, precision)) / Math.pow(10, precision);
    }

    // Place order on Binance
    async function placeBinanceOrder(symbol, side, quantity, orderType = 'MARKET', price = null) {
      const params = {
        symbol: symbol.toUpperCase(),
        side,
        type: orderType,
        quantity
      };

      if (orderType === 'LIMIT' && price) {
        params.price = price;
        params.timeInForce = 'GTC';
      }

      return binanceSignedRequest('POST', '/fapi/v1/order', params);
    }

    // Place stop loss order - Su dung STOP LIMIT order
    async function placeStopLoss(symbol, side, quantity, stopPrice) {
      const closeSide = side === 'BUY' ? 'SELL' : 'BUY';
      const params = {
        symbol: symbol.toUpperCase(),
        side: closeSide,
        type: 'STOP',
        stopPrice: stopPrice.toString(),
        price: stopPrice.toString(),
        quantity: quantity.toString(),
        reduceOnly: 'true',
        timeInForce: 'GTC',
        workingType: 'MARK_PRICE'
      };
      console.log('[placeStopLoss] Params:', params);
      return binanceSignedRequest('POST', '/fapi/v1/order', params);
    }

    // Place take profit order - Su dung TAKE_PROFIT LIMIT order
    async function placeTakeProfit(symbol, side, quantity, stopPrice) {
      const closeSide = side === 'BUY' ? 'SELL' : 'BUY';
      const params = {
        symbol: symbol.toUpperCase(),
        side: closeSide,
        type: 'TAKE_PROFIT',
        stopPrice: stopPrice.toString(),
        price: stopPrice.toString(),
        quantity: quantity.toString(),
        reduceOnly: 'true',
        timeInForce: 'GTC',
        workingType: 'MARK_PRICE'
      };
      console.log('[placeTakeProfit] Params:', params);
      return binanceSignedRequest('POST', '/fapi/v1/order', params);
    }

    // Set leverage
    async function setLeverage(symbol, leverage) {
      return binanceSignedRequest('POST', '/fapi/v1/leverage', {
        symbol: symbol.toUpperCase(),
        leverage
      });
    }

    // Set margin type
    async function setMarginType(symbol, marginType = 'ISOLATED') {
      try {
        return await binanceSignedRequest('POST', '/fapi/v1/marginType', {
          symbol: symbol.toUpperCase(),
          marginType
        });
      } catch (error) {
        // Ignore if already set to this type
        if (!error.message.includes('No need to change margin type')) {
          throw error;
        }
      }
    }

    // Execute trade on Binance with SL/TP
    async function executeBinanceTrade(symbol, side, margin, leverage, entryPrice, stopLoss, takeProfit) {
      if (!binanceApiConfig.connected) {
        throw new Error('Chua ket noi Binance API. Vui long cau hinh API truoc.');
      }

      const results = {
        leverage: null,
        mainOrder: null,
        slOrder: null,
        tpOrder: null,
        errors: []
      };

      try {
        // 1. Get symbol info
        const symbolInfo = await getSymbolInfo(symbol);

        // 2. Calculate position size
        const positionValue = margin * leverage;
        const quantity = roundQuantity(positionValue / entryPrice, symbolInfo.stepSize);

        if (quantity <= 0) {
          throw new Error('So luong qua nho, tang margin hoac leverage');
        }

        // 3. Set leverage
        results.leverage = await setLeverage(symbol, leverage);

        // 4. Set margin type
        await setMarginType(symbol, 'ISOLATED');

        // 5. Place main order
        const orderSide = side === 'LONG' ? 'BUY' : 'SELL';
        results.mainOrder = await placeBinanceOrder(symbol, orderSide, quantity, 'MARKET');
        console.log('[Trade] Main order result:', results.mainOrder);

        // Doi 500ms de lenh duoc xu ly hoan toan
        await new Promise(resolve => setTimeout(resolve, 500));

        // Lay gia thuc te va so luong thuc te tu lenh
        const actualEntryPrice = parseFloat(results.mainOrder.avgPrice) || entryPrice;
        const actualQuantity = parseFloat(results.mainOrder.executedQty) || quantity;
        console.log('[Trade] Actual entry price:', actualEntryPrice, 'Original entry:', entryPrice);
        console.log('[Trade] Actual quantity:', actualQuantity, 'Original quantity:', quantity);

        // NOTE: SL/TP khong duoc ho tro qua API Binance voi quyen hien tai
        // Ban can tu dat SL/TP tren app Binance sau khi vao lenh
        console.log('[Trade] SL/TP khong ho tro qua API - Vui long dat thu cong tren Binance');
        if (stopLoss && stopLoss > 0) {
          results.slNote = `Dat SL thu cong: ${roundPrice(stopLoss, symbolInfo.tickSize)}`;
          console.log('[Trade]', results.slNote);
        }
        if (takeProfit && takeProfit > 0) {
          results.tpNote = `Dat TP thu cong: ${roundPrice(takeProfit, symbolInfo.tickSize)}`;
          console.log('[Trade]', results.tpNote);
        }

        return results;

      } catch (error) {
        results.errors.push(error.message);
        throw { results, error: error.message };
      }
    }

    // Open position on Binance from signal
    async function openBinancePosition(side) {
      if (!binanceApiConfig.connected) {
        showToast({
          type: 'error',
          title: 'Chua ket noi Binance',
          message: 'Click vao nut khoa de cau hinh API Key truoc khi giao dich.'
        });
        return;
      }

      // Get elements with null checks
      const symbolEl = document.getElementById('symbol');
      const marginEl = document.getElementById('order-margin');
      const entryEl = document.getElementById('order-entry');
      const leverageEl = document.getElementById('order-leverage');
      const slEl = document.getElementById('order-sl');
      const tpEl = document.getElementById('order-tp');

      // Check if required elements exist
      if (!symbolEl || !marginEl || !entryEl || !leverageEl) {
        showToast({
          type: 'error',
          title: 'Loi',
          message: 'Vui long phan tich symbol truoc khi vao lenh. Chuyen sang tab "Phan tich 1 Symbol".'
        });
        return;
      }

      const symbol = symbolEl.value;
      const margin = parseFloat(marginEl.value);
      const entryPrice = parseFloat(entryEl.value);
      const leverage = parseInt(leverageEl.value);
      const stopLoss = slEl ? parseFloat(slEl.value) : 0;
      const takeProfit = tpEl ? parseFloat(tpEl.value) : 0;

      // Debug log
      console.log('[openBinancePosition] Form values:', {
        symbol,
        margin,
        entryPrice,
        leverage,
        stopLoss,
        takeProfit,
        slElValue: slEl?.value,
        tpElValue: tpEl?.value
      });

      if (!margin || !entryPrice || !leverage) {
        showToast({ type: 'error', title: 'Loi', message: 'Vui long nhap day du thong tin lenh' });
        return;
      }

      // Confirm before trading
      const confirmed = await showConfirm(
        `Xac nhan mo lenh ${side}`,
        `Symbol: ${symbol}<br>` +
        `Margin: ${margin} USDT<br>` +
        `Leverage: ${leverage}x<br>` +
        `Entry: ~$${entryPrice}<br>` +
        `<br><strong style="color: #ffc107;">Luu y: SL/TP can dat THU CONG tren app Binance sau khi vao lenh!</strong><br>` +
        `- Stop Loss de nghi: $${stopLoss}<br>` +
        `- Take Profit de nghi: $${takeProfit}<br>` +
        `<br><strong style="color: #ff5252;">Lenh se duoc thuc hien THAT tren Binance ${binanceApiConfig.testnet ? '(Testnet)' : '(Live)'}!</strong>`,
        false
      );

      if (!confirmed.confirmed) return;

      showToast({ type: 'info', title: 'Dang dat lenh...', message: 'Vui long doi...' });

      try {
        const results = await executeBinanceTrade(symbol, side, margin, leverage, entryPrice, stopLoss, takeProfit);

        const details = [
          { label: 'Order ID', value: results.mainOrder?.orderId || 'N/A' },
          { label: 'Quantity', value: results.mainOrder?.origQty || 'N/A' },
          { label: 'Gia vao', value: '$' + (results.mainOrder?.avgPrice || 'N/A') },
          { label: 'Status', value: results.mainOrder?.status || 'N/A' }
        ];

        // Hien thi huong dan dat SL/TP thu cong
        if (results.slNote) {
          details.push({ label: 'Stop Loss', value: results.slNote, class: 'warning' });
        }
        if (results.tpNote) {
          details.push({ label: 'Take Profit', value: results.tpNote, class: 'warning' });
        }

        showToast({
          type: 'success',
          title: `Lenh ${side} da mo thanh cong!`,
          message: `${symbol} - ${leverage}x | Dat SL/TP thu cong tren Binance!`,
          details,
          duration: 10000
        });

        // Also save to local positions for tracking
        openPosition(side);

        // Refresh balance
        testApiConnection();

      } catch (error) {
        const errMsg = error.error || error.message || 'Unknown error';
        showToast({
          type: 'error',
          title: 'Dat lenh that bai',
          message: errMsg,
          duration: 6000
        });
      }
    }

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', function() {
      // Show/hide admin-only features
      showBinanceFeatures();

      loadApiConfig();

      // Init chart modal
      initChartModal();

      // Init bot panel
      initBotPanel();
    });

    // ===================== BOT TRADER FUNCTIONS =====================
    let botStatusInterval = null;
    const BOT_STORAGE_KEY = 'trading_bot_data';

    // Lưu bot data vào localStorage
    function saveBotDataLocal(data) {
      try {
        const saveData = {
          openPositions: data.openPositions || [],
          tradeHistory: data.tradeHistory || [],
          stats: data.stats || {},
          savedAt: new Date().toISOString()
        };
        localStorage.setItem(BOT_STORAGE_KEY, JSON.stringify(saveData));
        console.log('[Bot] Data saved to localStorage');
      } catch (e) {
        console.error('[Bot] Error saving to localStorage:', e);
      }
    }

    // Load bot data từ localStorage
    function loadBotDataLocal() {
      try {
        const data = localStorage.getItem(BOT_STORAGE_KEY);
        if (data) {
          return JSON.parse(data);
        }
      } catch (e) {
        console.error('[Bot] Error loading from localStorage:', e);
      }
      return null;
    }

    function initBotPanel() {
      // Load initial bot status
      refreshBotStatus();

      // Auto refresh every 5 seconds when on bot tab
      setInterval(() => {
        const botTab = document.getElementById('bot-tab');
        if (botTab && botTab.style.display !== 'none') {
          refreshBotStatus();
        }
      }, 5000);
    }

    async function refreshBotStatus() {
      try {
        const response = await fetch(`${API_BASE}/api/bot/status`);
        const result = await response.json();

        if (result.success && result.data) {
          // Merge với localStorage data (ưu tiên server nếu có)
          // Server là nguồn chính - luôn dùng data từ server
          // Chỉ lưu lại vào localStorage để backup
          saveBotDataLocal(result.data);
          updateBotUI(result.data);
        }
      } catch (error) {
        console.error('Failed to fetch bot status:', error);
        // Nếu server không khả dụng, load từ localStorage
        const localData = loadBotDataLocal();
        if (localData) {
          console.log('[Bot] Using localStorage data (server unavailable)');
          updateBotUI({
            isRunning: false,
            config: { testMode: true, interval: '1h', scanInterval: 60, marginPerTrade: 5, maxOpenPositions: 3, minScore: 4 },
            ...localData
          });
        }
      }
    }

    function updateBotUI(data) {
      const { isRunning, config, stats, lastScan, openPositions, tradeHistory } = data;

      // Update status badge
      const statusBadge = document.getElementById('bot-status-badge');
      const statusText = document.getElementById('bot-status-text');
      const modeBadge = document.getElementById('bot-mode-badge');

      // Skip if bot UI elements don't exist (different tab active)
      if (!statusBadge || !statusText || !modeBadge) {
        return;
      }

      if (isRunning) {
        statusBadge.className = 'bot-status-badge running';
        statusText.textContent = 'Bot Running';
      } else {
        statusBadge.className = 'bot-status-badge stopped';
        statusText.textContent = 'Bot Stopped';
      }

      // Update mode badge
      if (config.testMode) {
        modeBadge.className = 'test-mode-badge';
        modeBadge.textContent = 'TEST MODE';
      } else {
        modeBadge.className = 'live-mode-badge';
        modeBadge.textContent = 'LIVE MODE';
      }

      // Update buttons
      const btnStart = document.getElementById('btn-start-bot');
      const btnStop = document.getElementById('btn-stop-bot');
      if (btnStart) btnStart.disabled = isRunning;
      if (btnStop) btnStop.disabled = !isRunning;

      // Update stats (with null checks)
      const el = (id, val) => { const e = document.getElementById(id); if (e) e.textContent = val; };
      el('bot-total-scans', stats.totalScans);
      el('bot-signals-found', stats.signalsFound);
      el('bot-trades-opened', stats.tradesOpened);
      el('bot-trades-closed', stats.tradesClosed);

      const pnlEl = document.getElementById('bot-total-pnl');
      if (pnlEl) {
        pnlEl.textContent = `$${stats.totalPnL.toFixed(2)}`;
        pnlEl.className = 'value ' + (stats.totalPnL >= 0 ? 'profit' : 'loss');
      }

      // Update last scan
      if (lastScan) {
        const scanTime = new Date(lastScan);
        el('bot-last-scan', scanTime.toLocaleTimeString('vi-VN'));
      }

      // Update config inputs (with null checks)
      const setVal = (id, val) => { const e = document.getElementById(id); if (e) e.value = val; };
      setVal('bot-interval', config.interval);
      setVal('bot-scan-interval', config.scanInterval);
      setVal('bot-margin', config.marginPerTrade);
      setVal('bot-max-positions', config.maxOpenPositions);
      setVal('bot-min-score', config.minScore);
      setVal('bot-test-mode', config.testMode ? 'true' : 'false');

      // Update open positions count
      el('bot-open-count', openPositions.length);

      // Render open trades
      renderBotOpenTrades(openPositions);

      // Render trade history
      renderBotTradeHistory(tradeHistory);
    }

    async function renderBotOpenTrades(positions) {
      const container = document.getElementById('bot-open-trades');

      if (!positions || positions.length === 0) {
        container.innerHTML = '<div class="no-trades">Chưa có lệnh nào đang mở</div>';
        return;
      }

      // Fetch giá hiện tại cho tất cả symbols
      const pricePromises = positions.map(async (trade) => {
        try {
          const response = await fetch(`https://fapi.binance.com/fapi/v1/ticker/price?symbol=${trade.symbol}`);
          const data = await response.json();
          return { symbol: trade.symbol, price: parseFloat(data.price) };
        } catch (e) {
          return { symbol: trade.symbol, price: trade.entryPrice };
        }
      });

      const prices = await Promise.all(pricePromises);
      const priceMap = {};
      prices.forEach(p => priceMap[p.symbol] = p.price);

      container.innerHTML = positions.map(trade => {
        const currentPrice = priceMap[trade.symbol] || trade.entryPrice;

        // Tính % SL và % TP
        const slPercent = trade.side === 'LONG'
          ? ((trade.stopLoss - trade.entryPrice) / trade.entryPrice * 100)
          : ((trade.entryPrice - trade.stopLoss) / trade.entryPrice * 100);
        const tpPercent = trade.side === 'LONG'
          ? ((trade.takeProfit - trade.entryPrice) / trade.entryPrice * 100)
          : ((trade.entryPrice - trade.takeProfit) / trade.entryPrice * 100);

        // Tính PnL hiện tại
        const pnlPercent = trade.side === 'LONG'
          ? ((currentPrice - trade.entryPrice) / trade.entryPrice * 100)
          : ((trade.entryPrice - currentPrice) / trade.entryPrice * 100);
        const pnlPercentLev = pnlPercent * trade.leverage;
        const pnlAmount = (pnlPercentLev / 100) * trade.margin;

        // Tính tiền SL/TP
        const slPercentLev = slPercent * trade.leverage;
        const tpPercentLev = tpPercent * trade.leverage;
        const slAmount = (slPercentLev / 100) * trade.margin;
        const tpAmount = (tpPercentLev / 100) * trade.margin;

        const pnlClass = pnlAmount >= 0 ? 'profit' : 'loss';
        const pnlSign = pnlAmount >= 0 ? '+' : '';

        return `
        <div class="bot-trade-card ${trade.side.toLowerCase()}">
          <div class="bot-trade-info">
            <div class="symbol">${trade.symbol}</div>
            <div class="side ${trade.side.toLowerCase()}">${trade.side} x${trade.leverage}</div>
            <div style="font-size: 0.8em; color: #888; margin-top: 5px;">Margin: $${trade.margin}</div>
          </div>
          <div class="bot-trade-prices">
            <div><span class="entry">Entry:</span> ${formatPrice(trade.entryPrice)}</div>
            <div><span style="color: #00d9ff;">Now:</span> ${formatPrice(currentPrice)}</div>
            <div><span class="sl">SL:</span> ${formatPrice(trade.stopLoss)} <span style="color: #ff5252;">(${slPercent.toFixed(2)}% | -$${Math.abs(slAmount).toFixed(2)})</span></div>
            <div><span class="tp">TP:</span> ${formatPrice(trade.takeProfit)} <span style="color: #00ff88;">(+${tpPercent.toFixed(2)}% | +$${tpAmount.toFixed(2)})</span></div>
          </div>
          <div class="bot-trade-pnl">
            <div class="pnl ${pnlClass}" style="font-size: 1.3em;">
              ${pnlSign}$${pnlAmount.toFixed(2)}
            </div>
            <div style="font-size: 0.85em;" class="${pnlClass}">
              ${pnlSign}${pnlPercentLev.toFixed(2)}%
            </div>
            <div style="font-size: 0.75em; color: #888; margin-top: 5px;">R:R = 1:${(Math.abs(tpPercent) / Math.abs(slPercent)).toFixed(1)}</div>
          </div>
          <div>
            <button onclick="closeBotTrade(${trade.id})" class="btn-bot-stop" style="padding: 8px 15px;">Close</button>
          </div>
        </div>
      `}).join('');
    }

    function renderBotTradeHistory(history) {
      const container = document.getElementById('bot-trade-history');

      if (!history || history.length === 0) {
        container.innerHTML = '<div class="no-trades">Chưa có lịch sử giao dịch</div>';
        return;
      }

      container.innerHTML = history.map(trade => `
        <div class="bot-trade-card ${trade.side.toLowerCase()}">
          <div class="bot-trade-info">
            <div class="symbol">${trade.symbol}</div>
            <div class="side ${trade.side.toLowerCase()}">${trade.side} x${trade.leverage}</div>
          </div>
          <div class="bot-trade-prices">
            <div><span class="entry">Entry:</span> ${formatPrice(trade.entryPrice)}</div>
            <div><span class="entry">Close:</span> ${formatPrice(trade.closePrice)}</div>
          </div>
          <div class="bot-trade-pnl">
            <div class="pnl ${trade.pnl >= 0 ? 'profit' : 'loss'}">
              ${trade.pnl >= 0 ? '+' : ''}$${trade.pnl.toFixed(2)}
            </div>
            <div style="font-size: 0.85em; color: #888;">
              ${trade.pnlPercent >= 0 ? '+' : ''}${trade.pnlPercent.toFixed(2)}%
            </div>
          </div>
          <div style="font-size: 0.85em; color: #888;">
            ${trade.closeReason || 'MANUAL'}
          </div>
        </div>
      `).join('');
    }

    async function startBot() {
      try {
        addBotLog('Starting bot...', 'info');

        const response = await fetch(`${API_BASE}/api/bot/start`, { method: 'POST' });
        const data = await response.json();

        if (data.success) {
          addBotLog('Bot started successfully!', 'success');
          showToast({ type: 'success', title: 'Bot Started', message: 'Auto trader is now running' });
          refreshBotStatus();
        } else {
          addBotLog(`Failed to start: ${data.error}`, 'error');
          showToast({ type: 'error', title: 'Error', message: data.error });
        }
      } catch (error) {
        addBotLog(`Error: ${error.message}`, 'error');
        showToast({ type: 'error', title: 'Error', message: error.message });
      }
    }

    async function stopBot() {
      try {
        addBotLog('Stopping bot...', 'info');

        const response = await fetch(`${API_BASE}/api/bot/stop`, { method: 'POST' });
        const data = await response.json();

        if (data.success) {
          addBotLog('Bot stopped', 'warn');
          showToast({ type: 'info', title: 'Bot Stopped', message: 'Auto trader has been stopped' });
          refreshBotStatus();
        } else {
          addBotLog(`Failed to stop: ${data.error}`, 'error');
        }
      } catch (error) {
        addBotLog(`Error: ${error.message}`, 'error');
      }
    }

    async function manualScanBot() {
      try {
        addBotLog('Manual scan triggered...', 'info');

        const response = await fetch(`${API_BASE}/api/bot/scan`, { method: 'POST' });
        const data = await response.json();

        if (data.success) {
          addBotLog(`Scan complete. Found ${data.signalsCount} signals`, 'success');
          if (data.signals && data.signals.length > 0) {
            data.signals.forEach(s => {
              addBotLog(`Signal: ${s.symbol} ${s.action} (Score: ${s.score})`, 'info');
            });
          }
          refreshBotStatus();
        } else {
          addBotLog(`Scan failed: ${data.error}`, 'error');
        }
      } catch (error) {
        addBotLog(`Error: ${error.message}`, 'error');
      }
    }

    async function updateBotConfig() {
      try {
        const config = {
          interval: document.getElementById('bot-interval').value,
          scanInterval: parseInt(document.getElementById('bot-scan-interval').value),
          marginPerTrade: parseFloat(document.getElementById('bot-margin').value),
          maxOpenPositions: parseInt(document.getElementById('bot-max-positions').value),
          minScore: parseInt(document.getElementById('bot-min-score').value),
          testMode: document.getElementById('bot-test-mode').value === 'true'
        };

        const response = await fetch(`${API_BASE}/api/bot/config`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(config)
        });

        const data = await response.json();

        if (data.success) {
          addBotLog('Config updated successfully', 'success');
          showToast({ type: 'success', title: 'Config Updated', message: 'Bot configuration has been updated' });
          refreshBotStatus();
        } else {
          addBotLog(`Failed to update config: ${data.error}`, 'error');
        }
      } catch (error) {
        addBotLog(`Error: ${error.message}`, 'error');
      }
    }

    // Đóng tất cả lệnh
    async function closeAllBotTrades() {
      const { confirmed } = await showModal({
        type: 'danger',
        title: 'Đóng tất cả lệnh',
        message: 'Bạn có chắc muốn đóng TẤT CẢ lệnh đang mở?<br><span style="color: #ff9800;">Tất cả lệnh sẽ được đóng ngay lập tức!</span>',
        confirmText: 'Đóng tất cả',
        cancelText: 'Hủy',
        dangerMode: true
      });
      if (!confirmed) return;

      try {
        addBotLog('Closing all trades...', 'info');

        const response = await fetch(`${API_BASE}/api/bot/close-all`, { method: 'POST' });
        const data = await response.json();

        if (data.success) {
          addBotLog(`Closed ${data.closedCount} trades. Total PnL: $${data.totalPnL.toFixed(2)}`, data.totalPnL >= 0 ? 'success' : 'error');
          showToast({
            type: data.totalPnL >= 0 ? 'success' : 'error',
            title: 'All Trades Closed',
            message: `Đóng ${data.closedCount} lệnh - Total PnL: $${data.totalPnL.toFixed(2)}`
          });
          refreshBotStatus();
        } else {
          addBotLog(`Failed: ${data.error}`, 'error');
        }
      } catch (error) {
        addBotLog(`Error: ${error.message}`, 'error');
      }
    }

    async function closeBotTrade(tradeId) {
      const { confirmed } = await showModal({
        type: 'warning',
        title: 'Đóng lệnh',
        message: 'Bạn có chắc muốn đóng lệnh này?',
        confirmText: 'Đóng lệnh',
        cancelText: 'Hủy',
        dangerMode: true
      });
      if (!confirmed) return;

      try {
        addBotLog(`Closing trade ${tradeId}...`, 'info');

        const response = await fetch(`${API_BASE}/api/bot/close/${tradeId}`, { method: 'POST' });
        const data = await response.json();

        if (data.success) {
          addBotLog(`Trade closed. PnL: $${data.trade.pnl.toFixed(2)}`, data.trade.pnl >= 0 ? 'success' : 'error');
          showToast({
            type: data.trade.pnl >= 0 ? 'success' : 'error',
            title: 'Trade Closed',
            message: `${data.trade.symbol} - PnL: $${data.trade.pnl.toFixed(2)}`
          });
          refreshBotStatus();
        } else {
          addBotLog(`Failed to close: ${data.error}`, 'error');
        }
      } catch (error) {
        // Server không khả dụng, đóng từ localStorage
        addBotLog(`Server unavailable, closing locally...`, 'warn');
        await closeBotTradeLocal(tradeId);
      }
    }

    // Đóng lệnh trực tiếp từ localStorage (khi server không khả dụng)
    async function closeBotTradeLocal(tradeId) {
      try {
        const localData = loadBotDataLocal();
        if (!localData || !localData.openPositions) {
          addBotLog('No local data found', 'error');
          return;
        }

        const tradeIndex = localData.openPositions.findIndex(t => t.id === tradeId);
        if (tradeIndex === -1) {
          addBotLog('Trade not found in local data', 'error');
          return;
        }

        const trade = localData.openPositions[tradeIndex];

        // Fetch giá hiện tại từ Binance
        let closePrice = trade.entryPrice;
        try {
          const priceRes = await fetch(`https://fapi.binance.com/fapi/v1/ticker/price?symbol=${trade.symbol}`);
          const priceData = await priceRes.json();
          closePrice = parseFloat(priceData.price);
        } catch (e) {
          addBotLog('Could not fetch price, using entry price', 'warn');
        }

        // Tính PnL
        const pnlPercent = trade.side === 'LONG'
          ? ((closePrice - trade.entryPrice) / trade.entryPrice) * 100
          : ((trade.entryPrice - closePrice) / trade.entryPrice) * 100;
        const pnl = (pnlPercent / 100) * trade.margin * trade.leverage;

        // Cập nhật trade
        trade.closePrice = closePrice;
        trade.closeTime = new Date().toISOString();
        trade.pnl = pnl;
        trade.pnlPercent = pnlPercent;
        trade.closeReason = 'MANUAL_LOCAL';
        trade.status = 'CLOSED';

        // Cập nhật stats
        localData.stats = localData.stats || { totalScans: 0, signalsFound: 0, tradesOpened: 0, tradesClosed: 0, totalPnL: 0 };
        localData.stats.tradesClosed = (localData.stats.tradesClosed || 0) + 1;
        localData.stats.totalPnL = (localData.stats.totalPnL || 0) + pnl;

        // Chuyển sang history
        localData.tradeHistory = localData.tradeHistory || [];
        localData.tradeHistory.push(trade);
        localData.openPositions.splice(tradeIndex, 1);

        // Lưu lại
        saveBotDataLocal(localData);

        addBotLog(`Trade closed locally. PnL: $${pnl.toFixed(2)}`, pnl >= 0 ? 'success' : 'error');
        showToast({
          type: pnl >= 0 ? 'success' : 'error',
          title: 'Trade Closed (Local)',
          message: `${trade.symbol} - PnL: $${pnl.toFixed(2)}`
        });

        // Refresh UI với local data
        updateBotUI({
          isRunning: false,
          config: { testMode: true, interval: '1h', scanInterval: 60, marginPerTrade: 5, maxOpenPositions: 3, minScore: 4 },
          ...localData
        });
      } catch (error) {
        addBotLog(`Local close error: ${error.message}`, 'error');
      }
    }

    // Xóa tất cả dữ liệu bot (localStorage và server)
    async function clearBotData() {
      const { confirmed } = await showModal({
        type: 'danger',
        title: 'Xóa dữ liệu',
        message: 'Bạn có chắc muốn XÓA TẤT CẢ dữ liệu bot?<br><span style="color: #ff9800;">Open positions, history, stats sẽ bị xóa!</span>',
        confirmText: 'Xóa tất cả',
        cancelText: 'Hủy',
        dangerMode: true
      });
      if (!confirmed) return;

      try {
        // Xóa localStorage
        localStorage.removeItem(BOT_STORAGE_KEY);
        addBotLog('Local data cleared', 'info');

        // Xóa trên server nếu có
        try {
          await fetch(`${API_BASE}/api/bot/clear`, { method: 'POST' });
          addBotLog('Server data cleared', 'info');
        } catch (e) {
          addBotLog('Server unavailable, only local data cleared', 'warn');
        }

        showToast({
          type: 'success',
          title: 'Data Cleared',
          message: 'Tất cả dữ liệu bot đã được xóa'
        });

        // Reset UI
        updateBotUI({
          isRunning: false,
          config: { testMode: true, interval: '1h', scanInterval: 60, marginPerTrade: 5, maxOpenPositions: 3, minScore: 4 },
          stats: { totalScans: 0, signalsFound: 0, tradesOpened: 0, tradesClosed: 0, totalPnL: 0 },
          lastScan: null,
          openPositions: [],
          tradeHistory: []
        });
      } catch (error) {
        addBotLog(`Clear error: ${error.message}`, 'error');
      }
    }

    function addBotLog(message, type = 'info') {
      const logsContainer = document.getElementById('bot-logs');
      const time = new Date().toLocaleTimeString('vi-VN');

      const logEntry = document.createElement('div');
      logEntry.className = `bot-log-entry ${type}`;
      logEntry.innerHTML = `<span class="time">[${time}]</span> ${message}`;

      logsContainer.appendChild(logEntry);
      logsContainer.scrollTop = logsContainer.scrollHeight;

      // Keep only last 50 logs
      while (logsContainer.children.length > 50) {
        logsContainer.removeChild(logsContainer.firstChild);
      }
    }
  </script>
</body>
</html>
